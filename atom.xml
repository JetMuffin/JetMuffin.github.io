<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>倦谈</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.jetmuffin.com/"/>
  <updated>2017-05-10T04:29:01.000Z</updated>
  <id>http://blog.jetmuffin.com/</id>
  
  <author>
    <name>JetMuffin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017 年系统软件与软件体系结构会议收集</title>
    <link href="http://blog.jetmuffin.com/2017/05/09/archive-of-system-and-architecture-conferences/"/>
    <id>http://blog.jetmuffin.com/2017/05/09/archive-of-system-and-architecture-conferences/</id>
    <published>2017-05-09T15:11:35.000Z</published>
    <updated>2017-05-10T04:29:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集整理了系统软件和体系结构方面的会议信息，具体如下：</p>
<a id="more"></a>
<h2 id="会议列表"><a href="#会议列表" class="headerlink" title="会议列表"></a>会议列表</h2><table>
<thead>
<tr>
<th>CCF等级</th>
<th>缩写</th>
<th>全称</th>
<th>2016/2017 submission deadline</th>
<th>主页</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>OSDI</td>
<td>USENIX Symposium on Operating Systems Design and Implementations</td>
<td>2016.05.10</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>ASPLOS</td>
<td>Architectural Support for Programming Languages and Operating Systems</td>
<td>2016.04.15</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td><strong>HPCA</strong></td>
<td>High-Performance Computer Architecture</td>
<td><strong>2017.07.25</strong></td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>ISCA</td>
<td>International Symposium on Computer Architecture</td>
<td>2016.11.18</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>SC</td>
<td>International Conference for High Performance Computing, Networking, Storage, and Analysis</td>
<td>2017.3.1</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>USENIX ATC</td>
<td>USENIX Annul Technical Conference</td>
<td>2017.02.07</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>PPoPP</td>
<td>Principles and Practice of Parallel Programming</td>
<td>2016.08.01</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>SPAA</td>
<td>ACM Symposium on Parallelism in Algorithms and Architectures</td>
<td>2017.02.09</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>PODC</td>
<td>ACM Symposium on Principles of Distributed Computing</td>
<td>2016.02.09</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>EuroSys</td>
<td>EoruSys</td>
<td>2016.10.21</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>HPDC</td>
<td>High-Performance Distributed Computing</td>
<td>2017.01.10</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>ICDCS</td>
<td>International Conference on Distributed Computing Systems</td>
<td>2016.12.05</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>SIGMETRICS</td>
<td>International Conference on Measurement and Modeling of Computer Systems</td>
<td>2016.10.11</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>SOCC</td>
<td>ACM Symposium on Cloud Computing</td>
<td>2017.05.05</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>Middleware</td>
<td>Conference on middleware</td>
<td>2017.05.29</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>HotOS</td>
<td>USENIX Workshop on Hot Topics in Operating Systems</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B</td>
<td><strong>Performance</strong></td>
<td>International Symposium on Computer Performance, Modeling, Measurements and Evaluation</td>
<td><strong>2017.06.19</strong></td>
<td></td>
</tr>
<tr>
<td>B</td>
<td><strong>ICSOC</strong></td>
<td>International Conference on Service Oriented Computing</td>
<td><strong>2017.06.06</strong></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>ASAP</td>
<td>Application-Specific Systems, Architectures, and Processors</td>
<td>2017.04.03</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>CLUSTER</td>
<td>Cluster Computing</td>
<td>2017.05.15</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>CCGRID</td>
<td>Cluster Computing and the Grid</td>
<td>2016.11.16</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>Euro-Par</td>
<td>European Conference on Parallel and Distributed Computing</td>
<td>2017.02.09</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>HPCC</td>
<td>IEEE International Conference on High Performance Computing and Communications</td>
<td>2017.06.01</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td><strong>ICPADS</strong></td>
<td>International Conference on Parallel and Distributed Systems</td>
<td><strong>2017.07.01</strong></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td><strong>ISPA</strong></td>
<td>International Symposium on Parallel and Distributed Processing with Applications</td>
<td><strong>2017.07.15</strong></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td><strong>APSEC</strong></td>
<td>Asia-Pacific Software Engineering Conference</td>
<td><strong>2017.06.30</strong></td>
</tr>
</tbody>
</table>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul>
<li><a href="https://ying-zhang.github.io/misc/2016-09-we-love-paper/" target="_blank" rel="external">如何收集和整理论文（面向CS专业）- ying-zhang 的博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集整理了系统软件和体系结构方面的会议信息，具体如下：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hihocoder 1489 legendary items 微软2017笔试第一场</title>
    <link href="http://blog.jetmuffin.com/2017/04/09/hihocoder-1489-legendary-items/"/>
    <id>http://blog.jetmuffin.com/2017/04/09/hihocoder-1489-legendary-items/</id>
    <published>2017-04-09T11:39:17.000Z</published>
    <updated>2017-04-09T12:32:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目地址 <a href="http://hihocoder.com/problemset/problem/1489" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1489</a></p>
<p>题目大意是，小 Hi 按一定的初始概率 <code>P</code> 夺宝（成功概率为 <code>P</code>，失败为 <code>1-P</code>，如果在某个关卡失败了，那么在下一个关卡他成功的概率会上升 <code>Q</code>；如果在某个关卡成功了，那么他在下个关卡成功的概率会变为 <code>⌊P/(2I)⌋</code>（<code>I</code> 为当前已经拿到的宝物数量）。问小 Hi 得到 N 个宝物需要闯关多少次。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>笔试的时候读题读了半天才弄懂题意，拿到手第一感觉是概率 dp，推一个一维公式推了好长一段时间，然后期间又转战另一个二维的递推方程，结果方程有了，实现的时候写了半天，最后没写出这道题。赛后把两个思路的代码都写完了，这里记录一下这两个思路。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p><strong>递推方程：</strong></p>
<p>$$ dp[i, j] = (i / 100) <em> ((dp[next_{i}, j+1] + 1) + ((100 - i) / 100 </em> (dp[i + q] + 1) $$</p>
<p>其中 $dp[i,j]$ 表示已经取了 $j$ 个宝物，当前状态闯关成功概率为 $i$ 时还需要 $dp[i,j]$ 步才能取完所有 N 个宝物。</p>
<p>那么公式中，前半部分为以$i/100$ 的概率闯关成功，那么还需要的步数为现在走的这一步加上下一个状态 $dp[next<em>{i}, j+1]$ 的剩余步数。其中 $next</em>{i}$ 为闯关成功后刷新的下一个状态的成功概率，即 <code>⌊P/(2I)⌋</code>。</p>
<p>后半部分为以 $(100 - i) / 100$ 概率闯关失败，那么还需要现在走的这一步加上下一个状态 $dp[i + q]$ 的剩余步数。</p>
<p>那么按这个思路的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> p, q, n;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000001</span>;</div><div class="line"><span class="keyword">double</span> dp[<span class="number">101</span>][maxn];</div><div class="line"><span class="keyword">int</span> nxt[maxn];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</div><div class="line">    nxt[<span class="number">0</span>] = p;</div><div class="line">    <span class="keyword">int</span> nxti, nxtii;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span> ; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            nxti = nxt[j+<span class="number">1</span>];</div><div class="line">            nxtii = i + q &gt;= <span class="number">100</span>? <span class="number">100</span> : i+q;</div><div class="line"></div><div class="line">            dp[i][j] = (i / <span class="number">100.0</span>) * (dp[nxti][j+<span class="number">1</span>] + <span class="number">1.0</span>) + (<span class="number">100</span> - i) / <span class="number">100.0</span> * (dp[nxtii][j] + <span class="number">1.0</span>);</div><div class="line">            <span class="comment">// printf("(%d %d)-&gt;(%lf %lf %lf %d) ;\n", i, j, (i / 100.0) * (dp[nxti][j+1] + 1), (100 - i) / 100.0 * (dp[min(i + q, 100)][j] + 1), dp[i][j], nxti);</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</div><div class="line">    nxt[<span class="number">0</span>] = p;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        nxt[i] = nxt[i - <span class="number">1</span>] / <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p, &amp;q, &amp;n);</div><div class="line">    pre();</div><div class="line">    solve();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp[p][<span class="number">0</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法的复杂度为 <code>O(100N)</code>，在 <code>1 ≤ N ≤ 1e6</code> 的情况下时间非常吃紧，后来交的几发提交都 T 了。</p>
<p>实际上从递推方程中可以发现的是，有许多情况下的概率 <code>i</code> 是不会出现的，那么也就没有必要遍历去求。在这个基础上用 dfs 加记忆化去求这个方程可能就可以减少计算量。</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><p><strong>递推方程：</strong></p>
<p>$$ dp[i] = \sum<em>{j=0}^{(100-s)/q} (s <em> j </em> \prod</em>{k=0}^{j-1}( 1 - (s+k*q))) $$</p>
<p>其中 $dp[i]$ 表示从取得 $i-1$ 个宝物到取得 $i$ 个物品需要的步数。严格意义上讲这并不是一个 dp，因为事实上每个 $dp[i]$ 是独立的。</p>
<p>公式中 $s$ 表示手上有 $i-1$ 个物品时的闯关成功概率。</p>
<p>在手上有 $i-1$ 个物品的情况下，最多失败 $(100-s)/q$ 次。</p>
<p>而失败 $j$ 次的概率是可以计算的，例如起始闯关成功概率 $s$，失败3次，那么总概率为 $(1-s)<em>(1-s+q)</em>(1-s+2q)*(s+2q)$ 再乘上步数就是期望了。</p>
<p>最后答案就是 $\sum_{i=0}^n dp[i]$</p>
<p>根据这个思路写的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000001</span>;</div><div class="line"><span class="keyword">double</span> dp[maxn];</div><div class="line"><span class="keyword">int</span> nxt[maxn];</div><div class="line"><span class="keyword">int</span> p, q, n;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</div><div class="line">    nxt[<span class="number">0</span>] = p;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        nxt[i] = nxt[i - <span class="number">1</span>] / <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</div><div class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">int</span> cnt = (<span class="number">100</span> - nxt[i<span class="number">-1</span>]) / q;</div><div class="line">        <span class="keyword">if</span>(cnt * q == <span class="number">100</span> - nxt[i<span class="number">-1</span>]) cnt--;</div><div class="line">        cnt++;</div><div class="line">        <span class="comment">// printf("i(%d) cnt(%d)\n", i, cnt);</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt; j++) &#123;</div><div class="line">            <span class="keyword">double</span> t = <span class="number">1.0</span>;</div><div class="line">            <span class="keyword">double</span> s = nxt[i<span class="number">-1</span>] / <span class="number">100.0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</div><div class="line">                t *= (<span class="number">1</span> - s);</div><div class="line">                <span class="comment">// printf("i(%d) j(%d) k(%d) %lf\n", i, j, k, 1 - s);</span></div><div class="line">                s += q / <span class="number">100.0</span>;</div><div class="line">            &#125;</div><div class="line">            t *= s &gt; <span class="number">1</span> ? <span class="number">1</span> : s;</div><div class="line">            t *= j + <span class="number">1</span>;</div><div class="line">            <span class="comment">// printf("s(%lf) t(%lf)\n", s, t);</span></div><div class="line">            dp[i] += t;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p, &amp;q, &amp;n)) &#123;</div><div class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">        pre();</div><div class="line">        solve();</div><div class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">            ans += dp[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个思路的复杂度为 <code>O(100N/q)</code> 平均情况会比上个方法好。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这场笔试雪崩，虽然还有一年，还是得多练。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目地址 &lt;a href=&quot;http://hihocoder.com/problemset/problem/1489&quot;&gt;http://hihocoder.com/problemset/problem/1489&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意是，小 Hi 按一定的初始概率 &lt;code&gt;P&lt;/code&gt; 夺宝（成功概率为 &lt;code&gt;P&lt;/code&gt;，失败为 &lt;code&gt;1-P&lt;/code&gt;，如果在某个关卡失败了，那么在下一个关卡他成功的概率会上升 &lt;code&gt;Q&lt;/code&gt;；如果在某个关卡成功了，那么他在下个关卡成功的概率会变为 &lt;code&gt;⌊P/(2I)⌋&lt;/code&gt;（&lt;code&gt;I&lt;/code&gt; 为当前已经拿到的宝物数量）。问小 Hi 得到 N 个宝物需要闯关多少次。&lt;/p&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://blog.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="概率dp" scheme="http://blog.jetmuffin.com/tags/%E6%A6%82%E7%8E%87dp/"/>
    
  </entry>
  
  <entry>
    <title>使用Ansible进行服务器自动化运维</title>
    <link href="http://blog.jetmuffin.com/2017/04/05/use-ansible-for-automatic-cluster-operation/"/>
    <id>http://blog.jetmuffin.com/2017/04/05/use-ansible-for-automatic-cluster-operation/</id>
    <published>2017-04-05T11:04:04.000Z</published>
    <updated>2017-04-05T11:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。</p>
</blockquote>
<a id="more"></a>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>Virtualbox &amp;&amp; Vagrant，安装 CentOS 7。用 Vagrant 自动分配 CPU、内存以及 IP。共两台虚拟机，一台为 master，一台为 slave，以模拟集群下环境。</p>
<ul>
<li>IP: 192.168.32.10(master) 192.168.32.11(slave)</li>
<li>子网掩码：255.255.255.0</li>
<li>用户：root</li>
</ul>
<h2 id="Ansible-脚本使用流程"><a href="#Ansible-脚本使用流程" class="headerlink" title="Ansible 脚本使用流程"></a>Ansible 脚本使用流程</h2><h3 id="安装-Ansible"><a href="#安装-Ansible" class="headerlink" title="安装 Ansible"></a>安装 Ansible</h3><p>Ansible 可以直接通过 yum 的 epel 源进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -y install epel-release</div><div class="line">yum -y install ansible</div></pre></td></tr></table></figure>
<h3 id="配置-ssh-无密码登陆"><a href="#配置-ssh-无密码登陆" class="headerlink" title="配置 ssh 无密码登陆"></a>配置 ssh 无密码登陆</h3><p>Ansible 在集群的机器之间所有的操作都是基于 ssh 进行的，因此需要配置每台机器上 master 的无密码登陆。这里我们只要配置 slave 这台机器即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -P <span class="string">""</span></div><div class="line">ssh-copy-id slave</div></pre></td></tr></table></figure>
<p>配置完 ssh-key 后尝试从 master 登录 slave，若不需密码则配置成功。</p>
<h3 id="Ansible-脚本使用"><a href="#Ansible-脚本使用" class="headerlink" title="Ansible 脚本使用"></a>Ansible 脚本使用</h3><p>从 gitlab 上 clone Ansible 运维的 playbooks 至 master，playbooks 的目录层级如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ics-cluster/ansible</div><div class="line">tree</div><div class="line">├── bin</div><div class="line">│   └── setup.sh</div><div class="line">├── firewall.yml</div><div class="line">├── group_vars</div><div class="line">│   └── all</div><div class="line">├── hosts</div><div class="line">├── keys.yml</div><div class="line">├── roles</div><div class="line">│   ├── authorized_keys</div><div class="line">│   ├── autofs</div><div class="line">│   ├── common</div><div class="line">│   ├── firewalld</div><div class="line">│   ├── nfs</div><div class="line">│   ├── nis</div><div class="line">│   ├── ntp</div><div class="line">│   └── user</div><div class="line">├── setup.retry</div><div class="line">├── setup.yml</div><div class="line">└── user.yml</div></pre></td></tr></table></figure>
<p>其中根目录下的 <code>yml</code> 文件为指定功能的 playbook，运行方法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible-playbook -i host xxx.yml</div></pre></td></tr></table></figure>
<p>若需要对过程进行 debug，在命令后加上 <code>-vvv</code> 参数即可。</p>
<h3 id="Playbook-编写"><a href="#Playbook-编写" class="headerlink" title="Playbook 编写"></a>Playbook 编写</h3><p>编写 playbook 需要按照在单机上配置软件的过程，大体包括三个部分：安装软件、配置软件和启动服务。因此 <code>package</code>，<code>template</code> 和 <code>service</code> 是经常使用的三个模块。</p>
<p>根据具体需要部署的软件的部署流程，依次在 playbook 中写好每个阶段的任务。其中可能还会涉及到选择分支等高级用法，具体详询 <a href="http://docs.ansible.com/ansible/playbooks.html" target="_blank" rel="external">Ansible Playbook Documents</a>。</p>
<h2 id="具体问题解决"><a href="#具体问题解决" class="headerlink" title="具体问题解决"></a>具体问题解决</h2><p>在配置集群环境以及编写 ansible playbooks 的过程中，会遇到非常多的坑，这里记录了一些可能会遇到的问题。</p>
<h4 id="1-ansible-在某个节点-setup-阶段卡住"><a href="#1-ansible-在某个节点-setup-阶段卡住" class="headerlink" title="1. ansible 在某个节点 setup 阶段卡住"></a>1. ansible 在某个节点 setup 阶段卡住</h4><p>Setup 阶段 ansible 主要收集机器节点的一些信息，而在这个阶段卡住原因可能出在文件系统（fs）和挂载点（mounts）上。因此登录到这个节点上使用 <code>df</code> 或者 <code>mount</code> 去人为检查文件系统是否出现问题。</p>
<h4 id="2-在-目录下-df-或-ls-卡住"><a href="#2-在-目录下-df-或-ls-卡住" class="headerlink" title="2. 在 / 目录下 df 或 ls 卡住"></a>2. 在 / 目录下 df 或 ls 卡住</h4><p>出现这种状况极有可能的原因是挂载点的问题。检查 <code>/etc/fstab</code> 中所有挂载点是否正常。如果在 <code>/etc/fstab</code> 中配置了自动挂载 nfs，那么如果 nfs-server 挂掉了，就会导致 nfs-client 上的 <code>df</code> 或 <code>ls</code> 卡住。</p>
<p>当然在这种状况下使用 <code>umount /exports</code> 也会卡住，需要使用 <code>umount -l /exports</code> 来解除挂载。</p>
<h4 id="3-ypbind-服务无法启动"><a href="#3-ypbind-服务无法启动" class="headerlink" title="3. ypbind 服务无法启动"></a>3. ypbind 服务无法启动</h4><p>配置 NIS 时，在 client 上启动 <code>ypbind</code> 服务时会出现启动超时的问题，主要的原因是 client 无法和 server 端通信。以下是两个排查的方向：</p>
<ol>
<li>检查 server 端的防火墙配置（iptables 或 firewalld），打开 <code>ypserv</code> 和 <code>yppasswdd</code> 的端口</li>
<li>server 端在初次启动 <code>ypserv</code> 后需要对 yp 进行初始化，运行 <code>ypinit -m</code></li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="docs.ansible.com">Ansible Documentation</a></li>
<li><a href="http://cn.linux.vbird.org/linux_server/0330nfs.php" target="_blank" rel="external">鸟哥的Linux 私房菜– NFS 服务器
</a></li>
<li><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=nis" target="_blank" rel="external">Configure NIS Server</a></li>
<li><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=nis&amp;f=2" target="_blank" rel="external">Configure NIS Client</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://blog.jetmuffin.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ansible" scheme="http://blog.jetmuffin.com/tags/ansible/"/>
    
      <category term="centos" scheme="http://blog.jetmuffin.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>除法取模（逆元求法）总结</title>
    <link href="http://blog.jetmuffin.com/2017/03/15/method-of-computing-inverse-of-number/"/>
    <id>http://blog.jetmuffin.com/2017/03/15/method-of-computing-inverse-of-number/</id>
    <published>2017-03-15T10:49:31.000Z</published>
    <updated>2017-04-05T11:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷的笔试题和以前打 ACM 中经常遇到求某个公式，最后的结果需要对某个数取模。我们都知道除法无法直接取模，即  $\frac{a}{b} \bmod c \neq \frac{a \bmod c}{b \bmod c} \bmod c$（当然，$ a \mid b $）。因此需要对 $b$ 求逆元，即 $\frac{a}{b} \bmod c = (a \bmod c)*(b^{‘} \bmod c) \bmod c $ 。这里总结一下求逆元的方法。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于正整数 $a$ 和 $m$，如果有 $ax \equiv 1 \pmod m$，那么把同余方程组里 $x$ 的最小正整数解称为 $a$ 模 $m$ 的逆元。</p>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p><strong>前提：$a$ 与 $m$ 互质</strong>。</p>
<p>一般情况下题目会给小于 <code>int</code> 的最大素数 <code>1e9+7</code>，那么费马小定力就可以用了。</p>
<p>$$ a^{m-1} \equiv 1 \pmod m \Rightarrow a \cdot a^{m-2} \equiv 1 \pmod m \Rightarrow a^{m-2} \equiv \frac{1}{a} \pmod m $$</p>
<p>那么逆元即为 $a^{m-2} \bmod m$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(b) &#123;</div><div class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</div><div class="line">      res = a * res % mod;</div><div class="line">    &#125;</div><div class="line">    a = a * a % mod;</div><div class="line">    a &gt;&gt;= <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> quick_pow(a, mod - <span class="number">2</span>) % mod;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p><strong>前提：$a$ 与 $m$ 互质</strong></p>
<p>由逆元定义可知，给定模数 $m$，求 $a$ 的逆相当于求解 $ax \equiv 1 \pmod m$。方程可以转化为 $ax-my=1$。那么当 $gcd(a, m) = 1$ 时，可以通过扩展欧几里得算法算出解，再将算出的特解转化到 $[0,m−1]$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ext_gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</div><div class="line">    x = <span class="number">1</span>;</div><div class="line">    y = <span class="number">0</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    ext_gcd(b, a % b, x, y);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t;</div><div class="line">    t = x;</div><div class="line">    x = y;</div><div class="line">    y = t - a / b * y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> now, t;</div><div class="line">  ext_gcd(x, mod, now, t);</div><div class="line">  <span class="keyword">return</span> (now % mod + mod) % mod;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>TBD</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刷的笔试题和以前打 ACM 中经常遇到求某个公式，最后的结果需要对某个数取模。我们都知道除法无法直接取模，即  $\frac{a}{b} \bmod c \neq \frac{a \bmod c}{b \bmod c} \bmod c$（当然，$ a \mid b $）。因此需要对 $b$ 求逆元，即 $\frac{a}{b} \bmod c = (a \bmod c)*(b^{‘} \bmod c) \bmod c $ 。这里总结一下求逆元的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法分析" scheme="http://blog.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数论" scheme="http://blog.jetmuffin.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="逆元" scheme="http://blog.jetmuffin.com/tags/%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>矩形计数 hihocoder 1476</title>
    <link href="http://blog.jetmuffin.com/2017/03/05/counting-rectangle-hihocoder-1476/"/>
    <id>http://blog.jetmuffin.com/2017/03/05/counting-rectangle-hihocoder-1476/</id>
    <published>2017-03-05T12:18:11.000Z</published>
    <updated>2017-04-05T10:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目地址 <a href="http://hihocoder.com/problemset/problem/1476" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1476</a></p>
<p><img src="https://media.hihocoder.com//problem_images/20170305/14886790334060.png" alt="图1"></p>
<a id="more"></a>
<p>如图所示， 给定的矩形中有 K 个单位正方形是黑色的，其余是白色的，求多少个不同的子矩形是完全由白色的正方形组成的。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接算由白色正方形组成的不好计数，需要反向通过减去包含黑色方块的计算更方便。但是减去黑色方块时需要用<strong>容斥原理</strong>。即总矩形数减去包含 1 个黑色方格的矩形数，加上包含 2 个黑色方格的矩形数，减去包含 3 个黑色方格的矩形数……依次类推。</p>
<p>可以想到的是，对于 n <em> m 大小的矩形，包含的所有子矩形的个数的 $\binom{n}{2} </em> \binom{m}{2}$。</p>
<p>而包含 t 个黑色方格的矩形数，可以首先处理出所有这些黑色方格的范围的四条线，$x_1$，$x_2$， $y_1$，$y_2$，那么如果矩形要包括所有的黑格，它的上横线必然从 $[0, x_1]$ 取，下横线从 $[x_2, n]$ 取，那么横线的取法有 $\binom{x_1}{1} <em> \binom{n - x_2 + 1}{1}$ 种，同理可得纵线取值，最后可以得到包含黑色方格的取法一共有 $x_1</em>(n-x_2+1)<em>y_1</em>(m-y_2+1)$ 种。</p>
<p>最后通过容斥原理统计一遍即可。</p>
<p><img src="http://cdn.jetmuffin.com/posts/hihocoder_1476.png" alt="图2"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f</span>;</div><div class="line">ll n, m, k;</div><div class="line">ll r[maxn], c[maxn];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k)) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;r[i], &amp;c[i]);</div><div class="line">		&#125;</div><div class="line">		ll ans = n * (n + <span class="number">1</span>) / <span class="number">2</span> * m * (m + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); i++) &#123;</div><div class="line">			<span class="keyword">int</span> num = __builtin_popcount(i);</div><div class="line">			<span class="keyword">int</span> x1 = inf, x2 = <span class="number">0</span>, y1 = inf, y2 = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</div><div class="line">				<span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</div><div class="line">					<span class="keyword">if</span>(x1 &gt; r[j]) x1 = r[j];</div><div class="line">					<span class="keyword">if</span>(x2 &lt; r[j]) x2 = r[j];</div><div class="line">					<span class="keyword">if</span>(y1 &gt; c[j]) y1 = c[j];</div><div class="line">					<span class="keyword">if</span>(y2 &lt; c[j]) y2 = c[j];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>) ans += x1 * y1 * (n - x2 + <span class="number">1</span>) * (m - y2 + <span class="number">1</span>);</div><div class="line">			<span class="keyword">else</span> ans -= x1 * y1 * (n - x2 + <span class="number">1</span>) * (m - y2 + <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目地址 &lt;a href=&quot;http://hihocoder.com/problemset/problem/1476&quot;&gt;http://hihocoder.com/problemset/problem/1476&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://media.hihocoder.com//problem_images/20170305/14886790334060.png&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://blog.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="容斥原理" scheme="http://blog.jetmuffin.com/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Counting Hamming Numbers</title>
    <link href="http://blog.jetmuffin.com/2017/02/18/Counting-Hamming-Numbers/"/>
    <id>http://blog.jetmuffin.com/2017/02/18/Counting-Hamming-Numbers/</id>
    <published>2017-02-18T02:26:40.000Z</published>
    <updated>2017-04-05T10:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://oeis.org/A051037" target="_blank" rel="external">Hamming Number</a> 是一类特殊的数，他们的因数仅为2，3，5 中的任意组合。形式化地说即：</p>
<p>$$x = 2^i \times 3^j \times 5^k, i,j,k \geq 0, \forall x \in H$$</p>
<a id="more"></a>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>若要求解 Hamming Number，第一反应是使用一个最小堆来维护整个数列，不断从堆里取出最小的数 <code>top</code>，再往堆里放入 <code>2*top</code>，<code>3*top</code>，<code>5*top</code>，同时对拿出来的数进行去重，整个计算的复杂度是 <code>O(logn)</code> 的。</p>
<p>大概的解决代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">countHammingNumber</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">  priority_queue&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt; &gt; q;</div><div class="line">  <span class="keyword">long</span> peak = <span class="number">1</span>;</div><div class="line">  q.push(<span class="number">2</span>);</div><div class="line">  q.push(<span class="number">3</span>);</div><div class="line">  q.push(<span class="number">5</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">    peak = q.top();</div><div class="line">    q.pop();</div><div class="line">    <span class="keyword">if</span>(!q.empty()) &#123;</div><div class="line">      <span class="keyword">while</span>(q.top() == peak) &#123;</div><div class="line">        q.pop();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    q.push(peak * <span class="number">2</span>);</div><div class="line">    q.push(peak * <span class="number">3</span>);</div><div class="line">    q.push(peak * <span class="number">5</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这样处理，最小堆每次取出的数放进一个数组里则这个数组里就全是 Hamming Number 了。</p>
<p>然而这样的处理比较耗时，再仔细分析 Hamming Number 的由来可以想到：</p>
<p>x（Hamming Number） 的因数仅存在 2、3、5，那么只要 count 2、3、5 的个数即可了。列一个表可以表示为：</p>
<table>
<thead>
<tr>
<th>n-th</th>
<th>5</th>
<th>3</th>
<th>2</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>从表中可以看出 Hamming Number 的递推过程存在一定规律，可以用 dp 的思路去解决，大体可以表示成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i] = min(dp[j]*2, dp[k]*3, dp[l]*5)</div></pre></td></tr></table></figure>
<p>即我们维护上表中的 <code>5、3、2</code> 因子为 <code>j、k、l</code>，那么当计算某个 <code>n-th</code> 即 <code>i</code> 时，<code>dp[i]</code> 就通过上式子递推得出。这样求解的话复杂度为 <code>O(n)</code></p>
<p>代码大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countHammingNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> dp[<span class="number">1690</span>];</div><div class="line">  <span class="keyword">int</span> j = <span class="number">1</span>, k = <span class="number">1</span>, l = <span class="number">1</span>;</div><div class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">    dp[i] = min(<span class="number">2</span> * dp[j], min(<span class="number">3</span> * dp[k], <span class="number">5</span> * dp[l]));</div><div class="line">    <span class="keyword">if</span>(dp[i] == <span class="number">2</span> * dp[j]) j++;</div><div class="line">    <span class="keyword">if</span>(dp[i] == <span class="number">3</span> * dp[k]) k++;</div><div class="line">    <span class="keyword">if</span>(dp[i] == <span class="number">5</span> * dp[l]) l++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><a href="https://leetcode.com/problems/ugly-number/?tab=Description" target="_blank" rel="external">Ugly Number</a></li>
<li><a href="https://leetcode.com/problems/ugly-number-ii/?tab=Description" target="_blank" rel="external">Ugly Number II</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://oeis.org/A051037&quot;&gt;Hamming Number&lt;/a&gt; 是一类特殊的数，他们的因数仅为2，3，5 中的任意组合。形式化地说即：&lt;/p&gt;
&lt;p&gt;$$x = 2^i \times 3^j \times 5^k, i,j,k \geq 0, \forall x \in H$$&lt;/p&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://blog.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="prime" scheme="http://blog.jetmuffin.com/tags/prime/"/>
    
      <category term="因数分解" scheme="http://blog.jetmuffin.com/tags/%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>集群调度架构的发展</title>
    <link href="http://blog.jetmuffin.com/2017/01/02/The-evoolution-of-cluster-scheduler-architectures/"/>
    <id>http://blog.jetmuffin.com/2017/01/02/The-evoolution-of-cluster-scheduler-architectures/</id>
    <published>2017-01-02T12:41:33.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章翻译自<a href="http://firmament.io/blog/scheduler-architectures.html" target="_blank" rel="external">《The evolution of cluster scheduler architectures》</a>，原作者为 Cambridge 的 Sys@Scale 实验室。</p>
<a id="more"></a>
<blockquote>
<p>集群调度器作为当今基础设施架构中重要的组件，在近几年中发展非常迅速。它们的结构从整体化的设计逐渐松散化，分布式化，变得更为灵活。然而，许多现在的开源实现要么仍然采用整体化设计，要么缺少重要的功能，而这些功能则正是关系到现实世界的用户所关心的问题，即他们要求实现的高利用。</p>
</blockquote>
<p>这篇文章是我们撰写的一个系列中的第一篇。这个系列阐述关于如何在大型集群调度任务，像那些互联网公司如 Amazon，Google，Facebook，Microsoft，Yahoo!等所在生产实践中所做的那样。调度是一个重要的主题，因为它直接影响着操作一个集群的代价。例如一个差的调度器会导致集群的使用率低下，这就意味着昂贵的服务器大部分在空闲着，必然造成经济上的损失。然而集群高使用率不仅仅是针对单个任务而言，因为任务之间往往会相互影响，这也就要求调度器在决策上更加地细致，小心。</p>
<h2 id="架构发展"><a href="#架构发展" class="headerlink" title="架构发展"></a>架构发展</h2><p>这篇文章讨论调度器的结构在近几年来是如何发展的，以及为什么这么发展。如图一所示，当前的调度器主要有以下几种不同的调度模式。其中灰色的正方形表示机器节点，彩色的圆形表示任务，而带有“S”的圆角矩形则代表调度器。箭头显示了调度器的调度决策，而三种不同的颜色（红黄蓝）则表示了不同的任务类型（例如 web 服务，批处理分析以及机器学习任务）。</p>
<p><img src="http://cdn.jetmuffin.com/posts/scheduler-arch-sharestate.png" alt="图1"></p>
<h3 id="中央调度架构"><a href="#中央调度架构" class="headerlink" title="中央调度架构"></a>中央调度架构</h3><p>许多集群调度器是<strong>中央调度架构</strong>的，例如大多数的高性能计算中的调度器，<a href="#">Borg 调度器</a>，一些早期的 Hadoop 中的调度器以及现在 Kubernetes 中的调度器。这种模式会在集群的某台机器上允许一个单独的调度进程（例如 Hadoop v1 中的 <code>JobTracker</code> 和 Kubernetes 中的 <code>kube-scheduler</code>），而这个调度进程负责分配任务到每台机器节点上。所有任务都是由一个调度器处理，也就是说所有的任务均是由一个调度逻辑进行分配的（如图 1a 所示）。这种架构简单一致，在许多越来越复杂的调度器中采用。例如 <a href="#">Paragon</a> 和 <a href="#">Quasar</a>，使用机器学习的方法来防止任务之间的资源竞争的调度器，也使用了这种调度模式。</p>
<p>相比于早些时候的 Hadoop 上的 MapReduce 任务，当前的集群允许的应用种类越来越多，不再针对单一的任务。然而，维护一个中央调度器来处理多类型混合任务是相当棘手的，原因有以下几点：</p>
<ol>
<li>很明显调度器在应该用不同方式处理长时间服务作业（Long-running service jobs）和批处理作业（batch jobs）。</li>
<li>不同的应用有不同的需求，需要满足他们所有的需求相当于不断在调度器上增加功能，这也使得调度器的逻辑和实现越来越复杂。</li>
<li>调度器处理任务的顺序也会成为一个问题，队列的影响（例如 head-of-line blocking）和任务存储将难以处理，除非调度器是精心设计的。</li>
</ol>
<p>总之，这些问题将造成工程上的噩梦，调度器的维护者将收到源源不断的功能需求而没法实现它。</p>
<h3 id="两层调度架构"><a href="#两层调度架构" class="headerlink" title="两层调度架构"></a>两层调度架构</h3><p><strong>两层调度架构</strong>通过分离<em>资源分配</em>和<em>任务调度</em>这两部分来解决了这个问题。它上层允许针对不同的应用定制不同的任务分配逻辑，同时维持他们共用集群的能力。<a href="#">Mesos</a>最先使用了这种架构，<a href="#">YARN</a>也在某个版本之后开始支持。在 Mesos 中，底层资源管理器将资源以 <code>offer</code> 的形式提供给应用级的调度器，这些调度器可以在其中选择适合的 <code>offer</code> 并使用它来运行任务。而 YARN 中则允许应用级的调度器向底层资源管理器请求资源。图 1b 显示了这种架构模式：针对任务定制的调度器（S0-S2）和资源管理器进行交互，动态地对资源进行分片，分配给各个任务。总体而言，这是一种灵活的，允许根据任务类型进行定制的架构模式。</p>
<p>但是，两层调度框架分层的思想也存在着缺陷。应用层的调度器无法获得上帝视角，例如他们无法看到<em>所有</em>可能的调度选项。相反，他们仅仅能够看到通过资源管理器提供的资源对应的调度选项。这就存在着一些缺点：</p>
<ol>
<li>优先级将难以实现：在基于 <code>offer</code> 的调度模型（Mesos）中，上层调度器无法看到分配给正在运行的任务的资源；在基于请求（YARN）的调度模型中，底层的资源管理器必须知道优先级策略（这和两层调度模式相矛盾）。</li>
<li>因为调度器无法看到所有的资源，它无法确认运行任务是否会影响降低资源的质量。</li>
<li>根据应用定制的调度器可能需要关注来自下层的资源中的许多不同的方面的信息，而他们仅仅能通过和底层资源管理器的接口获知这些内容，这也就导致这些接口可能会变得十分复杂。</li>
</ol>
<h3 id="共享状态架构"><a href="#共享状态架构" class="headerlink" title="共享状态架构"></a>共享状态架构</h3><p><strong>共享状态架构</strong>采用了一种半分布式的模型来解决上述的这些问题。在这个架构中，每个应用层的调度器相互独立地更新集群状态的多个副本，如图 1c 中所示。在这些变化在本地进行以后，调度器会进行启动一个乐观一致的事物去更新共享集群状态。当然这个事物也会失败，不同的调度器在同一时间进行了进行的变动可能会存在矛盾。</p>
<p>共享状态架构最典型的设计例子就是 Google 的 <a href="#">Omega</a> 了，其次就是微软的 <a href="#">Apollo</a>，以及 Hashicorp 的 [Nomad] 容器调度器。这些调度器都是将集群的共享状态储存在单个位置上，例如 Omega 中的 <code>cell state</code>，Apollo 中的 <code>resource monitor</code> 以及 Nomad 中的 <code>plan queue</code>。区别于其他两个调度框架，Apollo 中共享状态是只读的，同时调度事务是直接通过集群机器提交的。这些机器会自己确认是否存在矛盾，以及接受和拒绝这些变动。这也使得 Apollo 在集群共享状态暂时不可访问时也能短暂工作。</p>
<p>逻辑上的共享状态架构设计允许不在整个集群上实现完全的状态共享。在这种设计中（类似 Apollo 的设计），每台机器维护它自己的状态，发送要更新的状态到不同的 agent 上，例如调度器，机器的健康监控器，以及资源监控系统。每台机器局部的共享状态构成了整个集群的全局共享状态。</p>
<p>然而共享状态架构同样也有缺陷。和中央调度不同的是，共享状态总是处理着旧的集群状态信息，而不是实时的信息。这可能在高并发的场景下会降低调度器的性能。</p>
<h3 id="完全分布式架构"><a href="#完全分布式架构" class="headerlink" title="完全分布式架构"></a>完全分布式架构</h3><p><strong>完全分布式架构</strong>则将结构分解的更加彻底，如图 1d 所示，它甚至在调度器中没有协调者，仅仅是使用各个独立的调度器来对任务提供调度服务。这种架构中，每个调度器只是处理它本地的，部分的，常常过时的集群信息。作业可以提交到任意的调度器上，每个调度器可以调配任务到集群中的任意一个位置。和两层调度架构不同的是，它的调度器不负责对集群资源进行分片。相反，所有的调度和资源分片是任务在统计学上的多元性和随机性以及调度器的决策形成的结果。</p>
<p>虽然在之前有关于相关概念（利用多元随机决策）<a href="#">在1996年发表</a>，最近的关于完全分布式架构的调度器的文章大概是从 <a href="#">Sparrow</a> 的文章开始的。Sparrow 的主要前提是基于一个假设，即我们在集群中运行的任务在执行时间上在不断缩短，因为任务的划分粒度变得更加细粒度了。因此，作者假设瞬时任务数量变得更加庞大，这也就意味着调度器的决策吞吐量将会变得很大。而单个调度器可能支撑不了这么大的吞吐量（可能达到每秒百万个任务），Sparrow 想要将负载分配到多个调度器上。</p>
<p>这可能带来一些完美的作用，从概念上可以显示省去了中央的控制，同时它非常满足一些任务的需求——在之后的文章中会提到。在这里，以下一些原因足以显示这种分布式的，无中心协调的调度模式，在逻辑上相比比中央控制的，两层调度的，或共享状态的调度器，过于简单。例如：</p>
<ol>
<li>分布式的调度器通常基于简单的 <code>&quot;slot&quot;</code> 概念，把每台机器细分成 n 个一致的 slot，在其中运行 n 个并行的任务。这简化了任务的资源需求不一致的问题，然而在现实中这个不一致的问题是存在的。</li>
<li>它同样会在 worker 上使用一些特定的队列（例如 Sparrow 中的 FIFO），这会限制调度的灵活性，因为这种架构下的调度器只能从集群中选择一台机器来讲一个任务入队。</li>
<li>因为分布式调度器没有中心控制，它在使用全局约束上回存在问题（例如要求公平性策略或者严格的优先级顺序时）</li>
<li>由于它是为了基于最少的信息来做快速的决策而设计的，分布式调度器难以支持复杂的或者应用指定的调度策略。换言之，这种调度目前能架构处理的任务相对比较简单。例如对相互影响的任务它在处理上将会十分棘手。</li>
</ol>
<h3 id="混合式架构"><a href="#混合式架构" class="headerlink" title="混合式架构"></a>混合式架构</h3><p>最近在学术上提出了<strong>混合式架构</strong>，为了解决完全分布式架构的问题，它将中央调度和共享状态调度设计相结合。它的工作方式是，将所有任务通过两种途径进行调度，对于短任务和低优先级批处理任务通过分布式调度来进行分配，而其他的任务则通过中央调度来分配，例如 <a href="#">Tarcil</a>，<a href="#">Mercury</a> 和 <a href="#">Hawk</a>，图 1e 显示了这种设计模式的工作原理。这种设计的好处是，混合调度器混用了上述几种调度架构模式来避免各自的缺点。但据笔者所知，目前没有这种调度器用于生产实践中。</p>
<h2 id="在实践中的结果"><a href="#在实践中的结果" class="headerlink" title="在实践中的结果"></a>在实践中的结果</h2><p>讨论不同调度架构之间相对的优缺点不仅仅是学术上的话题，同样需要在工业界生产实践中去考虑考虑诸如 Borg，Mesos 和 Omega 之类的文章。更进一步的是，许多上面讨论到的系统已经在许多大企业中投入生产使用，例如微软的 Apollo，谷歌的 Borg 和 Apple 的 Mesos，它们同样启示其他的系统可能作为开源项目在生产中使用也是可行的。</p>
<p>最近几年，许多集群允许容器华的任务，导致了许多不同的基于容器的“编排框架”开始出现。这也和谷歌以及其他公司声称的“集群管理者”相类似。然而，集群调度器上仍然有许多细节需要讨论，例如他们的设计原则，他们关注的调度 API等。更重要的是，许多用户既不知道调度器架构起到什么作用，也不知道这些调度器适合哪些应用。</p>
<p>图 2 显示了一系列开源的编排框架的概况，以及它们的架构和它们的调度器支持的功能。在表格的最底部，我们同样引用了谷歌和微软的非开源的系统。<code>Resource granularity</code> 这一列表示资源使用固定的 slots，还是用多维的形式分配资源。</p>
<p><img src="http://cdn.jetmuffin.com/posts/orch-framework-feature-matrix.png" alt="图2"></p>
<p>其中一个帮助你确定调度框架是否合适的重要方面是你的集群是否允许不同的任务。例如在同一个集群中既有前端服务（负载均衡 web server 和 memcached）以及数据批处理分析（例如 MapReduce 或者 Spark）。在同一个集群上运行这两类任务可以提高该集群的使用率，但是不同的应用可能有不同的调度需求。在这种情况下，中央调度的调度器可能导致一个局部最优的调度结果，因为它在逻辑上无法做到根据每个任务进行的多样性调度。而两层调度和共享状态调度可能就更加适合一些。</p>
<p>大多数用户面对的服务任务是用服务时的峰值需求来设定的资源分配量的，但是在实际中通常这些服务的资源使用率是低于他们的分配需求。<strong>在这种情况下，能够适当的超售资源给低优先级的任务（同时保证服务的 QoS）是集群效率的关键。</strong>Mesos 是当前的开源系统中唯一支持资源超售的，而 Kubernetes 则是把它作为一个长远的目标。我们应该更加关注这个方面，因为根据谷歌 Borg 的报告指出，大多数集群的使用率仍然是低于 60-70% 的。我们将在未来的这个系列的文章中更加关注资源评估，资源超配和高效的机器使用率。</p>
<p>最后，特定的分析和 OLAP 风格的应用（例如 Dremel 或 SparkSQL queries）适用于完全分布式调度器。然而，完全分布式调度器（例如 Sparrow）受到一系列的约束，而在任务相同时工作效果最好。我们会在之后的文章中更加详细地解释完全分布式调度器和混合调度器中的分布式组件部分的内容。而现在足以说明从观察的结果看出，这种架构在调度策略上过于简单，以致于没法支持多类资源类型，资源超售和资源重分配等功能。</p>
<p>总体的说，从图 2 的表格中可以看出目前的开源调度框架还有很多的功能需要去支持和改进。这应该成为一个行动号召，解决这些框架中缺少的功能，低下的使用率，不可预测的任务性能等问题。</p>
<p>然而，一个好消息是，许多框架采用中央调度模式的调度框架正在往更加灵活的设计上发展。Kubernetes 已经支持了可插件化的调度器（<code>kube-scheduler</code> pod 可以被其他兼容 API 的调度器 pod 替代），从 v1.2 开始支持多调度器，以及正在开发的支持用户自定义的调度策略等。Docker Swarm 在未来可能同样会变得可插件化。</p>
<h2 id="下回预告"><a href="#下回预告" class="headerlink" title="下回预告"></a>下回预告</h2><p>本系列的下篇文章会关注完全分布式架构的主要问题。同时，我们会关注 resource-fitting 策略，以及最后讨论为什么我们的 Firmament scheduling 平台综合了其他调度架构所有的优点。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Verma A, Pedrosa L, Korupolu M, et al. Large-scale cluster management at Google with Borg[C]//Proceedings of the Tenth European Conference on Computer Systems. ACM, 2015: 18.</li>
<li>Hindman B, Konwinski A, Zaharia M, et al. Mesos: A Platform for Fine-Grained Resource Sharing in the Data Center[C]//NSDI. 2011, 11: 22-22.</li>
<li>Vavilapalli V K, Murthy A C, Douglas C, et al. Apache hadoop yarn: Yet another resource negotiator[C]//Proceedings of the 4th annual Symposium on Cloud Computing. ACM, 2013: 5.</li>
<li>Boutin E, Ekanayake J, Lin W, et al. Apollo: scalable and coordinated scheduling for cloud-scale computing[C]//11th USENIX Symposium on Operating Systems Design and Implementation (OSDI 14). 2014: 285-300.</li>
<li>Schwarzkopf M, Konwinski A, Abd-El-Malek M, et al. Omega: flexible, scalable schedulers for large compute clusters[C]//Proceedings of the 8th ACM European Conference on Computer Systems. ACM, 2013: 351-364.</li>
<li>Ousterhout K, Wendell P, Zaharia M, et al. Sparrow: distributed, low latency scheduling[C]//Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles. ACM, 2013: 69-84.</li>
<li>Delimitrou C, Kozyrakis C. Paragon: QoS-aware scheduling for heterogeneous datacenters[C]//ACM SIGPLAN Notices. ACM, 2013, 48(4): 77-88.</li>
<li>Delimitrou C, Kozyrakis C. Quasar: resource-efficient and QoS-aware cluster management[C]//ACM SIGPLAN Notices. ACM, 2014, 49(4): 127-144.</li>
<li>Delimitrou C, Sanchez D, Kozyrakis C. Tarcil: Reconciling scheduling speed and quality in large shared clusters[C]//Proceedings of the Sixth ACM Symposium on Cloud Computing. ACM, 2015: 97-110.</li>
<li>Delgado P, Dinu F, Kermarrec A M, et al. Hawk: Hybrid datacenter scheduling[C]//2015 USENIX Annual Technical Conference (USENIX ATC 15). 2015: 499-510.</li>
<li>Karanasos K, Rao S, Curino C, et al. Mercury: Hybrid centralized and distributed scheduling in large shared clusters[C]//2015 USENIX Annual Technical Conference (USENIX ATC</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章翻译自&lt;a href=&quot;http://firmament.io/blog/scheduler-architectures.html&quot;&gt;《The evolution of cluster scheduler architectures》&lt;/a&gt;，原作者为 Cambridge 的 Sys@Scale 实验室。&lt;/p&gt;
    
    </summary>
    
      <category term="资源调度" scheme="http://blog.jetmuffin.com/categories/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"/>
    
    
      <category term="mesos" scheme="http://blog.jetmuffin.com/tags/mesos/"/>
    
      <category term="资源调度" scheme="http://blog.jetmuffin.com/tags/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"/>
    
      <category term="borg" scheme="http://blog.jetmuffin.com/tags/borg/"/>
    
      <category term="omega" scheme="http://blog.jetmuffin.com/tags/omega/"/>
    
      <category term="sparrow" scheme="http://blog.jetmuffin.com/tags/sparrow/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes源码阅读 - storage part 1 - cache</title>
    <link href="http://blog.jetmuffin.com/2016/12/04/kubernetes-code-reading-storage-part-1-cache/"/>
    <id>http://blog.jetmuffin.com/2016/12/04/kubernetes-code-reading-storage-part-1-cache/</id>
    <published>2016-12-04T13:28:54.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 <code>Storage</code>，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</div><div class="line">	Store <span class="comment">// Queue事实上也是一种Storage，而在FIFOQueue中具体对Add,List,Delete等方法进行了重写</span></div><div class="line"></div><div class="line">	Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</div><div class="line"></div><div class="line">	AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</div><div class="line"></div><div class="line">	<span class="comment">// Return true if the first batch of items has been popped</span></div><div class="line">	HasSynced() <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>在 <code>pkg/client/cache</code> 包里实现了 cache 的一些基本结构，其中最核心的，也是最顶层的结构是 <code>Store</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/store.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</div><div class="line">	Add(obj <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 增</span></div><div class="line">	Update(obj <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 改</span></div><div class="line">	Delete(obj <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 删</span></div><div class="line">	List() []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 列举</span></div><div class="line">	ListKeys() []<span class="keyword">string</span> <span class="comment">// 列举 key</span></div><div class="line">	Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error) <span class="comment">// 查</span></div><div class="line">	GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error) <span class="comment">// 按key查</span></div><div class="line"></div><div class="line">	<span class="comment">// Replace will delete the contents of the store, using instead the</span></div><div class="line">	<span class="comment">// given list. Store takes ownership of the list, you should not reference</span></div><div class="line">	<span class="comment">// it after calling this function.</span></div><div class="line">	Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error <span class="comment">// 替换</span></div><div class="line">	Resync() error <span class="comment">// 同步</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Store 接口定义了 cache 中的所有数据类型的最通用的一层抽象，包括对 cache 存储的增删改查列举等操作。Store 具体的接口实现包括前面提到的 <code>FIFO</code>，<code>DeltaFIFO</code>，以及后面会提到的 <code>ThreadSafeStore</code>，<code>UnDeltaStore</code> 和 <code>ExpirationCache</code>。</p>
<h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p><code>ThreadSafeStore</code> 是 k8s 中用的最多，也是默认的 cache 存储。它允许对数据并行的访问，同时使用加锁的机制保证数据在多线程中是线程安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/thread_safe_store.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</div><div class="line">	lock  sync.RWMutex <span class="comment">// 锁</span></div><div class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 存储数据的map</span></div><div class="line"></div><div class="line">	<span class="comment">// indexers maps a name to an IndexFunc</span></div><div class="line">	indexers Indexers <span class="comment">// 存储Indexer的map</span></div><div class="line">	<span class="comment">// indices maps a name to an Index</span></div><div class="line">	indices Indices <span class="comment">// 存储Index的map</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ThreadSafeStore</code> 的实现上也比较简单，数据放在 map 的数据结构里，同时使用 <code>sync.RWMutex</code> 对这个 map 的 Add，Update，Delete，Get 等操作加读锁和写锁。此外，它还允许对同一作用的 items 加一个共同的索引方便直接获取，而这个索引放在 <code>indices</code> 里，获得索引的函数放在 <code>indexers</code> 里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/thread_safe_store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">Index</span><span class="params">(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	c.lock.RLock()</div><div class="line">	<span class="keyword">defer</span> c.lock.RUnlock()</div><div class="line"></div><div class="line">	indexFunc := c.indexers[indexName] <span class="comment">// 通过给的索引名称拿到索引函数</span></div><div class="line">	<span class="keyword">if</span> indexFunc == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Index with name %s does not exist"</span>, indexName)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	indexKeys, err := indexFunc(obj) <span class="comment">// 用索引函数拿到索引的keys</span></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	index := c.indices[indexName]</div><div class="line"></div><div class="line">	<span class="comment">// need to de-dupe the return list.  Since multiple keys are allowed, this can happen.</span></div><div class="line">	returnKeySet := sets.String&#123;&#125;</div><div class="line">	<span class="keyword">for</span> _, indexKey := <span class="keyword">range</span> indexKeys &#123;  <span class="comment">// 对索引的keys进行去重</span></div><div class="line">		set := index[indexKey]</div><div class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> set.UnsortedList() &#123;</div><div class="line">			returnKeySet.Insert(key)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	list := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, returnKeySet.Len())</div><div class="line">	<span class="keyword">for</span> absoluteKey := <span class="keyword">range</span> returnKeySet &#123;</div><div class="line">		list = <span class="built_in">append</span>(list, c.items[absoluteKey]) <span class="comment">// 根据keys拿到实际的items放到list里</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> list, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="UndeltaStore"><a href="#UndeltaStore" class="headerlink" title="UndeltaStore"></a>UndeltaStore</h3><p><code>UndeltaStore</code> 在 <code>Store</code> 上做了一层封装，在实例化时传入了一个回调函数 <code>PushFunc</code>，每当 <code>Store</code> 进行了 Add，Update，Delete 等操作，会调用 <code>PushFunc</code> 来告知这个数据的操作已经完成，可以进行后续的工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/undelta_store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UndeltaStore)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := u.Store.Add(obj); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	u.PushFunc(u.Store.List())</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现上其实也很简单，在每个操作的最后调用一次传入的 <code>PushFunc()</code>。</p>
<h3 id="ExpirationCache"><a href="#ExpirationCache" class="headerlink" title="ExpirationCache"></a>ExpirationCache</h3><p><code>ExpirationCache</code> 同样是对 <code>Store</code> 做了一层的封装，和 <code>UndeltaStore</code> 不同的是它是在 <code>ThreadSafeStore</code> 上进行的封装，实现了带过期期限的 cache 功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/expiration_cache.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> ExpirationCache <span class="keyword">struct</span> &#123;</div><div class="line">	cacheStorage     ThreadSafeStore <span class="comment">// 实际存储的storage</span></div><div class="line">	keyFunc          KeyFunc</div><div class="line">	clock            clock.Clock <span class="comment">// 标记创建时间的时间戳</span></div><div class="line">	expirationPolicy ExpirationPolicy <span class="comment">// 失效策略</span></div><div class="line">	<span class="comment">// expirationLock is a write lock used to guarantee that we don't clobber</span></div><div class="line">	<span class="comment">// newly inserted objects because of a stale expiration timestamp comparison</span></div><div class="line">	expirationLock sync.Mutex <span class="comment">// 失效检查的锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>ExpirationCache</code> 中的每个 item 被创建的时候会为其打上时间戳，而这个 item 在查询的时候会检查这个时间戳到目前的时间间隔是否超过了失效的阈值，若超过了则返回 <code>nil</code> 并把这个 item 从 map 里删掉。（这里相当于做了一个 lazy 操作，如果 item 失效了但是一直没有查询，那么它会一直在 map 里待着）。</p>
<p>默认使用的失效策略比较简单，就是给定一个时间范围阈值 <code>TTL(TimeToLive)</code>，然后判断这个时间戳到现在的时间距离是否大于这个阈值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/expiration_cache.go</span></div><div class="line"><span class="keyword">type</span> TTLPolicy <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">//	 &gt;0: Expire entries with an age &gt; ttl</span></div><div class="line">	<span class="comment">//	&lt;=0: Don't expire any entry</span></div><div class="line">	Ttl time.Duration <span class="comment">// 过期阈值</span></div><div class="line"></div><div class="line">	<span class="comment">// Clock used to calculate ttl expiration</span></div><div class="line">	Clock clock.Clock</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *TTLPolicy)</span> <span class="title">IsExpired</span><span class="params">(obj *timestampedEntry)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> p.Ttl &gt; <span class="number">0</span> &amp;&amp; p.Clock.Since(obj.timestamp) &gt; p.Ttl <span class="comment">// 判断是否失效（间隔是否大于TTL）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比于 <code>ThreadSafeStore</code>，<code>ExpirationCache</code> 在使用时还需要检查 item 是不是失效了，而这个检查的过程也是加锁的，而我们知道 <code>ThreadSafeStore</code> 自身本来就是带锁的操作的，所以它的操作会比 <code>ThreadSafeStore</code> 慢一些。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>除了上面提到的几种 cache 中用到的数据结构外，cache 包里还提供了一些其他的类来进行辅助工作：</p>
<ul>
<li>Indexer（<code>pkg/client/cache/index.go</code>）允许用多种方法对 items 进行过滤（索引）</li>
<li>Lister（<code>pkg/client/cache/lister.go</code>）提供了各种列举 items 的方法</li>
<li>MutationDetection（<code>pkg/client/cache/mutation_dectector.go</code>）检测某个 item 是否发生变化了</li>
<li>…</li>
</ul>
<h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><p>cache 包里的各个类定义了不同场景下 k8s 使用的数据结构，我们也知道 k8s 里实际存储 pods 等资源是放在 <code>ThreadSafeStore</code> 里的，那么 k8s 是如何将 APIServer 里的 RESTful API 和 cache 相联系起来的呢？</p>
<p>在 <code>pkg/client/cache/reflector.go</code> 里，k8s 提供了一种叫做 <code>Reflector</code> 的类，用于作为 APIServer 和 cache 之间的桥梁。对每一类 Resource 为它创建一个从 RESTful Resource 到 cache item 的 Reflector。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></div><div class="line">	name <span class="keyword">string</span></div><div class="line"></div><div class="line">	<span class="comment">// The type of object we expect to place in the store.</span></div><div class="line">	expectedType reflect.Type <span class="comment">// item的类型</span></div><div class="line">	<span class="comment">// The destination to sync up with the watch source</span></div><div class="line">	store Store <span class="comment">// item 的实际存储</span></div><div class="line">	<span class="comment">// listerWatcher is used to perform lists and watches.</span></div><div class="line">	listerWatcher ListerWatcher <span class="comment">// 用于监听item变化的watcher</span></div><div class="line">	<span class="comment">// period controls timing between one watch ending and</span></div><div class="line">	<span class="comment">// the beginning of the next one.</span></div><div class="line">	period       time.Duration <span class="comment">//watch的间隔</span></div><div class="line">	resyncPeriod time.Duration</div><div class="line">	<span class="comment">// now() returns current time - exposed for testing purposes</span></div><div class="line">	now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></div><div class="line">	// <span class="title">lastSyncResourceVersion</span> <span class="title">is</span> <span class="title">the</span> <span class="title">resource</span> <span class="title">version</span> <span class="title">token</span> <span class="title">last</span></div><div class="line">	// <span class="title">observed</span> <span class="title">when</span> <span class="title">doing</span> <span class="title">a</span> <span class="title">sync</span> <span class="title">with</span> <span class="title">the</span> <span class="title">underlying</span> <span class="title">store</span></div><div class="line">	// <span class="title">it</span> <span class="title">is</span> <span class="title">thread</span> <span class="title">safe</span>, <span class="title">but</span> <span class="title">not</span> <span class="title">synchronized</span> <span class="title">with</span> <span class="title">the</span> <span class="title">underlying</span> <span class="title">store</span></div><div class="line">	<span class="title">lastSyncResourceVersion</span> <span class="title">string</span></div><div class="line">	// <span class="title">lastSyncResourceVersionMutex</span> <span class="title">guards</span> <span class="title">read</span>/<span class="title">write</span> <span class="title">access</span> <span class="title">to</span> <span class="title">lastSyncResourceVersion</span></div><div class="line">	<span class="title">lastSyncResourceVersionMutex</span> <span class="title">sync</span>.<span class="title">RWMutex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Reflector 有两种允许方式：</p>
<ul>
<li><code>Run()</code></li>
<li><code>RunUntil(stopCh &lt;-chan struct{})</code></li>
</ul>
<p>两者的区别在于后者传入了一个 stopCh，当收到停止信号会停止这个 <code>Run()</code> 方法，而前者则是 Run forever 的。而两者的方法的主题都是一致的，都在启动了一个 goroutine 去一直执行 <code>ListAndWatch()</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</div><div class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err := r.ListAndWatch(wait.NeverStop); err != <span class="literal">nil</span> &#123; <span class="comment">// 一直执行ListAndWatch</span></div><div class="line">			utilruntime.HandleError(err)</div><div class="line">		&#125;</div><div class="line">	&#125;, r.period, wait.NeverStop)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么来看一看这个 <code>ListAndWatch()</code> 是做什么的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"></div><div class="line"><span class="comment">//...</span></div><div class="line">w, err := r.listerWatcher.Watch(options) <span class="comment">// 获得一个watch.Interface</span></div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">	<span class="keyword">switch</span> err &#123;</div><div class="line">	<span class="keyword">case</span> io.EOF:</div><div class="line">		<span class="comment">// watch closed normally</span></div><div class="line">	<span class="keyword">case</span> io.ErrUnexpectedEOF:</div><div class="line">		glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></div><div class="line">	<span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></div><div class="line">	<span class="comment">// watch where we ended.</span></div><div class="line">	<span class="comment">// If that's the case wait and resend watch request.</span></div><div class="line">	<span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</div><div class="line">		<span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</div><div class="line">			<span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</div><div class="line">				time.Sleep(time.Second)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123; <span class="comment">// 处理这个 watch.Interface</span></div><div class="line">	<span class="keyword">if</span> err != errorStopRequested &#123;</div><div class="line">		glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>在 <code>ListAndWatch()</code> 中前面先开了一个独立的 goroutine 去同步 Store 这里就不细说了。核心的内容在后面，首先是 <code>r.listerWatcher.Watch(options)</code> 获取到一个 <code>watch.Interface</code> 对象，然后对这个对象进行处理，即 <code>r.watchHandler()</code>。</p>
<p>首先看这个 <code>watch.Interface</code>，寻找引用它的路径可以按着 <code>pkg/client/cache/listwatch.go: ListerWatcher.Watch()</code> -&gt; <code>pkg/client/cache/listwatch.go: ListWatch.WatchFunc</code> -&gt; <code>pkg/client/cache/listwatch.go: NewListWatchFromClient()</code> 的一个思路去看。</p>
<p>那么最终关注这个 <code>NewListWatchFromClient()</code> 方法，它事实上就是连接着 API 的那一头，传入了 API 的一个 Resource，而 <code>ListerWatcher</code> 的 <code>Watch()</code> 方法就是这个 Resource 中的 <code>Watch()</code> 方法。具体实例化是在每个资源的包中，例如 <code>pkg/kubelet/config/apiserver.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/kubelet/config/apiserver.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSourceApiserver</span><span class="params">(c *clientset.Clientset, nodeName types.NodeName, updates <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	lw := cache.NewListWatchFromClient(c.Core().RESTClient(), <span class="string">"pods"</span>, v1.NamespaceAll, fields.OneTermEqualSelector(api.PodHostField, <span class="keyword">string</span>(nodeName)))</div><div class="line">	newSourceApiserverFromLW(lw, updates)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里为 pods 创建了一个 RESTClient，同时用这个 Client 作为参数创建一个 ListWatcher，ListAndWatch 中的 Watch 方法就是 Client 中的 Watch 方法。</p>
<p>那么搞清楚了这一头了以后看一看检测到变化以后 Reflector 是怎么处理的。在 ListAndWatch 方法中还有一个重要的方法 <code>watchHandler()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">  	<span class="comment">//...</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-stopCh:</div><div class="line">			<span class="keyword">return</span> errorStopRequested</div><div class="line">		<span class="keyword">case</span> err := &lt;-errc:</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		<span class="keyword">case</span> event, ok := &lt;-w.ResultChan(): <span class="comment">// 从ResultChan中拿出一个event</span></div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">break</span> loop</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> event.Type == watch.Error &#123;</div><div class="line">				<span class="keyword">return</span> apierrs.FromObject(event.Object)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			meta, err := meta.Accessor(event.Object) <span class="comment">//用event.Object获取meta信息</span></div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			newResourceVersion := meta.GetResourceVersion()</div><div class="line">			<span class="keyword">switch</span> event.Type &#123; <span class="comment">// 根据event的不同类型对cache做不同处理</span></div><div class="line">			<span class="keyword">case</span> watch.Added:</div><div class="line">				r.store.Add(event.Object)</div><div class="line">			<span class="keyword">case</span> watch.Modified:</div><div class="line">				r.store.Update(event.Object)</div><div class="line">			<span class="keyword">case</span> watch.Deleted:</div><div class="line">				<span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></div><div class="line">				<span class="comment">// state", which is passed in event.Object? If so, may need</span></div><div class="line">				<span class="comment">// to change this.</span></div><div class="line">				r.store.Delete(event.Object)</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</div><div class="line">			&#125;</div><div class="line">			*resourceVersion = newResourceVersion</div><div class="line">			r.setLastSyncResourceVersion(newResourceVersion)</div><div class="line">			eventCount++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>watchHandler()</code> 的核心是这个 loop，Reflector 会从 watch.Interface 中拿到一个叫做 ResultChan 的 chanel，watch.Interface 在 API 的那一头会根据 HTTP Request 源源不断往这个 chanel 里扔进去事件 Event（<code>pkg/watch/watch.go: Event</code>），而 Reflector 从 chanel 的这一头不断的拿出这些事件，获取他们的 meta 信息，再根据事件的不同类型对 cache 做增删改查操作。</p>
<p>也就是说 k8s 对各种操作事实上是统一通过这个 chanel 里以事件的形式市传过来的，这也解释了为什么 cache 和 Store 中的实现所有的方法都是传进去一个 object 的 interface。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里所有的路径都打通了，再最后理一遍 k8s 是如何从 API 到 cache 的 Store 的：</p>
<ol>
<li>APIServer 为每类资源（例如 pods）创建一个 RESTClient（client）用于处理诸如 POST，PUT，GET 的 RESTful HTTP requsts</li>
<li>APIServer 用 client 创建一个 ListWatcher（lw）用于监控每类资源的变化</li>
<li>APIServer 用 lw，指定的 store，创建一个 Reflector（reflector），将这个变化作用到 store 上</li>
<li>当发生 HTTP Requests 时，client 的 Watch 方法会把资源和资源变化类型打包成 event 放进 lw 的 ResultChan 中</li>
<li>reflector 从 ResultChan 里拿出 event，根据 event.EventType 把 event.Object 作用到 store 里去</li>
</ol>
<p>整个过程中用了许多的 goroutine 来完成这么一件事。相比于 k8s 的实现，常见的 webapp 的处理相对就简单了好多，也可以看出 k8s 在设计上的精妙。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 &lt;code&gt;Storage&lt;/code&gt;，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
      <category term="容器管理" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="cache" scheme="http://blog.jetmuffin.com/tags/cache/"/>
    
      <category term="storage" scheme="http://blog.jetmuffin.com/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes源码阅读 - queue</title>
    <link href="http://blog.jetmuffin.com/2016/12/03/kubernetes-code-reading-queue/"/>
    <id>http://blog.jetmuffin.com/2016/12/03/kubernetes-code-reading-queue/</id>
    <published>2016-12-03T08:04:00.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中对 k8s 的 scheduler 部分进行了简单的源码阅读和分析，现在接着上次的位置继续往下阅读。</p>
<p><img src="http://cdn.jetmuffin.com/posts/gce.png" alt="k8s"></p>
<a id="more"></a>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在 <code>plugin/pkg/scheduler/factory/factory.go</code> 的代码中，scheduler 在创建时引用了一个 <code>getNextPod</code> 方法，获取下一个待调度的 pod。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ConfigFactory)</span> <span class="title">getNextPod</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        pod := cache.Pop(f.PodQueue).(*v1.Pod) <span class="comment">// 获取下一个待调度的 Pod</span></div><div class="line">        <span class="keyword">if</span> f.responsibleForPod(pod) &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v"</span>, pod.Name)</div><div class="line">            <span class="keyword">return</span> pod</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当时没有继续下去，这些 pod 在 k8s 的调度队列里是如何管理的，这也是这篇文章想从源码里学到的。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>和上篇文章一样，由于 k8s 的代码量非常大，那么我们还是一点一点追溯到代码的源头。从 <code>cache.Pop()</code> 方法往上头寻找，IDE 会把你带到 <code>pkg/client/cache/fifo.go</code> 这个文件。从名字很明显看出这是一个先进先出的队列，那么我们就需要看看 k8s 在队列上是如何进行设计的。</p>
<p>首先是 <code>Queue</code> 的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</div><div class="line">    Store <span class="comment">// 实际存储的后端</span></div><div class="line"></div><div class="line">    <span class="comment">// Pop blocks until it has something to process.</span></div><div class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></div><div class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></div><div class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></div><div class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error) <span class="comment">// pop 的抽象方法</span></div><div class="line"></div><div class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></div><div class="line">    <span class="comment">// returned by Pop back into the queue as long</span></div><div class="line">    <span class="comment">// as nothing else (presumably more recent)</span></div><div class="line">    <span class="comment">// has since been added.</span></div><div class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 如同注释所说。。加入队列如果它不在队列中</span></div><div class="line"></div><div class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></div><div class="line">    HasSynced() <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口实际上是对所有类型的队列进行抽象，<code>Pop()</code> 方法是它们共有的方法，FIFO 是一种队列的实现方式，队列还可能有其他的实现方式，诸如 FILO 等。</p>
<h3 id="FIFO-Queue"><a href="#FIFO-Queue" class="headerlink" title="FIFO Queue"></a>FIFO Queue</h3><p>k8s 中默认使用的是 FIFO 队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> FIFO <span class="keyword">struct</span> &#123;</div><div class="line">    lock sync.RWMutex <span class="comment">// 读写锁</span></div><div class="line">    cond sync.Cond <span class="comment">// 读写锁基础上的消息通知对象</span></div><div class="line">    <span class="comment">// We depend on the property that items in the set are in the queue and vice versa.</span></div><div class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 存储对象的内容</span></div><div class="line">    queue []<span class="keyword">string</span> <span class="comment">// 存储对象的 id</span></div><div class="line"></div><div class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></div><div class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></div><div class="line">    populated <span class="keyword">bool</span></div><div class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></div><div class="line">    initialPopulationCount <span class="keyword">int</span></div><div class="line"></div><div class="line">    <span class="comment">// keyFunc is used to make the key used for queued item insertion and retrieval, and</span></div><div class="line">    <span class="comment">// should be deterministic.</span></div><div class="line">    keyFunc KeyFunc <span class="comment">// 用于获取item的key的function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FIFO 队列中有两个重要的数据结构：</p>
<ul>
<li><code>items map[string]interface{}</code> 用于 map 的 键值对形式实际存 items，便于 items 的增删改查</li>
<li><code>queue []string</code> 用于维护每个 items 进入 FIFO 队列的先后顺序，只存 id</li>
</ul>
<p>这里和其他用 chanel 实现的 FIFO 队列稍有不同，用一个 map 和一个 list 就成功的实现了可以增删改查的先进先出队列。</p>
<p>而这个先进先出的 FIFO 队列共有以下操作：</p>
<ul>
<li><code>Add()</code> （添加一个 item）</li>
<li><code>AddIfNotPresent()</code> （如果 item 不在队列中，那么就把它加进队列里）</li>
<li><code>Update()</code> （更新指定 item）</li>
<li><code>Delete()</code> （删除制定 item）</li>
<li><code>List()</code> （列举所有的 item）</li>
<li><code>ListKeys()</code> （列举所有的 key）</li>
<li><code>Get()</code> (按对象获取 item）</li>
<li><code>GetByKey()</code> （按 key 获取 item）</li>
<li><strong><code>Pop()</code></strong></li>
<li><code>Replace()</code> （替换整个队列的内容）</li>
<li><strong><code>Resync()</code></strong></li>
</ul>
<p>前几个方法比较常规，就是一些增删改查的方法。不过需要注意的是，这个 FIFO 在 Delete 时只是删去它在 map 里的对象，不会删去 queue 里的 id，而是在 Pop 时检查一下这个 id 是不是存在于 map 里就行了，相当于是一种 lazy 操作，因为动态维护 queue 队列里的顺序比较麻烦。</p>
<p>当然因为这个 lazy 操作会出现一种情况，就是 queue 里的 id 数和 map 里的 item 数不一致，那么就需要 <code>Resync()</code> 方法来进行同步了。它会直接遍历比较 queue 和 map，把不在 queue 里的 item 全部加到 queue 的末尾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="comment">// Resync will touch all objects to put them into the processing queue</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line"></div><div class="line">    inQueue := sets.NewString()</div><div class="line">    <span class="keyword">for</span> _, id := <span class="keyword">range</span> f.queue &#123;</div><div class="line">        inQueue.Insert(id) <span class="comment">// queue 里现在有的所有id</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> id := <span class="keyword">range</span> f.items &#123; <span class="comment">// 遍历map里的所有key,如果不在queue里就扔到queue末尾曲</span></div><div class="line">        <span class="keyword">if</span> !inQueue.Has(id) &#123; </div><div class="line">            f.queue = <span class="built_in">append</span>(f.queue, id)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f.queue) &gt; <span class="number">0</span> &#123;</div><div class="line">        f.cond.Broadcast()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最重要的是 Pop 方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</div><div class="line">            f.cond.Wait()</div><div class="line">        &#125;</div><div class="line">        id := f.queue[<span class="number">0</span>]</div><div class="line">        f.queue = f.queue[<span class="number">1</span>:] <span class="comment">// 从队列里拿出第一个item的id</span></div><div class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</div><div class="line">            f.initialPopulationCount--</div><div class="line">        &#125;</div><div class="line">        item, ok := f.items[id]</div><div class="line">        <span class="keyword">if</span> !ok &#123;</div><div class="line">            <span class="comment">// Item may have been deleted subsequently.</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果id在map里不存在，那么跳过它</span></div><div class="line">        <span class="built_in">delete</span>(f.items, id) <span class="comment">// 删掉map里对应的item</span></div><div class="line">        err := process(item) <span class="comment">// process方法会阻塞这个Pop方法直到这个item变为ready状态</span></div><div class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</div><div class="line">            f.addIfNotPresent(id, item)</div><div class="line">            err = e.Err</div><div class="line">        &#125;<span class="comment">// 如果出现错误再次放回队列里</span></div><div class="line">        <span class="keyword">return</span> item, err</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pop 方法里会从 queue 中拿出第一个 item 的 id，检查它是不是在 map 里，然后调用 process() 方法判断它是不是 ready 状态，最后返回这个 item。</p>
<p>阅读这里比较疑惑的是，实际 k8s 代码中貌似并没有实现这个 <strong>process</strong> 方法，可以看到在 <code>pkg/client/cache/fifo.go</code> 中有一个 Pop 方法的 helper，对方法进行了封装，而在封装中可以看到，传入的 <code>process()</code> 方法是个匿名函数，只是简单的把传入的 item 赋值给外部的 result 然后返回，并没有 check 这个 item 是否 ready。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(queue Queue)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    <span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</div><div class="line">    queue.Pop(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">        result = obj</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后需要提一下的就是这个 <code>keyFunc</code> 了。从 FIFO 类的定义上看，它是用于获取一个 item 的 key 的方法。而在 FIFO 实例化时，实际上传入的是 <code>MetaNamespaceKeyFunc()</code> 方法，获取 Pod 的 meta 信息里 <code>namespace/name</code> 或者 <code>name</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pkg/client/cache/store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MetaNamespaceKeyFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> key, ok := obj.(ExplicitKey); ok &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">string</span>(key), <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    meta, err := meta.Accessor(obj)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"object has no meta: %v"</span>, err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(meta.GetNamespace()) &gt; <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> meta.GetNamespace() + <span class="string">"/"</span> + meta.GetName(), <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> meta.GetName(), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DeltaFIFO-Queue"><a href="#DeltaFIFO-Queue" class="headerlink" title="DeltaFIFO Queue"></a>DeltaFIFO Queue</h3><p>在 k8s 的 cache 中还提供了一种叫做 <strong>DeltaFIFO</strong> 的队列，相比于 FIFO 队列，它的作用不一样，它是用于储存每个 Pod 的事件（包括 Delete, Update, Add）。这个方法是在 <a href="https://github.com/kubernetes/kubernetes/issues/4877" target="_blank" rel="external">ISSUE#4877</a> 中提出的，因为某些情况下控制器需要知道调度器中队列的操作事件，并且添加 watcher 来针对事件来做出响应，这里也简单的过一下。</p>
<p>首先 delta 的类型定义有 <code>Added</code>，<code>Updated</code>，<code>Deleted</code>，<code>Sync</code> 这四种，分别是在队列进行添加、更新、删除和同步操作时加入的事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/delta_fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Added   DeltaType = <span class="string">"Added"</span></div><div class="line">    Updated DeltaType = <span class="string">"Updated"</span></div><div class="line">    Deleted DeltaType = <span class="string">"Deleted"</span></div><div class="line">    <span class="comment">// The other types are obvious. You'll get Sync deltas when:</span></div><div class="line">    <span class="comment">//  * A watch expires/errors out and a new list/watch cycle is started.</span></div><div class="line">    <span class="comment">//  * You've turned on periodic syncs.</span></div><div class="line">    <span class="comment">// (Anything that trigger's DeltaFIFO's Replace() method.)</span></div><div class="line">    Sync DeltaType = <span class="string">"Sync"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>Delta 对象存储了<strong>修改的类型（Type）</strong>和<strong>修改在哪个对象上（Object)</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/delta_fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</div><div class="line">    Type   DeltaType</div><div class="line">    Object <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样这个队列和 FIFO 类似，也是用 map 存 Deltas，用 queue 存 id。稍微不同的地方上，对这个队列的 <code>Add()</code>，<code>Update()</code>， <code>Delete()</code> 操作是把相应的 Delta <strong>添加</strong> 到队列里去，也就是说这个队列始终是在往里添加东西（Delta)，而外部的 Watcher 则在不断的从这个 DeltaFIFO 中取 Delta 来处理。也就是我们常说的 <strong>Producer/Consumer</strong> 的模型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>和之前看的 Mesos 中的 DRF 算法不同，k8s 中使用 FIFO 队列来维护每个 Pod 进入调度器的顺序。当然 Mesos 用 DRF 也是考虑在两层调度框架上进行公平调度，而 k8s 只关心进来的 Pod 的先后顺序。</p>
<p>再和上篇文章说到的内容结合，k8s 的调度实际上是基于<strong>先后顺序（FIFO），节点过滤（predicates）和节点打分（prioritizers）</strong>来做到从 Pod 到 Node 的调度过程。</p>
<p>最后，调度器中 FIFO 当然也是最简单和最常使用的队列模式，或许之后可以为 k8s 增加更多模式的调度器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中对 k8s 的 scheduler 部分进行了简单的源码阅读和分析，现在接着上次的位置继续往下阅读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jetmuffin.com/posts/gce.png&quot; alt=&quot;k8s&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="queue" scheme="http://blog.jetmuffin.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes源码阅读 - scheduler</title>
    <link href="http://blog.jetmuffin.com/2016/11/24/kubernetes-code-reading-scheduler/"/>
    <id>http://blog.jetmuffin.com/2016/11/24/kubernetes-code-reading-scheduler/</id>
    <published>2016-11-24T11:50:52.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。</p>
<p><img src="http://cdn.jetmuffin.com/posts/kubernetes.jpg" alt="k8s"></p>
<a id="more"></a>
<h2 id="Scheduler-入口"><a href="#Scheduler-入口" class="headerlink" title="Scheduler 入口"></a>Scheduler 入口</h2><p>首先定位到 <code>plugin/cmd/scheduler.go</code> 这个文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/cmd/scheduler.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := options.NewSchedulerServer()</div><div class="line">    s.AddFlags(pflag.CommandLine) <span class="comment">// 解析参数</span></div><div class="line"></div><div class="line">    flag.InitFlags()</div><div class="line">    logs.InitLogs()</div><div class="line">    <span class="keyword">defer</span> logs.FlushLogs()</div><div class="line"></div><div class="line">    verflag.PrintAndExitIfRequested()</div><div class="line"></div><div class="line">    app.Run(s) <span class="comment">// 启动调度器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面这段代码可以看出这是从 command 启动 scheduler 的入口，它解析了 scheduler 的参数，同时调用了 <code>app.Run(s)</code>来启动 scheduler。</p>
<p>按着这个走向找到 <code>app.Run(s)</code> 的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/cmd/kube-scheduler/app/server.go</span></div><div class="line"></div><div class="line"><span class="comment">// Run runs the specified SchedulerServer.  This should never exit.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(s *options.SchedulerServer)</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line"></div><div class="line">    sched := scheduler.New(config) <span class="comment">// 新建调度器</span></div><div class="line"></div><div class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(_ &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">        sched.Run() <span class="comment">// 正式启动调度器入口</span></div><div class="line">        <span class="keyword">select</span> &#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在这段代码片段中，通过 <code>sched := scheduler.New(config)</code> 新建了一个 scheduler 对象，并且调用它的 <code>Run()</code> 成员方法，同时需要特意留意 <code>config</code>。继续追踪到 scheduler 类的定义中取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="comment">// Run begins watching and scheduling. It starts a goroutine and returns immediately.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">go</span> wait.Until(s.scheduleOne, <span class="number">0</span>, s.config.StopEverything)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Scheduler.Run()</code> 方法中，Scheduler 通过 <code>wait.Until()</code> 工具，不停得调用 <code>Scheduler.scheduleOne()</code> 方法直到收到停止信号。我们接着看 <code>scheduleOne()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">()</span></span> &#123;</div><div class="line">    pod := s.config.NextPod() <span class="comment">// 获取下一个待调度的pod</span></div><div class="line"></div><div class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">    start := time.Now()</div><div class="line">    dest, err := s.config.Algorithm.Schedule(pod, s.config.NodeLister) <span class="comment">// 调用算法进行调度</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        glog.V(<span class="number">1</span>).Infof(<span class="string">"Failed to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">        s.config.Error(pod, err)</div><div class="line">        s.config.Recorder.Eventf(pod, api.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"%v"</span>, err)</div><div class="line">        s.config.PodConditionUpdater.Update(pod, &amp;api.PodCondition&#123;</div><div class="line">            Type:   api.PodScheduled,</div><div class="line">            Status: api.ConditionFalse,</div><div class="line">            Reason: api.PodReasonUnschedulable,</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scheduler 首先通过 <code>config.NextPod()</code> 来获取到当前要进行调度的一个 pod，然后调用 <code>config.Algorithm.Schedule()</code> 方法来对这个 pod 实际进行调度。从这种写法上我们可以猜测到 Algorithm 这儿用的是工厂模式。若根据该算法调度成功，那么将这个时间进行记录。否则调用 <code>config.Error()</code> 来进行错误处理。</p>
<p>这里有三个比较重点的内容：</p>
<ul>
<li>config.NextPod()</li>
<li>config.Algorithm.schedule()</li>
<li>config.Error()</li>
</ul>
<p>它们均来自 <code>Config</code> 类，那么我们先看这个类，再接下去探索这两个方法。<code>Config</code> 类的定义也在这个文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// It is expected that changes made via SchedulerCache will be observed</span></div><div class="line">    <span class="comment">// by NodeLister and Algorithm.</span></div><div class="line">    SchedulerCache schedulercache.Cache</div><div class="line">    NodeLister     algorithm.NodeLister</div><div class="line">    Algorithm      algorithm.ScheduleAlgorithm <span class="comment">// 调度算法</span></div><div class="line">    Binder         Binder</div><div class="line">    <span class="comment">// PodConditionUpdater is used only in case of scheduling errors. If we succeed</span></div><div class="line">    <span class="comment">// with scheduling, PodScheduled condition will be updated in apiserver in /bind</span></div><div class="line">    <span class="comment">// handler so that binding and setting PodCondition it is atomic.</span></div><div class="line">    PodConditionUpdater PodConditionUpdater</div><div class="line"></div><div class="line">    <span class="comment">// NextPod should be a function that blocks until the next pod</span></div><div class="line">    <span class="comment">// is available. We don't use a channel for this, because scheduling</span></div><div class="line">    <span class="comment">// a pod may take some amount of time and we don't want pods to get</span></div><div class="line">    <span class="comment">// stale while they sit in a channel.</span></div><div class="line">    NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span> // 获取下一个<span class="title">pod</span>的抽象方法</span></div><div class="line"></div><div class="line">    // <span class="title">Error</span> <span class="title">is</span> <span class="title">called</span> <span class="title">if</span> <span class="title">there</span> <span class="title">is</span> <span class="title">an</span> <span class="title">error</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">passed</span> <span class="title">the</span> <span class="title">pod</span> <span class="title">in</span></div><div class="line">    // <span class="title">question</span>, <span class="title">and</span> <span class="title">the</span> <span class="title">error</span></div><div class="line">    <span class="title">Error</span> <span class="title">func</span><span class="params">(*api.Pod, error)</span> // 处理调度出现的错误</div><div class="line"></div><div class="line">    // <span class="title">Recorder</span> <span class="title">is</span> <span class="title">the</span> <span class="title">EventRecorder</span> <span class="title">to</span> <span class="title">use</span></div><div class="line">    <span class="title">Recorder</span> <span class="title">record</span>.<span class="title">EventRecorder</span></div><div class="line"></div><div class="line">    // <span class="title">Close</span> <span class="title">this</span> <span class="title">to</span> <span class="title">shut</span> <span class="title">down</span> <span class="title">the</span> <span class="title">scheduler</span>.</div><div class="line">    <span class="title">StopEverything</span> <span class="title">chan</span> <span class="title">struct</span>&#123;&#125; <span class="comment">// 停止信号</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Config</code> 类传入了 scheduler 必要的各种参数，相当于原来隶属于 scheduler 的成员变量通过它传入。<code>Config</code> 类在 <code>plugin/pkg/scheduler/factory</code> 中被实例化，相应的抽象方法也被传入实际的引用方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> &amp;scheduler.Config&#123;</div><div class="line">      SchedulerCache: f.schedulerCache,</div><div class="line">      <span class="comment">// The scheduler only needs to consider schedulable nodes.</span></div><div class="line">      NodeLister:          f.NodeLister.NodeCondition(getNodeConditionPredicate()),</div><div class="line">      Algorithm:           algo,</div><div class="line">      Binder:              &amp;binder&#123;f.Client&#125;,</div><div class="line">      PodConditionUpdater: &amp;podConditionUpdater&#123;f.Client&#125;,</div><div class="line">      NextPod: <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">          <span class="keyword">return</span> f.getNextPod()</div><div class="line">      &#125;,</div><div class="line">      Error:          f.makeDefaultErrorFunc(&amp;podBackoff, f.PodQueue),</div><div class="line">      StopEverything: f.StopEverything,</div><div class="line">  &#125;, <span class="literal">nil</span></div></pre></td></tr></table></figure>
<h2 id="获取待调度的-Pod"><a href="#获取待调度的-Pod" class="headerlink" title="获取待调度的 Pod"></a>获取待调度的 Pod</h2><p>首先看 <code>NextPod</code> 参数，从类 <code>Config</code> 的定义中的注释可以看到，这个参数是一个获取下一个 pod，并且阻塞该方法直到下一个 pod 可用为止。并且它的实现没有用 chanel，原因是一旦放到 chanel 里，这个 pod 便无法修改。这个 参数是在实例化时传入的获取下一个 pod 的方法。传入的代码也在这个文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ConfigFactory)</span> <span class="title">getNextPod</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        pod := cache.Pop(f.PodQueue).(*api.Pod)</div><div class="line">        <span class="keyword">if</span> f.responsibleForPod(pod) &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v"</span>, pod.Name)</div><div class="line">            <span class="keyword">return</span> pod</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这段代码可以看出，获取下一个待调度的 pod 似乎是从一个队列中 pop 出一个 pod 来实现的。使用的来源是 <code>pkg/client/cache</code>，继续追踪：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(queue Queue)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    <span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</div><div class="line">    queue.Pop(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">        result = obj</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是个代理方法，是对 <code>Queue</code> 类中的 <code>Pop()</code> 方法进行了一层封装，于是自然看到对应的 <code>Queue.Pop()</code>，它是在类 <code>FIFO</code> 中的，那么这块儿也逐渐明了了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="comment">// Pop waits until an item is ready and processes it. If multiple items are</span></div><div class="line"><span class="comment">// ready, they are returned in the order in which they were added/updated.</span></div><div class="line"><span class="comment">// The item is removed from the queue (and the store) before it is processed,</span></div><div class="line"><span class="comment">// so if you don't successfully process it, it should be added back with</span></div><div class="line"><span class="comment">// AddIfNotPresent(). process function is called under lock, so it is safe</span></div><div class="line"><span class="comment">// update data structures in it that need to be in sync with the queue.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</div><div class="line">            f.cond.Wait()</div><div class="line">        &#125;</div><div class="line">        id := f.queue[<span class="number">0</span>]</div><div class="line">        f.queue = f.queue[<span class="number">1</span>:]</div><div class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</div><div class="line">            f.initialPopulationCount--</div><div class="line">        &#125;</div><div class="line">        item, ok := f.items[id]</div><div class="line">        <span class="keyword">if</span> !ok &#123;</div><div class="line">            <span class="comment">// Item may have been deleted subsequently.</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">delete</span>(f.items, id)</div><div class="line">        err := process(item)</div><div class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</div><div class="line">            f.addIfNotPresent(id, item)</div><div class="line">            err = e.Err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> item, err</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法算是这条路径的最后一个追踪的节点了。总结一下这条路径：</p>
<ol>
<li>kubernetes 的 cache 中维护了一个先进先出的队列 <code>FIFO</code>，它不同于 golang 中的 chanel，它支持对队列中的元素进行更新、删除等操作。</li>
<li>这个队列的 <code>FIFO.Pop()</code> 方法会队首元素（一个 pod）到达 ready 状态，然后将它弹出，否则阻塞该方法。</li>
<li><code>Scheduler</code> 类初始化时使用参数 <code>Config</code>，<code>Config</code> 中的 <code>NextPod()</code> 默认使用 <code>FIFO.Pop()</code>，当 <code>Scheduler</code> 需要进行调度时使用该方法得到下一个待调度的 pod。</li>
</ol>
<h2 id="使用调度算法进行实时调度"><a href="#使用调度算法进行实时调度" class="headerlink" title="使用调度算法进行实时调度"></a>使用调度算法进行实时调度</h2><p>回到 <code>Config</code> 类的第二个重要参数 <code>Algorithm</code>,它是对 pod 进行调度的实体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line">algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)</div></pre></td></tr></table></figure>
<p>可以看到默认情况下，<code>Algorithm</code> 是用的通用调度器，接着看这个 <code>GenericScheduler</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/generic_scheduler.go</span></div><div class="line"></div><div class="line"><span class="comment">// Schedule tries to schedule the given pod to one of node in the node list.</span></div><div class="line"><span class="comment">// If it succeeds, it will return the name of the node.</span></div><div class="line"><span class="comment">// If it fails, it will return a Fiterror error with reasons.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *api.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> trace *util.Trace</div><div class="line">    <span class="keyword">if</span> pod != <span class="literal">nil</span> &#123;</div><div class="line">        trace = util.NewTrace(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        trace = util.NewTrace(<span class="string">"Scheduling &lt;nil&gt; pod"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</div><div class="line"></div><div class="line">    nodes, err := nodeLister.List() <span class="comment">// 获取所有节点</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, ErrNoNodesAvailable</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Used for all fit and priority funcs.</span></div><div class="line">    err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// TODO(harryz) Check if equivalenceCache is enabled and call scheduleWithEquivalenceClass here</span></div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Computing predicates"</span>)</div><div class="line">    filteredNodes, failedPredicateMap, err := findNodesThatFit(pod, g.cachedNodeInfoMap, nodes, g.predicates, g.extenders, g.predicateMetaProducer)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, &amp;FitError&#123;</div><div class="line">            Pod:              pod,</div><div class="line">            FailedPredicates: failedPredicateMap,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Prioritizing"</span>)</div><div class="line">    metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap)</div><div class="line">    priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Selecting host"</span>)</div><div class="line">    <span class="keyword">return</span> g.selectHost(priorityList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，GenericScheduler 进行调度为以下过程：</p>
<ol>
<li>从 <code>NodeList</code> 获取所有的节点</li>
<li>通过所给的断言函数（<code>predicates</code>）对所有节点进行过滤，选出符合的节点（<code>findNodesThatFit()</code>）</li>
<li>根据所给的打分函数（<code>prioritizers</code>）对过滤后的节点进行排序（<code>PrioritizeNodes()</code>）</li>
<li>通过 round-robin 方式依次获取分数最高的节点来运行 pod。</li>
</ol>
<h2 id="调度失败"><a href="#调度失败" class="headerlink" title="调度失败"></a>调度失败</h2><p>在 <code>Config</code> 类的 <code>Error</code> 参数中传入了调度失败的处理方法 <code>makeDefaultErrorFunc()</code> 对调度失败的 pod 进行重调度处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(factory *ConfigFactory)</span> <span class="title">makeDefaultErrorFunc</span><span class="params">(backoff *podBackoff, podQueue *cache.FIFO)</span> <span class="title">func</span><span class="params">(pod *api.Pod, err error)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(pod *api.Pod, err error)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> err == scheduler.ErrNoNodesAvailable &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"Unable to schedule %v %v: no nodes are registered to the cluster; waiting"</span>, pod.Namespace, pod.Name)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            glog.Errorf(<span class="string">"Error scheduling %v %v: %v; retrying"</span>, pod.Namespace, pod.Name, err)</div><div class="line">        &#125;</div><div class="line">        backoff.gc() <span class="comment">// 清空backoff列表</span></div><div class="line">        <span class="comment">// Retry asynchronously.</span></div><div class="line">        <span class="comment">// Note that this is extremely rudimentary and we need a more real error handling path.</span></div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">            <span class="keyword">defer</span> runtime.HandleCrash()</div><div class="line">            podID := types.NamespacedName&#123;</div><div class="line">                Namespace: pod.Namespace,</div><div class="line">                Name:      pod.Name,</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            entry := backoff.getEntry(podID)</div><div class="line">            <span class="keyword">if</span> !entry.TryWait(backoff.maxDuration) &#123;</div><div class="line">                glog.Warningf(<span class="string">"Request for pod %v already in flight, abandoning"</span>, podID)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Get the pod again; it may have changed/been scheduled already.</span></div><div class="line">            getBackoff := initialGetBackoff</div><div class="line">            <span class="keyword">for</span> &#123;</div><div class="line">                pod, err := factory.Client.Core().Pods(podID.Namespace).Get(podID.Name)</div><div class="line">                <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> &#123;</div><div class="line">                        podQueue.AddIfNotPresent(pod) <span class="comment">// 重新将pod加入调度队列</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">                    glog.Warningf(<span class="string">"A pod %v no longer exists"</span>, podID)</div><div class="line">                    <span class="keyword">return</span></div><div class="line">                &#125;</div><div class="line">                glog.Errorf(<span class="string">"Error getting pod %v for retry: %v; retrying..."</span>, podID, err)</div><div class="line">                <span class="keyword">if</span> getBackoff = getBackoff * <span class="number">2</span>; getBackoff &gt; maximalGetBackoff &#123;</div><div class="line">                    getBackoff = maximalGetBackoff</div><div class="line">                &#125;</div><div class="line">                time.Sleep(getBackoff)</div><div class="line">            &#125;</div><div class="line">        &#125;()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从该处理方法看出，一旦出现调度失败，k8s 并不会阻塞调度过程，而是将调度失败的 pod 扔到这个失败处理方法里，而这个方法是通过异步的方式进行重试。k8s 从 backoff 这个列表中拿出指定的 pod，然后将它再次放到 <code>FIFO</code> 队列里，期间如果继续失败，再扔进 backoff 里异步等待处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>k8s 的代码量非常庞大，需要快速定位源码比较困难，而采用这种根据从入口不断深入的阅读方式会减少很多工作量，只关心一部分的代码。当然这也无法从一个宏观的角度去看整个代码的设计，但是对于当前的工作已经足够。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jetmuffin.com/posts/kubernetes.jpg&quot; alt=&quot;k8s&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="kubernetes" scheme="http://blog.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="scheduler" scheme="http://blog.jetmuffin.com/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>How to fix &#39;/bin/rm: Argument list too long</title>
    <link href="http://blog.jetmuffin.com/2016/11/13/How-to-fix-bin-rm-Argument-list-too-long/"/>
    <id>http://blog.jetmuffin.com/2016/11/13/How-to-fix-bin-rm-Argument-list-too-long/</id>
    <published>2016-11-13T08:09:57.000Z</published>
    <updated>2016-11-13T08:18:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>做运维时发现系统的磁盘满了，检查发现磁盘的 <code>/tmp</code> 目录下装满了东西，于是很简单的想用 <code>rm -rf /tmp/*</code> 来删除，结果发现报错：<code>bash: /bin/rm: Argument list too long</code>。找了找方法解决它。<br><a id="more"></a></p>
<p>当执行命令时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/rm -rf ./*</div></pre></td></tr></table></figure>
<p>得到了错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash: /bin/rm: Argument list too long</div></pre></td></tr></table></figure>
<p>查看发现，<code>rm</code> 命令也有参数长度的限制，所以需要用管道将命令分批次输入到 <code>rm</code> 中去。</p>
<p>因此 <code>xargs</code> 就派上用场了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;_MEI*&quot; | xargs /bin/rm -rf</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;_MEI*&quot; -print0 | xargs /bin/rm -rf</div></pre></td></tr></table></figure>
<p>或者更直接的用 <code>find</code> 的 <code>-delete</code> 参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;_MEI*&quot; -delete</div></pre></td></tr></table></figure>
<p>即可解决。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做运维时发现系统的磁盘满了，检查发现磁盘的 &lt;code&gt;/tmp&lt;/code&gt; 目录下装满了东西，于是很简单的想用 &lt;code&gt;rm -rf /tmp/*&lt;/code&gt; 来删除，结果发现报错：&lt;code&gt;bash: /bin/rm: Argument list too long&lt;/code&gt;。找了找方法解决它。&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://blog.jetmuffin.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="http://blog.jetmuffin.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Difference between Mesos and Kubernetes</title>
    <link href="http://blog.jetmuffin.com/2016/10/24/Difference-between-Mesos-and-Kubernetes/"/>
    <id>http://blog.jetmuffin.com/2016/10/24/Difference-between-Mesos-and-Kubernetes/</id>
    <published>2016-10-24T03:09:27.000Z</published>
    <updated>2016-10-24T06:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>自 Docker 大火之后，Swarm，Mesos，Kubernetes 这类围绕 Docker 容器展开的集群开源管理项目也逐渐风起云涌。本文主要从多个方面整理当前主流的两个容器编排框架 Mesos 和 Kubernetes 的区别。</p>
<a id="more"></a>  
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache Mesos 始于加州大学伯克利分校的一个项目，用来驱动 Twitter 的底层基础架构，并且在之后成为许多大公司，如 eBay 和 Airbnb 的重要工具。之后 Mesos 的作者之一 Ben Hindman 创立了商业化公司 Mesosphere，并为 Mesos 社区贡献了许多持续性的开发和支持工具。</p>
<p>而 Kubernetes 则是出自 Google 公司，基于他们在 Borg 上的经验总结，推出的极具“谷歌风格”的开源集群容器管理平台。Kubernetes 和 Borg 的开发和维护是由 Google 的同一个团队进行的。</p>
<h2 id="社区人气"><a href="#社区人气" class="headerlink" title="社区人气"></a>社区人气</h2><p>在资源和容器管理方面，大公司（诸如微软、BAT 等）会自己造内部的轮子进行使用，而规模较小的公司则采用开源项目或基于开源项目进行二次开发。而在社区上，大家对 Docker 容器编排技术的选择更趋向于哪些方面？</p>
<p><img src="/uploads/images/2016/10/24/1.png" alt="rihe.png"></p>
<p>Caicloud 在 2016 年 2 月统计了包括 Kubernetes, Swarm, Compose, Mesos, Docker Machine, Hyper, Containerd 在内的7个项目在 Github 上的 fork 数和被 star 数等。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>在 fork 上的数据，Kubernetes 以 3699 次遥遥领先于其他所有的编排框架，而 Mesos 仅有 738 次 fork。而在笔者写这篇文章时（2016 年 10 月 24 日），Kubernetes 的 fork 数已经超过了 5800 次，而 Mesos 大概在 1050 次 fork。</p>
<p><img src="/uploads/images/2016/10/24/2.png" alt="fork.png"></p>
<h3 id="star"><a href="#star" class="headerlink" title="star"></a>star</h3><p>star 的数据上 Kubernetes 依然以 12888 颗星数雄踞榜首，而 Mesos 仅有 2056 次 star。而直到今天，Kubernetes 已经拿到了近 17800 颗 star，而 Mesos 的 star 数量仅在 2600 次。</p>
<p><img src="/uploads/images/2016/10/24/3.png" alt="star.png"></p>
<p>从 fork 和 star 数量可以看出两个框架在社区中的受欢迎程度，Kubernetes 远大于 Mesos。当然，由于 Kubernetes 出自名门，其中自然也带有一些来自于对 Google 公司的影响，而 Mesos 则更显得稍微小众一些。当然，社区的支持度越大，对开源框架的贡献者则越多，那么这个框架的发展则越迅速。</p>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>虽然同样被视为容器编排框架，但是 Kubernetes 和 Mesos 的设计理念完全不同。</p>
<p>## </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自 Docker 大火之后，Swarm，Mesos，Kubernetes 这类围绕 Docker 容器展开的集群开源管理项目也逐渐风起云涌。本文主要从多个方面整理当前主流的两个容器编排框架 Mesos 和 Kubernetes 的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="http://blog.jetmuffin.com/tags/mesos/"/>
    
      <category term="kubernetes" scheme="http://blog.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="docker" scheme="http://blog.jetmuffin.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Debian下编译shadowsocks-qt5</title>
    <link href="http://blog.jetmuffin.com/2016/10/18/compile-shadowsocks-qt5-on-debian/"/>
    <id>http://blog.jetmuffin.com/2016/10/18/compile-shadowsocks-qt5-on-debian/</id>
    <published>2016-10-18T05:53:08.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时开发用的是 debian 的 linux 发行版，而 shadowsocks-qt5 没有提供 debian 的 release 版本，于是得自己动手编译，编译的时候会遇到许多坑，这里记录一下。</p>
<a id="more"></a>
<h3 id="libQtshadowsocks"><a href="#libQtshadowsocks" class="headerlink" title="libQtshadowsocks"></a>libQtshadowsocks</h3><p>首先需要编译 shadowsocks 的 lib 库 <code>libQtShadowsocks</code>，从 <a href="https://github.com/shadowsocks/libQtShadowsocks/releases" target="_blank" rel="external">github/libQtshadowsocks</a> 上找到稳定版本，直接下载源码的 .tar.gz 文件到本地，解压，并进入文件夹。</p>
<p>wiki 上对编译的依赖描述如下：</p>
<blockquote>
<p>Qt &gt;= 5.2 (qt5-qtbase-devel and qt5-qttools in Fedora, qtbase5-dev and qt5-qmake in Debian/Ubuntu)<br>Botan &gt;= 1.10 (botan-devel in Fedora, libbotan1.10-dev in Debian/Ubuntu)<br>A C++ Compiler that supports C++11 features (i.e. GCC &gt;= 4.7) </p>
</blockquote>
<p>但是只安装这些依赖，在 debian 下会出现 <code>botan-1.10 development package not found</code> 的错误，但是检查后发现 <code>libbotan1.10-dev</code> 包已经安装了。</p>
<p>后来发现是有其他的依赖没满足，所以干脆一次性把所有依赖全部装了，就不会出现问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libappindicator-dev libzbar-dev libbotan1.10-dev</div></pre></td></tr></table></figure>
<p>然后进入进行编译，编译时可以选择 <code>INSTALL_PREFIX</code>，它默认是 <code>/usr</code> 目录，如果自行更改会有另外的问题，下面会提到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qmake</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h3 id="shadowsocks-qt5"><a href="#shadowsocks-qt5" class="headerlink" title="shadowsocks-qt5"></a>shadowsocks-qt5</h3><p>编译安装完 <code>libQtShadowsocks</code> 后就可以编译 <code>shadowsocks-qt5</code> 了。从 <a href="https://github.com/shadowsocks/shadowsocks-qt5" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-qt5</a> 上 clone ss-qt5 的源码，然后进入目录编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/shadowsocks/shadowsocks-qt5.git</div><div class="line">cd shadowsocks-qt5</div><div class="line">qmake</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>同样这里的 <code>qmake</code> 可以指定 <code>INSTALL_PREFIX</code>, 默认为 <code>/usr</code>。安装后 ss-qt5 会在 <code>/usr/bin</code> 文件夹中，命令行直接运行 <code>ss-qt5</code> 或者在图形界面中直接搜索就可以运行了。</p>
<h3 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h3><p>如果在运行时仍然碰到 <code>libQtShadowsocks.so.1 not found</code> 这个问题，那么原因就可能是上面所提到的编译 <code>libQtShadowsocks</code> 的问题了。默认指定的 <code>INSTALL_PREFIX</code> 为 <code>/usr</code>，即安装到 <code>/usr/lib</code> 中，而这个路径是自动被加到系统的链接库里的。</p>
<p>而如果自行指定了 <code>INSTALL_PREFIX</code>，例如我选择了 <code>/usr/local</code>，那么这个 so 文件会被安装到 <code>/usr/local/lib</code>，而这个目录不是默认被加到系统链接库里的，那么需要手动加进去，解决方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo &quot;/usr/local/lib&quot; &gt;&gt; &quot;/etc/ld.so.conf&quot;</div><div class="line">/sbin/ldconfig</div></pre></td></tr></table></figure>
<p>然后再运行 ss-qt5 就没有问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时开发用的是 debian 的 linux 发行版，而 shadowsocks-qt5 没有提供 debian 的 release 版本，于是得自己动手编译，编译的时候会遇到许多坑，这里记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="设计开发" scheme="http://blog.jetmuffin.com/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="shadowsocks" scheme="http://blog.jetmuffin.com/tags/shadowsocks/"/>
    
      <category term="debian" scheme="http://blog.jetmuffin.com/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>使用 gh-md-doc 生成 markdown 文章结构</title>
    <link href="http://blog.jetmuffin.com/2016/09/13/use-gh-md-doc-to-generate-toc-of-blog/"/>
    <id>http://blog.jetmuffin.com/2016/09/13/use-gh-md-doc-to-generate-toc-of-blog/</id>
    <published>2016-09-13T12:23:11.000Z</published>
    <updated>2017-04-06T01:21:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇技巧来自于我在 <a href="http://www.iqiyi.com" target="_blank" rel="external">iQiyi</a> 的云平台部门实习时的内部分享，主要用于文档编写。<br>在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 <a href="https://github.com/ekalinin/github-markdown-toc" target="_blank" rel="external">gh-md-toc</a>。</p>
<a id="more"></a>
<h2 id="生成-markdown-table-of-contents"><a href="#生成-markdown-table-of-contents" class="headerlink" title="生成 markdown table of contents"></a>生成 markdown table of contents</h2><hr>
<p>常常项目开发的文档都是用 markdown 格式编写，并且以代码的形式托管在 Git 上，<br>同时，那么就可以使用 <a href="https://github.com/ekalinin/github-markdown-toc" target="_blank" rel="external">gh-md-toc</a><br>来生成文档目录。</p>
<p>但是，gh-md-toc 会直接将结果打印到 stout，而我们想要的最好的效果是直接将其添加到文档头部，<br>而不是从 stdout 再复制粘贴，然后还要格式化空行。</p>
<p>以本文档为例，gh-md-toc 生成的 table of contents 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Table of Contents</div><div class="line">=================</div><div class="line"></div><div class="line">    * [生成 markdown table of contents](#生成-markdown-table-of-contents)</div><div class="line">    * [使用 gh-md-toc 的奇技淫巧](#使用-gh-md-toc-的奇技淫巧)</div><div class="line"></div><div class="line">Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)</div></pre></td></tr></table></figure>
<p>显然，我们需要将这段文字添加到文件的头部，并且<strong>删除第一行空行，在最后一行添加一行空行</strong>。</p>
<h2 id="使用-gh-md-toc-的奇技淫巧"><a href="#使用-gh-md-toc-的奇技淫巧" class="headerlink" title="使用 gh-md-toc 的奇技淫巧"></a>使用 gh-md-toc 的奇技淫巧</h2><p>OK，Let’s Rock!</p>
<p>先看一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gh-md-toc file.md | (tail -n +2 &amp;&amp; echo &quot;&quot; &amp;&amp; cat file.md) | sponge file.md</div></pre></td></tr></table></figure>
<p>你会惊讶的发现，这条命令就完成了所有事，为 file.md 生成了 table of<br>contents，并且自动添加在了 file.md 的头部，并且完美的处理了空行。</p>
<p>这里使用了一个好工具 <code>sponge</code>，需要安装包 <code>moreutils</code>。想想为什么不能直接重定向到 file.md 呢？</p>
<p>但是，追求极致的程序员不会止步，因为上面的命令中 file.md 这个待处理的文件出现了<br>3 次，所以也挺烦人的，对吧，即使使用命令替换也来得不如一次直接。</p>
<p>OK，Let’s Rock Again!</p>
<p>添加一个函数，重定义 gh-md-toc，添加下面的函数定义到你的 shell rc，例如：</p>
<ul>
<li>bash，~/.bashrc</li>
<li>zsh，~/.zshrc</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> gh-md-<span class="function"><span class="title">toc</span></span>() &#123;</div><div class="line">  <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">"gh-md-toc &lt;markdown file&gt;"</span></div><div class="line">      <span class="built_in">return</span> 1</div><div class="line">  <span class="keyword">fi</span></div><div class="line">  /home/chengwei/Github/github-markdown-toc/gh-md-toc <span class="variable">$1</span> | (tail -n +2 &amp;&amp; <span class="built_in">echo</span> <span class="string">""</span> &amp;&amp; cat <span class="variable">$1</span>) | sponge <span class="variable">$1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将上面的 <code>/home/chengwei/Github/github-markdown-toc/gh-md-toc</code> 替换成 gh-md-doc<br>在你的系统上的路径。</p>
<p><strong>注意：如果你把 gh-md-doc 放在了 $PATH 中，必须用绝对路径调用，否则就无限递归了 :-)</strong></p>
<p>最后，source shell rc 配置文件，生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">source</span> ~/.bashrc</div><div class="line">OR</div><div class="line">$ <span class="built_in">source</span> ~/.zshrc</div></pre></td></tr></table></figure>
<p>现在，要为某个 markdown 文件添加 table of contents 只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gh-md-toc file.md</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇技巧来自于我在 &lt;a href=&quot;http://www.iqiyi.com&quot;&gt;iQiyi&lt;/a&gt; 的云平台部门实习时的内部分享，主要用于文档编写。&lt;br&gt;在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 &lt;a href=&quot;https://github.com/ekalinin/github-markdown-toc&quot;&gt;gh-md-toc&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="设计开发" scheme="http://blog.jetmuffin.com/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="markdown" scheme="http://blog.jetmuffin.com/tags/markdown/"/>
    
      <category term="gh-md-doc" scheme="http://blog.jetmuffin.com/tags/gh-md-doc/"/>
    
  </entry>
  
  <entry>
    <title>Moore vote algorithm 多数投票算法</title>
    <link href="http://blog.jetmuffin.com/2016/09/04/moore-vote-algorithm/"/>
    <id>http://blog.jetmuffin.com/2016/09/04/moore-vote-algorithm/</id>
    <published>2016-09-04T12:24:16.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在刷 leetcode 时，发现一道题目 <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="external">Majority Element</a>，要求求出数组中出现元素超过 <code>n/2</code> 的元素。思考了许久也只能写出 <code>O(nlogn)</code> 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 <code>O(n)</code> 时间和 <code>O(1)</code> 空间解决这个问题。</p>
<a id="more"></a>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>算法的思想很简单，每次从数组中取一对数，如果相同就叠加，如果不同就一起删去，很明显最后留下的肯定是数量最多的一个数。再深入一步实现，只要用一个变量记录<strong>标记元素</strong>和<strong>标记元素的出现次数</strong>，然后找下一个元素，分以下情况：</p>
<ul>
<li>如果下一个元素和标记元素相同，那么标记元素出现次数加1；</li>
<li>如果和标记元素不同，那么标记元素出现次数减1；</li>
<li>如果标记元素变为 0，那么取下一个元素作为标记元素，初始出现次数为1；</li>
</ul>
<p>举个说明性的例子，数列 <code>[2,3,2,2,4,1,2]</code>，标记元素变量 <code>now</code>，出现次数 <code>count</code></p>
<ol>
<li>初始状态（取第一个数）：<code>now:2</code>，<code>count:1</code></li>
<li>取第二个数 <code>3</code>，它和 <code>now</code> 不同，那么 <code>count--</code>，这时候 <code>count = 0</code>，那么拿下一个元素（第三个数）为标记元素 <code>now:2</code>，<code>count:1</code></li>
<li>取第四个数 <code>2</code>，它和 <code>now</code> 相同，那么 <code>count++</code>，状态变为 <code>now:2</code>，<code>count:2</code></li>
<li>取第五个数 <code>4</code>，它和 <code>now</code> 不同，那么 <code>count--</code>，状态变为 <code>now:2</code>，<code>count:1</code></li>
<li>重复以上过程直到结尾，最后 <code>now:2</code>，所以数量超过 <code>n/2</code> 的元素为 2</li>
</ol>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>为了更好实现上述过程，事实上程序的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">For i from 0 to len(arr):</div><div class="line">    if count == 0:</div><div class="line">        now = arr[i]</div><div class="line">        count = 1</div><div class="line">    else:</div><div class="line">        if now == arr[i]:</div><div class="line">            count ++</div><div class="line">        else:</div><div class="line">            count --</div></pre></td></tr></table></figure>
<p>即只要标记元素被删去了，那么访问的下一个元素就作为标记元素。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, now = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</div><div class="line">                now = nums[i];</div><div class="line">                count = <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span>(now == nums[i]) &#123;</div><div class="line">                    count ++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    count --;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> now;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/" target="_blank" rel="external">算法效果演示</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在刷 leetcode 时，发现一道题目 &lt;a href=&quot;https://leetcode.com/problems/majority-element/&quot;&gt;Majority Element&lt;/a&gt;，要求求出数组中出现元素超过 &lt;code&gt;n/2&lt;/code&gt; 的元素。思考了许久也只能写出 &lt;code&gt;O(nlogn)&lt;/code&gt; 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 &lt;code&gt;O(n)&lt;/code&gt; 时间和 &lt;code&gt;O(1)&lt;/code&gt; 空间解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="算法分析" scheme="http://blog.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="moore vote algorithm" scheme="http://blog.jetmuffin.com/tags/moore-vote-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础学习（二）类型</title>
    <link href="http://blog.jetmuffin.com/2016/09/04/go-learning-2/"/>
    <id>http://blog.jetmuffin.com/2016/09/04/go-learning-2/</id>
    <published>2016-09-04T02:25:44.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>go 语言中有许多的类型，包括字符串、整形、浮点型、布尔型等等，这和一般的语言相同。这些类型之间可以进行基本的运算，这和 C, Java 等语言也是相同的。</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math/cmplx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    flag   <span class="keyword">bool</span>       = <span class="literal">false</span></div><div class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></div><div class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"go"</span> + <span class="string">"lang"</span>)</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"1+1 = "</span>, <span class="number">1</span>+<span class="number">1</span>)</div><div class="line">    fmt.Println(<span class="string">"7.0/3.0 ="</span>, <span class="number">7.0</span>/<span class="number">3.0</span>)</div><div class="line"></div><div class="line">    fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)</div><div class="line">    fmt.Println(<span class="literal">true</span> || <span class="literal">false</span>)</div><div class="line">    fmt.Println(!<span class="literal">true</span>)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> f = <span class="string">"%T(%v)\n"</span></div><div class="line">    fmt.Printf(f, flag, flag)</div><div class="line">    fmt.Printf(f, MaxInt, MaxInt)</div><div class="line">    fmt.Printf(f, z, z)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>go 语言中的基础数据类型包括以下几种：</p>
<ul>
<li>int，Rune（Rune 是 int 的别名，代表一个 Unicode 码）</li>
<li>int8，int16，int32，int64</li>
<li>byte，uint8，uint16，uint32，uint64（byte 是 uint8 的别名）</li>
<li>float32，float64</li>
<li>bool</li>
<li>string</li>
<li>complex128，complex64（复数）</li>
</ul>
<p>源码中 <code>runtime.h</code> 对几种简单的基本类型先做了定义，然后用它们对其他的类型进行定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>             int8;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>           uint8;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span>            int16;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>          uint16;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">int</span>              int32;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>            uint32;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>    int64;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>                   float32;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>                  float64;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> uint32                  uintptr</div><div class="line"><span class="keyword">typedef</span> int32                   intptr</div><div class="line"><span class="keyword">typedef</span> int32                   intgo</div><div class="line"><span class="keyword">typedef</span> uint32                  uintgo</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> uint8                   <span class="keyword">bool</span>;</div><div class="line"><span class="keyword">typedef</span> uint8                   byte;</div></pre></td></tr></table></figure>
<p>从中可以看出 go 中的每个类型在 c 中对应的类型和占用字节大小。另外其中还定义了 <code>intptr</code> 和 <code>intgo</code>，其中 <code>intptr</code> 用于指针运算，<code>intgo</code> 相当于在源码中给 <code>int</code> 起的一个别名。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string 类型事实上是一个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct String &#123;</div><div class="line">    byte*   str;</div><div class="line">    intgo   len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对于每个 string 类型，都确定了它的长度和字符数组，也就是说 golang 的字符串初始化话底层的结构就会被初始化。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>go 中使用 <code>var</code> 作为关键字来进行变量声明。但和 javascript 里不同，go 中的变量是强类型。声明的方式有多种，包括：</p>
<ul>
<li><code>var a int</code>（仅声明不初始化）</li>
<li><code>var a = 10</code>（声明同时初始化，但不指定类型，由编译器自动推导类型）</li>
<li><code>var a int = 10</code>（声明、指定类型以及初始化）</li>
<li><code>a := 10</code>（省略关键字，声明同时初始化，由编译器推导类型）</li>
</ul>
<p><strong>Note:</strong> 这里需要注意的是，<code>:=</code>是用于声明及赋值，而不是赋值，因此仅在变量定义时使用，开始写 go 的时候常常将 <code>:=</code> 用于赋值导致出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"initial"</span></div><div class="line">    fmt.Println(a)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b, c <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></div><div class="line">    fmt.Println(b, c)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></div><div class="line">    fmt.Println(d)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> e <span class="keyword">int</span></div><div class="line">    fmt.Println(e)</div><div class="line"></div><div class="line">    f := <span class="string">"short"</span></div><div class="line">    fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>对变量声明语句，编译器会对其进行自动的类型推导，可以用 <code>reflect</code> 包来查看变量的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></div><div class="line">    <span class="keyword">var</span> b <span class="keyword">byte</span> = <span class="number">10</span></div><div class="line"></div><div class="line">    c := <span class="number">10.0</span></div><div class="line">    d := <span class="string">"10"</span></div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"a type:%s\n"</span>, reflect.TypeOf(a))</div><div class="line">    fmt.Printf(<span class="string">"b type:%s\n"</span>, reflect.TypeOf(b))</div><div class="line">    fmt.Printf(<span class="string">"c type:%s\n"</span>, reflect.TypeOf(c))</div><div class="line">    fmt.Printf(<span class="string">"d type:%s\n"</span>, reflect.TypeOf(d))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a type:int</div><div class="line">b type:uint8</div><div class="line">c type:float64</div><div class="line">d type:string</div></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>正常情况下，将类型 V 转化为 T 需要显式声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a := 5 // typeof(a) is int32</div><div class="line">b := int64(10) // typeof(b) is int64</div></pre></td></tr></table></figure>
<p>若没有显式声明还需要进行类型转换 V -&gt; T，则需要满足 <code>assignability</code>，根据文档<a href="https://golang.org/ref/spec#Assignability" target="_blank" rel="external">assignability</a>，可能的条件如下：</p>
<ul>
<li>T 和 V 的类型相同</li>
<li>T 和 V 的基础类型相同，并且其中至少一个并未显式指定类型</li>
<li>T 是一个 <code>interface</code> 类型，并且 V 实现了 T (这在后面会提到)</li>
<li>V 是一个双向的 <code>channel</code>，而 T 是一个 <code>channel</code>，同时 V 和 T 的元素类型相同</li>
<li>V 是 nil 同时 T 是 <code>slice</code>, <code>function</code>, <code>map</code>, <code>channel</code>, <code>interface</code>, <code>pointer</code> 中的一种</li>
<li>V 是未声明类型的常量</li>
</ul>
<p>在这些条件下，不需要显式声明，直接可以将 T 的值赋予 V。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>go 中的常量和 c 相同，需要在编译时确定值，并在编译时被创建。常量需要满足以下几个要求：</p>
<ul>
<li>类型必须是数值、字符串和布尔值之一</li>
<li>可以使用表达式，但表达式必须在编译时可以计算的</li>
<li>声明常量同时必须指定值（初始化），并且不能再修改值</li>
</ul>
<p>常量的关键字和 cpp 相同，用 <code>const</code> 进行声明，声明时可以显式指定数据类型，也可以不指定。多个常量可以同时进行批量声明，常见的使用方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    s <span class="keyword">string</span> = <span class="string">"constant"</span></div><div class="line">    one, two = <span class="number">1</span>, <span class="number">2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(s)</div><div class="line">    fmt.Println(one)</div><div class="line">    fmt.Println(two)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> n = <span class="number">500000000</span></div><div class="line">    <span class="keyword">const</span> d = <span class="number">3e20</span> / n</div><div class="line">    fmt.Println(d)</div><div class="line"></div><div class="line">    fmt.Println(<span class="keyword">int64</span>(d))</div><div class="line"></div><div class="line">    fmt.Println(math.Sin(n))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota 在 go 中用于常量计数。iota 在 const 关键字出现时置 0，并且 const 内每增加一行讲使 itoa 计数一次，举个例子应该就很清楚了。</p>
<p>```go<br>const a = iota // a = 0<br>const b = iota // b = 0<br>const (<br>    c = iota   // c = 0<br>    d = iota   // d = 1<br>    e = iota   // e = 2<br>)<br>const (<br>    f, g = iota, 1 &lt;&lt; iota // f = 0, g = 1<br>    h, i = iota, 1 &lt;&lt; iota // h = 1, i = 2<br>)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://golang.org/ref/spec#Constant" target="_blank" rel="external">Golang Document</a></li>
<li><a href="http://www.cnblogs.com/howDo/archive/2013/04/15/GoLang-Constant.html" target="_blank" rel="external">老虞学GoLang笔记</a></li>
<li><a href="http://www.tuicool.com/articles/MJZvi27" target="_blank" rel="external">golang的类型转换的坑和分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h2&gt;&lt;p&gt;go 语言中有许多的类型，包括字符串、整形、浮点型、布尔型等等，这和一般的语言相同。这些类型之间可以进行基本的运算，这和 C, Java 等语言也是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.jetmuffin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="http://blog.jetmuffin.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础学习（一）</title>
    <link href="http://blog.jetmuffin.com/2016/09/03/go-learning-1/"/>
    <id>http://blog.jetmuffin.com/2016/09/03/go-learning-1/</id>
    <published>2016-09-03T12:09:56.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>最初接触 go 是在 15 年，最开始对 go 的理解是写多线程的程序非常方便，于是学习了 go 的基本语法，并尝试写了一些 go 的简单应用，包括我的本科毕业设计也是使用 go 写的（<a href="https://github.com/icsnju/apt-mesos" target="_blank" rel="external">apt-mesos</a>）。但是对 go 也是停留在最基本的语法认识，有很多特性并未了解。所以想要从头再屡一遍 go 的所有内容。对每一块儿内容，以重学的角度深入学习。</p>
<a id="more"></a>
<h2 id="教程与代码"><a href="#教程与代码" class="headerlink" title="教程与代码"></a>教程与代码</h2><p>学习的过程将使用教程（<a href="https://gobyexample.com/" target="_blank" rel="external">https://gobyexample.com/</a>），它对 go 的每块儿内容提供了 demo，可以更易于理解。教程中的例程，将对其进行理解和实现，然后将代码整理在仓库 [<a href="https://github.com/JetMuffin/golearning.git" target="_blank" rel="external">JetMuffin/golearning</a>]中。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>任何语言的入门，都需要编写一个 Hello World 程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"hello world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一段使用 <code>fmt</code> 进行输出 <code>hello world</code> 字符的代码，从语言的风格上看，go 使用 <code>package</code> 作为关键字进行包管理，这和 java 很像；而导入包的部分则又像 python；而主函数部分也比较独特。庆幸的是，go 中也不需要添加分号。</p>
<p>go 和 python，ruby 等不同，它是解释型语言，因此在每次运行前需要进行编译，然后才可以进行执行，或者直接进行编译执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ go run helloworld.go</div><div class="line">hello world</div><div class="line"></div><div class="line">$ go build helloworld.go</div><div class="line">$ ls</div><div class="line">helloworld      helloworld.go</div><div class="line"></div><div class="line">$ ./helloworld</div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>这里需要知道的一点是，编译好后生成了 binary 文件，可以在同平台下直接进行运行，但并无法做到 runing everywhere，因为可能需要涉及到交叉编译的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;最初接触 go 是在 15 年，最开始对 go 的理解是写多线程的程序非常方便，于是学习了 go 的基本语法，并尝试写了一些 go 的简单应用，包括我的本科毕业设计也是使用 go 写的（&lt;a href=&quot;https://github.com/icsnju/apt-mesos&quot;&gt;apt-mesos&lt;/a&gt;）。但是对 go 也是停留在最基本的语法认识，有很多特性并未了解。所以想要从头再屡一遍 go 的所有内容。对每一块儿内容，以重学的角度深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.jetmuffin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="http://blog.jetmuffin.com/tags/golang/"/>
    
      <category term="hello world" scheme="http://blog.jetmuffin.com/tags/hello-world/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix配合lm_sensors监控服务器CPU温度</title>
    <link href="http://blog.jetmuffin.com/2016/09/01/monitor-temperature-of-server-by-zabbix-and-lm-sensors/"/>
    <id>http://blog.jetmuffin.com/2016/09/01/monitor-temperature-of-server-by-zabbix-and-lm-sensors/</id>
    <published>2016-09-01T06:18:06.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。</p>
<p>首先是获取 CPU 温度的方法，常见的有两种：</p>
<ul>
<li>IPMI</li>
<li>lm_sensors</li>
</ul>
<p>其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>lm_sensors 的安装很简单，repo 里已经有这个包了，所以直接通过 yum 安装就行了（集群是用的 CentOS，Debian系的也差不多）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install lm_sensors</div></pre></td></tr></table></figure>
<p>考虑到大多数集群是无法直接通外网的，所以可以在一台可以通外网的机器上下好 rpm 包，再传到 NFS 上或者直接 <code>scp</code>进去。下载 rpm 包可以使用 <code>yumdownloader</code>，刚好 lm_sensors 没有要依赖的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yumdownloader install lm_sensors</div></pre></td></tr></table></figure>
<h2 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h2><p>采集数据之前，先看一下 zabbix 的自定义监控项的定义方法。在 <code>zabbix_agentd</code> 中对自定义监控项的定义格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserParameter=&lt;key&gt;,&lt;shell command&gt;</div></pre></td></tr></table></figure>
<p>其中可以看出监控项通过一句 shell 命令获得，并且获得的需要是一个数值。这样我们大概明确了需要采集的目标。</p>
<p>然后先简单过掉下 lm_sensors 需要的配置，即监测 sensors 的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sensors-detect</div><div class="line">This program will <span class="built_in">help</span> you determine <span class="built_in">which</span> kernel modules you need</div><div class="line">to load to use lm_sensors most effectively. It is generally safe</div><div class="line">and recommended to accept the default answers to all questions,</div><div class="line">unless you know what you<span class="string">'re doing.</span></div><div class="line"></div><div class="line">Some south bridges, CPUs or memory controllers contain embedded sensors.</div><div class="line">Do you want to scan for them? This is totally safe. (YES/no):</div></pre></td></tr></table></figure>
<p>一路敲 <code>yes</code> 即可，然后执行 <code>sensors</code> 命令可以看到 CPU 的温度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ sensors</div><div class="line">power_meter-acpi-0</div><div class="line">Adapter: ACPI interface</div><div class="line">power1:     18446.74 GW  (interval =   2.00 s)</div><div class="line"></div><div class="line">coretemp-isa-0000</div><div class="line">Adapter: ISA adapter</div><div class="line">Physical id 0: +41.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 0:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +28.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +34.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line"></div><div class="line">coretemp-isa-0001</div><div class="line">Adapter: ISA adapter</div><div class="line">Physical id 1: +38.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 0:        +33.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +34.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div></pre></td></tr></table></figure>
<p>命令显示的结果是每个核心的温度以及物理核的温度，最后要聚合到一个数值上。这里可以选择两个方向，一是对每个核心进行监控，这样较为复杂，但是细节明显；二是对每个核心取平均值，处理比较简单。这里我选择了后者，那么就需要从命令输出中获取到需要的信息了。这里就用 <code>grep</code>，<code>cut</code>，<code>awk</code> 乱处理一通了。</p>
<p>首先用 <code>grep</code> 拿到每个核心的温度行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ sensors | grep <span class="string">"Core"</span></div><div class="line">Core 0:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +34.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 0:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +33.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div></pre></td></tr></table></figure>
<p>然后用 <code>cut</code> 或者 <code>awk</code> 获取每行的温度数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ sensors | grep <span class="string">"Core"</span> | awk <span class="string">'&#123;print $3&#125;'</span> | awk -F <span class="string">'.'</span> <span class="string">'&#123;print $1&#125;'</span> | awk -F <span class="string">'+'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">30</div><div class="line">33</div><div class="line">29</div><div class="line">34</div><div class="line">30</div><div class="line">30</div><div class="line">31</div><div class="line">34</div><div class="line">32</div><div class="line">32</div><div class="line">32</div><div class="line">30</div></pre></td></tr></table></figure>
<p>最后对这些输出按行取平均，再四舍五入到整数就行了（也可以不四舍五入）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sensors | grep <span class="string">'Core'</span> | awk <span class="string">'&#123;print $3&#125;'</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $1&#125;'</span> | awk -F <span class="string">"+"</span> <span class="string">'&#123;print $2&#125;'</span> | \</div><div class="line">awk <span class="string">'&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;'</span> | awk -F. <span class="string">'&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;'</span></div><div class="line">31</div></pre></td></tr></table></figure>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>做完数据的采集工作，那么就要集成进 Zabbix 里了。首先需要在 zabbix_agentd 里定义这个监控项，在 <code>zabbix_agentd.conf</code> 里加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserParameter=system.cpu.temperature,/usr/bin/sensors | grep &apos;Core&apos; | awk &apos;&#123;print $3&#125;&apos; | awk -F &quot;.&quot; &apos;&#123;print $1&#125;&apos; | awk -F &quot;+&quot; &apos;&#123;print $2&#125;&apos; | awk  &apos;&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;&apos; | awk -F. &apos;&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;&apos;</div></pre></td></tr></table></figure>
<p>然后重启 agent 服务即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ service zabbix_agentd restart</div><div class="line">Shutting down zabbix_agentd:                               [  OK  ]</div><div class="line">Starting zabbix_agentd:                                    [  OK  ]</div></pre></td></tr></table></figure>
<p>回到 Zabbix 的界面，选择一个合适的模板，进到它的监控项中，点击新建监控项，然后如下图填入信息即可。注意这里的键值即上面填的 <code>UserParameters</code> 里的 <code>key</code>。</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-0@2x.png" alt="add-new-metric"></p>
<p>然后对相应的主机应用这个模板，那么就可以获取到这台主机的 CPU 温度了。</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-1@2x.png" alt="metric-data"></p>
<p>报警设置和普通监控项相同，如下：</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-2@2x.png" alt="alert"></p>
<p>最后，如果对 Zabbix 增加了 grafana 的话，还可以在 grafana 里去显示 CPU 温度。</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-3@2x.png" alt="grafana"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。&lt;/p&gt;
&lt;p&gt;首先是获取 CPU 温度的方法，常见的有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPMI&lt;/li&gt;
&lt;li&gt;lm_sensors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://blog.jetmuffin.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="zabbix" scheme="http://blog.jetmuffin.com/tags/zabbix/"/>
    
      <category term="lm_sensors" scheme="http://blog.jetmuffin.com/tags/lm-sensors/"/>
    
      <category term="cpu" scheme="http://blog.jetmuffin.com/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>InfiniBand技术介绍</title>
    <link href="http://blog.jetmuffin.com/2016/06/07/infiniband-technique/"/>
    <id>http://blog.jetmuffin.com/2016/06/07/infiniband-technique/</id>
    <published>2016-06-07T01:51:44.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>随着服务器处理速度的不断加快，用户对提升网络传输速度的需求也越来越紧迫，传统意义上的输入 / 输出技术， 如 PCI、以太等，已经无法满足这种需求。如何更为有效的提高数据传输速度，增加有效带宽成为摆在人们面前必须解决的一个重大问题。 InfiniBand 标准就是在这种情况下应运而生的，它在很大程度上解决了传统输入 / 输出架构的传输瓶颈问题 , 运行速度可达到每端口 2.5Gb/s 或 10Gb/s 。 目前，这项技术已经广泛应用到高性能计算等领域，Linux 操作系统内核也对其提供了全面的支持，本文将逐一介绍 InfiniBand 技术架构，以及如何在 Red Hat Enterprise Linux 5.3 和 SLES11 系统中配置 InfiniBand 网络设备，包括网卡驱动的安装以及 IPoIB（IP over InfiniBand）接口配置。</p>
</blockquote>
<a id="more"></a>
<h3 id="HPC集群"><a href="#HPC集群" class="headerlink" title="HPC集群"></a>HPC集群</h3><p>高性能计算（HPC）服务器集群在各个行业中正逐步流行开来，主要用于计算密集型任务。包括模拟物体表面上大气或流体流动的计算流体力学，财务风险分析，生物信息学，量子力学等方面计算。</p>
<h3 id="HPC集群中的网络"><a href="#HPC集群中的网络" class="headerlink" title="HPC集群中的网络"></a>HPC集群中的网络</h3><p>网络是HPC集群的核心，用于实现执行并行计算的计算节点之间的通信。</p>
<p>根据使用目的的不同，可以把HPC中的网络大体分为三种类型，在真正搭建HPC集群时使用其中的一种，两种或三种。</p>
<ul>
<li><strong>管理网络</strong>：用于用户维护、控制和操作单个节点的网络</li>
<li><strong>I/O网络</strong>：用于对中央共享文件系统执行读写操作的网络</li>
<li><strong>IPC网络</strong>：用于为并行处理传递消息和数据的流程间通信网络</li>
</ul>
<h3 id="InfiniBand-vs-以太网"><a href="#InfiniBand-vs-以太网" class="headerlink" title="InfiniBand vs 以太网"></a>InfiniBand vs 以太网</h3><p>为了满足HPC集群中的网络需求，通常的解决方案有两种：以太网和InfiniBand。然而这两种网络的区别和使用范围还是很明显的。</p>
<p>传统数据中心常常使用以太网互联（这里的以太网多指千兆以太网），构成一张高速运转的数据网络。以太网采用树状结构，按三层交换机制排列，从核心开始扇形展开。<br>而高性能计算集群则常常使用InfiniBand。InfiniBand的拓扑结构相对更加扁平，如图1所示，它主要依赖于两个核心组件：主机通道适配器<code>HCA（Host Channel Adapter）</code>和InfiniBand交换机。其中HCA为主机设备提供一个接口用于支持所有InfiniBand定义的操作，而交换机则将一个端口接受到的InfiniBand保温转发到另一个端口，支持单播和多播。<br><img src="/uploads/images/2016/06/07/image001.jpg" alt="图1. InfiniBand拓扑结构"></p>
<p>也是取决于InfiniBand的结构决定了它的带宽大、延迟低的优势，也正因为如此被广泛使用在高性能集群中。</p>
<p>近年来万兆以太网逐渐进入市场，它启用了CSMA/CD来处理数据包冲突，而采用全双工模式以降低延迟，同时它支持更大的带宽，然而万兆以太网在延迟上仍然比InfiniBand高，同时成本也相比InfiniBand高。但是在未来，万兆以太网可能会影响InfiniBand在高性能集群中的市场。</p>
<h3 id="InfiniBand在Linux中的使用"><a href="#InfiniBand在Linux中的使用" class="headerlink" title="InfiniBand在Linux中的使用"></a>InfiniBand在Linux中的使用</h3><p>Red Hat产品中从Red Hat Enterprise Linux 5.3开始正式从内核中集成对InfiniBand网卡的支持，并开始讲InfiniBand所需的驱动以及库文件打包到发行版的CD里，所以推荐使用Red Hat 5.3之后的系统版本。而对于其他发行版的Linux，都在支持InfiniBand。</p>
<h3 id="配置及错误总结"><a href="#配置及错误总结" class="headerlink" title="配置及错误总结"></a>配置及错误总结</h3><p>详见下一篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着服务器处理速度的不断加快，用户对提升网络传输速度的需求也越来越紧迫，传统意义上的输入 / 输出技术， 如 PCI、以太等，已经无法满足这种需求。如何更为有效的提高数据传输速度，增加有效带宽成为摆在人们面前必须解决的一个重大问题。 InfiniBand 标准就是在这种情况下应运而生的，它在很大程度上解决了传统输入 / 输出架构的传输瓶颈问题 , 运行速度可达到每端口 2.5Gb/s 或 10Gb/s 。 目前，这项技术已经广泛应用到高性能计算等领域，Linux 操作系统内核也对其提供了全面的支持，本文将逐一介绍 InfiniBand 技术架构，以及如何在 Red Hat Enterprise Linux 5.3 和 SLES11 系统中配置 InfiniBand 网络设备，包括网卡驱动的安装以及 IPoIB（IP over InfiniBand）接口配置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础架构" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="hpc" scheme="http://blog.jetmuffin.com/tags/hpc/"/>
    
      <category term="网络" scheme="http://blog.jetmuffin.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="InfiniBand" scheme="http://blog.jetmuffin.com/tags/InfiniBand/"/>
    
  </entry>
  
  <entry>
    <title>使用slurm进行集群的资源管理（vagrant）</title>
    <link href="http://blog.jetmuffin.com/2016/05/30/install-and-use-slurm-on-ubuntu/"/>
    <id>http://blog.jetmuffin.com/2016/05/30/install-and-use-slurm-on-ubuntu/</id>
    <published>2016-05-30T01:42:48.000Z</published>
    <updated>2017-02-17T13:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。</p>
</blockquote>
<a id="more"></a>
<p>slrum相当于一个集群管理器，可以伸缩至大型节点集群，容错好，而更重要的是他开源。而现在，slurm已经成为很多强大的超级计算机上使用的资源管理器。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://www.ibm.com/developerworks/cn/linux/l-slurm-utility/figure2.gif" alt="slurm架构"><br>slurm的架构和一般的集群管理架构相类似，顶部是一对冗余集群控制器，它充当计算集群的管理器并实现一个管理守护程序（<code>slurmctld</code>），<code>slurmctld</code>提供了对计算资源的监视，同时它将进入的作业映射到基本的计算资源。</p>
<p>此外，每个计算节点上有一个守护程序<code>slurmd</code>，<code>slurmd</code>负责管理在其上执行的节点包括运行的任务，来自控制器的工作，以及接受控制器的请求等。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装上，为了模拟集群的环境，需要使用多个节点，所以我们用<code>vagrant</code>创建多个虚拟机。<code>Vagrantfile</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- mode: ruby -*-</div><div class="line"># vi: set ft=ruby :</div><div class="line">Vagrant.configure(2) do |config|</div><div class="line">  config.vm.box = &quot;ubuntu/trusty64&quot;</div><div class="line">  config.ssh.insert_key = false</div><div class="line">  config.vm.define &quot;master&quot; do |node|</div><div class="line">	node.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.10&quot;</div><div class="line">	node.vm.hostname = &quot;master&quot;</div><div class="line">	node.vm.provider &quot;virtualbox&quot; do |v|</div><div class="line">	  v.memory = 2048</div><div class="line">	  v.cpus = 2</div><div class="line">	end</div><div class="line">  end</div><div class="line">  config.vm.define &quot;compute&quot; do |slave|</div><div class="line">	slave.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot;</div><div class="line">	slave.vm.hostname = &quot;compute&quot;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>分别使用<code>vagrant up master</code>和<code>vagrant up compute</code>启动控制节点和计算节点。</p>
<p>Ubuntu源里提供了munge，所以可以直接通过源进行安装。在控制节点和计算节点分别安装slurm包，这个包里包含了<code>slurmctld</code>和<code>slurmd</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install slurm-llnl</div></pre></td></tr></table></figure>
<p>由于计算节点和控制节点需要通信，而通信之间需要进行认证，所以这里需要生成key并启动认证服务。这里使用的是llnl的munge。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo create-munge-key</div><div class="line">Generating a pseudo-random key using /dev/urandom complete.</div></pre></td></tr></table></figure>
<p>然后启动munge的认证服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service munge start</div></pre></td></tr></table></figure>
<p>接下来配置slurm的配置文件，然而笔者在使用时，slrum的配置工具<a href="https://computing.llnl.gov/linux/slurm/configurator.html" target="_blank" rel="external">Slurm Configuration Tool</a>失效了，所以可以去slurm的源码里复制一份<a href="https://github.com/SchedMD/slurm/blob/master/etc/slurm.conf.example" target="_blank" rel="external">example</a>。我的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">ClusterName=vagrant</div><div class="line">ControlMachine=master</div><div class="line">#ControlAddr=</div><div class="line">#</div><div class="line">SlurmUser=slurm</div><div class="line">SlurmctldPort=6817</div><div class="line">SlurmdPort=6818</div><div class="line">AuthType=auth/munge</div><div class="line">StateSaveLocation=/tmp</div><div class="line">SlurmdSpoolDir=/tmp/slurmd</div><div class="line">SwitchType=switch/none</div><div class="line">MpiDefault=none</div><div class="line">SlurmctldPidFile=/var/run/slurmctld.pid</div><div class="line">SlurmdPidFile=/var/run/slurmd.pid</div><div class="line">ProctrackType=proctrack/pgid</div><div class="line">ReturnToService=0</div><div class="line">#</div><div class="line"># TIMERS</div><div class="line">SlurmctldTimeout=300</div><div class="line">SlurmdTimeout=300</div><div class="line">InactiveLimit=0</div><div class="line">MinJobAge=300</div><div class="line">KillWait=30</div><div class="line">Waittime=0</div><div class="line">#</div><div class="line"># SCHEDULING</div><div class="line">SchedulerType=sched/backfill</div><div class="line">SelectType=select/linear</div><div class="line">FastSchedule=1</div><div class="line">#</div><div class="line"># LOGGING</div><div class="line">SlurmctldDebug=3</div><div class="line">SlurmdDebug=3</div><div class="line">JobCompType=jobcomp/none</div><div class="line">#</div><div class="line"># ACCOUNTING</div><div class="line">#</div><div class="line"># COMPUTE NODES</div><div class="line">NodeName=compute Procs=1 State=UNKNOWN</div><div class="line">PartitionName=debug Nodes=compute Default=YES MaxTime=INFINITE State=UP</div></pre></td></tr></table></figure>
<p>这份配置文件在计算节点上同样要使用，所以要复制到计算节点上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo scp /etc/slurm-llnl/slurm.conf vagrant@compute/~</div></pre></td></tr></table></figure>
<p>然后启动控制节点上的slurmctld服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo service slurm-llnl start</div><div class="line">* Starting slurm central management daemon slurmctld</div></pre></td></tr></table></figure>
<p>接着是计算节点的配置，同样需要使用munge，将控制节点生成的<code>munge.key</code>拷贝到计算节点上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo scp /etc/munge/munge.key vagrant@compute:/~</div></pre></td></tr></table></figure>
<p>然后进入计算节点，将<code>munge.key</code>拷贝到munge的目录并启动munge,<strong>注意要修改key的owner和group为munge</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo mv ~/munge.key /etc/munge/</div><div class="line">$ sudo chown munge:munge /etc/munge/munge.key</div></pre></td></tr></table></figure>
<p>然后就可以启动munge服务了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service munge start</div></pre></td></tr></table></figure>
<p>再将之前复制的<code>slurm.conf</code>放到指定位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mv ~/slurm.conf /etc/slurm-llnl/slurm.conf</div></pre></td></tr></table></figure>
<p>接着启动计算节点上的slurmd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service slurm-llnl start</div></pre></td></tr></table></figure>
<p>这样，slurm就配置完毕了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里就简单测试下slurm的功能（在控制节点上运行），首先运行<code>sinfo</code>查看集群状况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sinfo</div><div class="line">PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST</div><div class="line">debug*       up   infinite      1   idle compute</div></pre></td></tr></table></figure>
<p>然后启动一个任务（<code>/bin/hostname</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ srun -N1 /bin/hostname</div><div class="line">compute</div></pre></td></tr></table></figure>
<h2 id="错误与解决方案"><a href="#错误与解决方案" class="headerlink" title="错误与解决方案"></a>错误与解决方案</h2><p><strong>1. 启动munge报错误munged: Error: Logfile is insecure: group-writable permissions set on “/var/log”</strong></p>
<p>在Ubuntu 14.04下启动munge会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo service munge start</div><div class="line"> * Starting MUNGE munged [fail]</div><div class="line">munged: Error: Logfile is insecure: group-writable permissions set on &quot;/var/log&quot;</div></pre></td></tr></table></figure>
<p>原因是因为Ubuntu 14.04将<code>/var/log</code>目录的权限从0755 root:root调整为0755 root:syslog，因此直接启动会报group-writable permissions的错误。</p>
<p>解决方案是启动munge时加上<code>--force</code>或<code>--syslog</code>的参数。</p>
<ul>
<li><code>--force</code>会将errors转为warnings，跳过错误</li>
<li><code>--syslog</code>会跳过<code>/var/log</code>目录的权限检查</li>
</ul>
<p>如果是使用<code>/etc/init.d/munge start</code>或者<code>service munge start</code>的话，可以将Option写到配置文件<code>/etc/default/munge</code>里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OPTIONS=&quot;--force&quot;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础架构" scheme="http://blog.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="资源管理" scheme="http://blog.jetmuffin.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
      <category term="集群" scheme="http://blog.jetmuffin.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
</feed>
