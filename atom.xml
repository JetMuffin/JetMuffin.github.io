<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JetMuffin&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jetmuffin.com/"/>
  <updated>2016-12-03T12:11:11.000Z</updated>
  <id>https://www.jetmuffin.com/</id>
  
  <author>
    <name>JetMuffin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubernetes源码阅读 - queue</title>
    <link href="https://www.jetmuffin.com/2016/12/03/kubernetes%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-queue/"/>
    <id>https://www.jetmuffin.com/2016/12/03/kubernetes源码阅读-queue/</id>
    <published>2016-12-03T08:04:00.000Z</published>
    <updated>2016-12-03T12:11:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中对 k8s 的 scheduler 部分进行了简单的源码阅读和分析，现在接着上次的位置继续往下阅读。</p>
<a id="more"></a>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在 <code>plugin/pkg/scheduler/factory/factory.go</code> 的代码中，scheduler 在创建时引用了一个 <code>getNextPod</code> 方法，获取下一个待调度的 pod。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ConfigFactory)</span> <span class="title">getNextPod</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        pod := cache.Pop(f.PodQueue).(*v1.Pod) <span class="comment">// 获取下一个待调度的 Pod</span></div><div class="line">        <span class="keyword">if</span> f.responsibleForPod(pod) &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v"</span>, pod.Name)</div><div class="line">            <span class="keyword">return</span> pod</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当时没有继续下去，这些 pod 在 k8s 的调度队列里是如何管理的，这也是这篇文章想从源码里学到的。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>和上篇文章一样，由于 k8s 的代码量非常大，那么我们还是一点一点追溯到代码的源头。从 <code>cache.Pop()</code> 方法往上头寻找，IDE 会把你带到 <code>pkg/client/cache/fifo.go</code> 这个文件。从名字很明显看出这是一个先进先出的队列，那么我们就需要看看 k8s 在队列上是如何进行设计的。</p>
<p>首先是 <code>Queue</code> 的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</div><div class="line">    Store <span class="comment">// 实际存储的后端</span></div><div class="line"></div><div class="line">    <span class="comment">// Pop blocks until it has something to process.</span></div><div class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></div><div class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></div><div class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></div><div class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error) <span class="comment">// pop 的抽象方法</span></div><div class="line"></div><div class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></div><div class="line">    <span class="comment">// returned by Pop back into the queue as long</span></div><div class="line">    <span class="comment">// as nothing else (presumably more recent)</span></div><div class="line">    <span class="comment">// has since been added.</span></div><div class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 如同注释所说。。加入队列如果它不在队列中</span></div><div class="line"></div><div class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></div><div class="line">    HasSynced() <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口实际上是对所有类型的队列进行抽象，<code>Pop()</code> 方法是它们共有的方法，FIFO 是一种队列的实现方式，队列还可能有其他的实现方式，诸如 FILO 等。</p>
<h3 id="FIFO-Queue"><a href="#FIFO-Queue" class="headerlink" title="FIFO Queue"></a>FIFO Queue</h3><p>k8s 中默认使用的是 FIFO 队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> FIFO <span class="keyword">struct</span> &#123;</div><div class="line">    lock sync.RWMutex <span class="comment">// 读写锁</span></div><div class="line">    cond sync.Cond <span class="comment">// 读写锁基础上的消息通知对象</span></div><div class="line">    <span class="comment">// We depend on the property that items in the set are in the queue and vice versa.</span></div><div class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 存储对象的内容</span></div><div class="line">    queue []<span class="keyword">string</span> <span class="comment">// 存储对象的 id</span></div><div class="line"></div><div class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></div><div class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></div><div class="line">    populated <span class="keyword">bool</span></div><div class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></div><div class="line">    initialPopulationCount <span class="keyword">int</span></div><div class="line"></div><div class="line">    <span class="comment">// keyFunc is used to make the key used for queued item insertion and retrieval, and</span></div><div class="line">    <span class="comment">// should be deterministic.</span></div><div class="line">    keyFunc KeyFunc <span class="comment">// 用于获取item的key的function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FIFO 队列中有两个重要的数据结构：</p>
<ul>
<li><code>items map[string]interface{}</code> 用于 map 的 键值对形式实际存 items，便于 items 的增删改查</li>
<li><code>queue []string</code> 用于维护每个 items 进入 FIFO 队列的先后顺序，只存 id</li>
</ul>
<p>这里和其他用 chanel 实现的 FIFO 队列稍有不同，用一个 map 和一个 list 就成功的实现了可以增删改查的先进先出队列。</p>
<p>而这个先进先出的 FIFO 队列共有以下操作：</p>
<ul>
<li><code>Add()</code> （添加一个 item）</li>
<li><code>AddIfNotPresent()</code> （如果 item 不在队列中，那么就把它加进队列里）</li>
<li><code>Update()</code> （更新指定 item）</li>
<li><code>Delete()</code> （删除制定 item）</li>
<li><code>List()</code> （列举所有的 item）</li>
<li><code>ListKeys()</code> （列举所有的 key）</li>
<li><code>Get()</code> (按对象获取 item）</li>
<li><code>GetByKey()</code> （按 key 获取 item）</li>
<li><strong><code>Pop()</code></strong></li>
<li><code>Replace()</code> （替换整个队列的内容）</li>
<li><strong><code>Resync()</code></strong></li>
</ul>
<p>前几个方法比较常规，就是一些增删改查的方法。不过需要注意的是，这个 FIFO 在 Delete 时只是删去它在 map 里的对象，不会删去 queue 里的 id，而是在 Pop 时检查一下这个 id 是不是存在于 map 里就行了，相当于是一种 lazy 操作，因为动态维护 queue 队列里的顺序比较麻烦。</p>
<p>当然因为这个 lazy 操作会出现一种情况，就是 queue 里的 id 数和 map 里的 item 数不一致，那么就需要 <code>Resync()</code> 方法来进行同步了。它会直接遍历比较 queue 和 map，把不在 queue 里的 item 全部加到 queue 的末尾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="comment">// Resync will touch all objects to put them into the processing queue</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line"></div><div class="line">    inQueue := sets.NewString()</div><div class="line">    <span class="keyword">for</span> _, id := <span class="keyword">range</span> f.queue &#123;</div><div class="line">        inQueue.Insert(id) <span class="comment">// queue 里现在有的所有id</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> id := <span class="keyword">range</span> f.items &#123; <span class="comment">// 遍历map里的所有key,如果不在queue里就扔到queue末尾曲</span></div><div class="line">        <span class="keyword">if</span> !inQueue.Has(id) &#123; </div><div class="line">            f.queue = <span class="built_in">append</span>(f.queue, id)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f.queue) &gt; <span class="number">0</span> &#123;</div><div class="line">        f.cond.Broadcast()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最重要的是 Pop 方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</div><div class="line">            f.cond.Wait()</div><div class="line">        &#125;</div><div class="line">        id := f.queue[<span class="number">0</span>]</div><div class="line">        f.queue = f.queue[<span class="number">1</span>:] <span class="comment">// 从队列里拿出第一个item的id</span></div><div class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</div><div class="line">            f.initialPopulationCount--</div><div class="line">        &#125;</div><div class="line">        item, ok := f.items[id]</div><div class="line">        <span class="keyword">if</span> !ok &#123;</div><div class="line">            <span class="comment">// Item may have been deleted subsequently.</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果id在map里不存在，那么跳过它</span></div><div class="line">        <span class="built_in">delete</span>(f.items, id) <span class="comment">// 删掉map里对应的item</span></div><div class="line">        err := process(item) <span class="comment">// process方法会阻塞这个Pop方法直到这个item变为ready状态</span></div><div class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</div><div class="line">            f.addIfNotPresent(id, item)</div><div class="line">            err = e.Err</div><div class="line">        &#125;<span class="comment">// 如果出现错误再次放回队列里</span></div><div class="line">        <span class="keyword">return</span> item, err</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pop 方法里会从 queue 中拿出第一个 item 的 id，检查它是不是在 map 里，然后调用 process() 方法判断它是不是 ready 状态，最后返回这个 item。</p>
<p>阅读这里比较疑惑的是，实际 k8s 代码中貌似并没有实现这个 <strong>process</strong> 方法，可以看到在 <code>pkg/client/cache/fifo.go</code> 中有一个 Pop 方法的 helper，对方法进行了封装，而在封装中可以看到，传入的 <code>process()</code> 方法是个匿名函数，只是简单的把传入的 item 赋值给外部的 result 然后返回，并没有 check 这个 item 是否 ready。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(queue Queue)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    <span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</div><div class="line">    queue.Pop(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">        result = obj</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后需要提一下的就是这个 <code>keyFunc</code> 了。从 FIFO 类的定义上看，它是用于获取一个 item 的 key 的方法。而在 FIFO 实例化时，实际上传入的是 <code>MetaNamespaceKeyFunc()</code> 方法，获取 Pod 的 meta 信息里 <code>namespace/name</code> 或者 <code>name</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pkg/client/cache/store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MetaNamespaceKeyFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> key, ok := obj.(ExplicitKey); ok &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">string</span>(key), <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    meta, err := meta.Accessor(obj)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"object has no meta: %v"</span>, err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(meta.GetNamespace()) &gt; <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> meta.GetNamespace() + <span class="string">"/"</span> + meta.GetName(), <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> meta.GetName(), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DeltaFIFO-Queue"><a href="#DeltaFIFO-Queue" class="headerlink" title="DeltaFIFO Queue"></a>DeltaFIFO Queue</h3><p>在 k8s 的 cache 中还提供了一种叫做 <strong>DeltaFIFO</strong> 的队列，相比于 FIFO 队列，它的作用不一样，它是用于储存每个 Pod 的事件（包括 Delete, Update, Add）。这个方法是在 <a href="https://github.com/kubernetes/kubernetes/issues/4877" target="_blank" rel="external">ISSUE#4877</a> 中提出的，因为某些情况下控制器需要知道调度器中队列的操作事件，并且添加 watcher 来针对事件来做出响应，这里也简单的过一下。</p>
<p>首先 delta 的类型定义有 <code>Added</code>，<code>Updated</code>，<code>Deleted</code>，<code>Sync</code> 这四种，分别是在队列进行添加、更新、删除和同步操作时加入的事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/delta_fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Added   DeltaType = <span class="string">"Added"</span></div><div class="line">    Updated DeltaType = <span class="string">"Updated"</span></div><div class="line">    Deleted DeltaType = <span class="string">"Deleted"</span></div><div class="line">    <span class="comment">// The other types are obvious. You'll get Sync deltas when:</span></div><div class="line">    <span class="comment">//  * A watch expires/errors out and a new list/watch cycle is started.</span></div><div class="line">    <span class="comment">//  * You've turned on periodic syncs.</span></div><div class="line">    <span class="comment">// (Anything that trigger's DeltaFIFO's Replace() method.)</span></div><div class="line">    Sync DeltaType = <span class="string">"Sync"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>Delta 对象存储了<strong>修改的类型（Type）</strong>和<strong>修改在哪个对象上（Object)</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/delta_fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</div><div class="line">    Type   DeltaType</div><div class="line">    Object <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样这个队列和 FIFO 类似，也是用 map 存 Deltas，用 queue 存 id。稍微不同的地方上，对这个队列的 <code>Add()</code>，<code>Update()</code>， <code>Delete()</code> 操作是把相应的 Delta <strong>添加</strong> 到队列里去，也就是说这个队列始终是在往里添加东西（Delta)，而外部的 Watcher 则在不断的从这个 DeltaFIFO 中取 Delta 来处理。也就是我们常说的 <strong>Producer/Consumer</strong> 的模型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>和之前看的 Mesos 中的 DRF 算法不同，k8s 中使用 FIFO 队列来维护每个 Pod 进入调度器的顺序。当然 Mesos 用 DRF 也是考虑在两层调度框架上进行公平调度，而 k8s 只关心进来的 Pod 的先后顺序。</p>
<p>再和上篇文章说到的内容结合，k8s 的调度实际上是基于<strong>先后顺序（FIFO），节点过滤（predicates）和节点打分（prioritizers）</strong>来做到从 Pod 到 Node 的调度过程。</p>
<p>最后，调度器中 FIFO 当然也是最简单和最常使用的队列模式，或许之后可以为 k8s 增加更多模式的调度器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中对 k8s 的 scheduler 部分进行了简单的源码阅读和分析，现在接着上次的位置继续往下阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="kubernetes" scheme="https://www.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="queue" scheme="https://www.jetmuffin.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes源码阅读 - scheduler</title>
    <link href="https://www.jetmuffin.com/2016/11/24/Kubernetes%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Scheduler/"/>
    <id>https://www.jetmuffin.com/2016/11/24/Kubernetes源码阅读-Scheduler/</id>
    <published>2016-11-24T11:50:52.000Z</published>
    <updated>2016-12-03T12:10:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。</p>
<a id="more"></a>
<h2 id="Scheduler-入口"><a href="#Scheduler-入口" class="headerlink" title="Scheduler 入口"></a>Scheduler 入口</h2><p>首先定位到 <code>plugin/cmd/scheduler.go</code> 这个文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/cmd/scheduler.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := options.NewSchedulerServer()</div><div class="line">    s.AddFlags(pflag.CommandLine) <span class="comment">// 解析参数</span></div><div class="line"></div><div class="line">    flag.InitFlags()</div><div class="line">    logs.InitLogs()</div><div class="line">    <span class="keyword">defer</span> logs.FlushLogs()</div><div class="line"></div><div class="line">    verflag.PrintAndExitIfRequested()</div><div class="line"></div><div class="line">    app.Run(s) <span class="comment">// 启动调度器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面这段代码可以看出这是从 command 启动 scheduler 的入口，它解析了 scheduler 的参数，同时调用了 <code>app.Run(s)</code>来启动 scheduler。</p>
<p>按着这个走向找到 <code>app.Run(s)</code> 的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/cmd/kube-scheduler/app/server.go</span></div><div class="line"></div><div class="line"><span class="comment">// Run runs the specified SchedulerServer.  This should never exit.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(s *options.SchedulerServer)</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line"></div><div class="line">    sched := scheduler.New(config) <span class="comment">// 新建调度器</span></div><div class="line"></div><div class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(_ &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">        sched.Run() <span class="comment">// 正式启动调度器入口</span></div><div class="line">        <span class="keyword">select</span> &#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在这段代码片段中，通过 <code>sched := scheduler.New(config)</code> 新建了一个 scheduler 对象，并且调用它的 <code>Run()</code> 成员方法，同时需要特意留意 <code>config</code>。继续追踪到 scheduler 类的定义中取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="comment">// Run begins watching and scheduling. It starts a goroutine and returns immediately.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">go</span> wait.Until(s.scheduleOne, <span class="number">0</span>, s.config.StopEverything)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Scheduler.Run()</code> 方法中，Scheduler 通过 <code>wait.Until()</code> 工具，不停得调用 <code>Scheduler.scheduleOne()</code> 方法直到收到停止信号。我们接着看 <code>scheduleOne()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">()</span></span> &#123;</div><div class="line">    pod := s.config.NextPod() <span class="comment">// 获取下一个待调度的pod</span></div><div class="line"></div><div class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">    start := time.Now()</div><div class="line">    dest, err := s.config.Algorithm.Schedule(pod, s.config.NodeLister) <span class="comment">// 调用算法进行调度</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        glog.V(<span class="number">1</span>).Infof(<span class="string">"Failed to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">        s.config.Error(pod, err)</div><div class="line">        s.config.Recorder.Eventf(pod, api.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"%v"</span>, err)</div><div class="line">        s.config.PodConditionUpdater.Update(pod, &amp;api.PodCondition&#123;</div><div class="line">            Type:   api.PodScheduled,</div><div class="line">            Status: api.ConditionFalse,</div><div class="line">            Reason: api.PodReasonUnschedulable,</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scheduler 首先通过 <code>config.NextPod()</code> 来获取到当前要进行调度的一个 pod，然后调用 <code>config.Algorithm.Schedule()</code> 方法来对这个 pod 实际进行调度。从这种写法上我们可以猜测到 Algorithm 这儿用的是工厂模式。若根据该算法调度成功，那么将这个时间进行记录。否则调用 <code>config.Error()</code> 来进行错误处理。</p>
<p>这里有三个比较重点的内容：</p>
<ul>
<li>config.NextPod()</li>
<li>config.Algorithm.schedule()</li>
<li>config.Error()</li>
</ul>
<p>它们均来自 <code>Config</code> 类，那么我们先看这个类，再接下去探索这两个方法。<code>Config</code> 类的定义也在这个文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// It is expected that changes made via SchedulerCache will be observed</span></div><div class="line">    <span class="comment">// by NodeLister and Algorithm.</span></div><div class="line">    SchedulerCache schedulercache.Cache</div><div class="line">    NodeLister     algorithm.NodeLister</div><div class="line">    Algorithm      algorithm.ScheduleAlgorithm <span class="comment">// 调度算法</span></div><div class="line">    Binder         Binder</div><div class="line">    <span class="comment">// PodConditionUpdater is used only in case of scheduling errors. If we succeed</span></div><div class="line">    <span class="comment">// with scheduling, PodScheduled condition will be updated in apiserver in /bind</span></div><div class="line">    <span class="comment">// handler so that binding and setting PodCondition it is atomic.</span></div><div class="line">    PodConditionUpdater PodConditionUpdater</div><div class="line"></div><div class="line">    <span class="comment">// NextPod should be a function that blocks until the next pod</span></div><div class="line">    <span class="comment">// is available. We don't use a channel for this, because scheduling</span></div><div class="line">    <span class="comment">// a pod may take some amount of time and we don't want pods to get</span></div><div class="line">    <span class="comment">// stale while they sit in a channel.</span></div><div class="line">    NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span> // 获取下一个<span class="title">pod</span>的抽象方法</span></div><div class="line"></div><div class="line">    // <span class="title">Error</span> <span class="title">is</span> <span class="title">called</span> <span class="title">if</span> <span class="title">there</span> <span class="title">is</span> <span class="title">an</span> <span class="title">error</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">passed</span> <span class="title">the</span> <span class="title">pod</span> <span class="title">in</span></div><div class="line">    // <span class="title">question</span>, <span class="title">and</span> <span class="title">the</span> <span class="title">error</span></div><div class="line">    <span class="title">Error</span> <span class="title">func</span><span class="params">(*api.Pod, error)</span> // 处理调度出现的错误</div><div class="line"></div><div class="line">    // <span class="title">Recorder</span> <span class="title">is</span> <span class="title">the</span> <span class="title">EventRecorder</span> <span class="title">to</span> <span class="title">use</span></div><div class="line">    <span class="title">Recorder</span> <span class="title">record</span>.<span class="title">EventRecorder</span></div><div class="line"></div><div class="line">    // <span class="title">Close</span> <span class="title">this</span> <span class="title">to</span> <span class="title">shut</span> <span class="title">down</span> <span class="title">the</span> <span class="title">scheduler</span>.</div><div class="line">    <span class="title">StopEverything</span> <span class="title">chan</span> <span class="title">struct</span>&#123;&#125; <span class="comment">// 停止信号</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Config</code> 类传入了 scheduler 必要的各种参数，相当于原来隶属于 scheduler 的成员变量通过它传入。<code>Config</code> 类在 <code>plugin/pkg/scheduler/factory</code> 中被实例化，相应的抽象方法也被传入实际的引用方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> &amp;scheduler.Config&#123;</div><div class="line">      SchedulerCache: f.schedulerCache,</div><div class="line">      <span class="comment">// The scheduler only needs to consider schedulable nodes.</span></div><div class="line">      NodeLister:          f.NodeLister.NodeCondition(getNodeConditionPredicate()),</div><div class="line">      Algorithm:           algo,</div><div class="line">      Binder:              &amp;binder&#123;f.Client&#125;,</div><div class="line">      PodConditionUpdater: &amp;podConditionUpdater&#123;f.Client&#125;,</div><div class="line">      NextPod: <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">          <span class="keyword">return</span> f.getNextPod()</div><div class="line">      &#125;,</div><div class="line">      Error:          f.makeDefaultErrorFunc(&amp;podBackoff, f.PodQueue),</div><div class="line">      StopEverything: f.StopEverything,</div><div class="line">  &#125;, <span class="literal">nil</span></div></pre></td></tr></table></figure>
<h2 id="获取待调度的-Pod"><a href="#获取待调度的-Pod" class="headerlink" title="获取待调度的 Pod"></a>获取待调度的 Pod</h2><p>首先看 <code>NextPod</code> 参数，从类 <code>Config</code> 的定义中的注释可以看到，这个参数是一个获取下一个 pod，并且阻塞该方法直到下一个 pod 可用为止。并且它的实现没有用 chanel，原因是一旦放到 chanel 里，这个 pod 便无法修改。这个 参数是在实例化时传入的获取下一个 pod 的方法。传入的代码也在这个文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ConfigFactory)</span> <span class="title">getNextPod</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        pod := cache.Pop(f.PodQueue).(*api.Pod)</div><div class="line">        <span class="keyword">if</span> f.responsibleForPod(pod) &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v"</span>, pod.Name)</div><div class="line">            <span class="keyword">return</span> pod</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这段代码可以看出，获取下一个待调度的 pod 似乎是从一个队列中 pop 出一个 pod 来实现的。使用的来源是 <code>pkg/client/cache</code>，继续追踪：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(queue Queue)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    <span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</div><div class="line">    queue.Pop(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">        result = obj</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是个代理方法，是对 <code>Queue</code> 类中的 <code>Pop()</code> 方法进行了一层封装，于是自然看到对应的 <code>Queue.Pop()</code>，它是在类 <code>FIFO</code> 中的，那么这块儿也逐渐明了了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="comment">// Pop waits until an item is ready and processes it. If multiple items are</span></div><div class="line"><span class="comment">// ready, they are returned in the order in which they were added/updated.</span></div><div class="line"><span class="comment">// The item is removed from the queue (and the store) before it is processed,</span></div><div class="line"><span class="comment">// so if you don't successfully process it, it should be added back with</span></div><div class="line"><span class="comment">// AddIfNotPresent(). process function is called under lock, so it is safe</span></div><div class="line"><span class="comment">// update data structures in it that need to be in sync with the queue.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</div><div class="line">            f.cond.Wait()</div><div class="line">        &#125;</div><div class="line">        id := f.queue[<span class="number">0</span>]</div><div class="line">        f.queue = f.queue[<span class="number">1</span>:]</div><div class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</div><div class="line">            f.initialPopulationCount--</div><div class="line">        &#125;</div><div class="line">        item, ok := f.items[id]</div><div class="line">        <span class="keyword">if</span> !ok &#123;</div><div class="line">            <span class="comment">// Item may have been deleted subsequently.</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">delete</span>(f.items, id)</div><div class="line">        err := process(item)</div><div class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</div><div class="line">            f.addIfNotPresent(id, item)</div><div class="line">            err = e.Err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> item, err</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法算是这条路径的最后一个追踪的节点了。总结一下这条路径：</p>
<ol>
<li>kubernetes 的 cache 中维护了一个先进先出的队列 <code>FIFO</code>，它不同于 golang 中的 chanel，它支持对队列中的元素进行更新、删除等操作。</li>
<li>这个队列的 <code>FIFO.Pop()</code> 方法会队首元素（一个 pod）到达 ready 状态，然后将它弹出，否则阻塞该方法。</li>
<li><code>Scheduler</code> 类初始化时使用参数 <code>Config</code>，<code>Config</code> 中的 <code>NextPod()</code> 默认使用 <code>FIFO.Pop()</code>，当 <code>Scheduler</code> 需要进行调度时使用该方法得到下一个待调度的 pod。</li>
</ol>
<h2 id="使用调度算法进行实时调度"><a href="#使用调度算法进行实时调度" class="headerlink" title="使用调度算法进行实时调度"></a>使用调度算法进行实时调度</h2><p>回到 <code>Config</code> 类的第二个重要参数 <code>Algorithm</code>,它是对 pod 进行调度的实体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line">algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)</div></pre></td></tr></table></figure>
<p>可以看到默认情况下，<code>Algorithm</code> 是用的通用调度器，接着看这个 <code>GenericScheduler</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/generic_scheduler.go</span></div><div class="line"></div><div class="line"><span class="comment">// Schedule tries to schedule the given pod to one of node in the node list.</span></div><div class="line"><span class="comment">// If it succeeds, it will return the name of the node.</span></div><div class="line"><span class="comment">// If it fails, it will return a Fiterror error with reasons.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *api.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> trace *util.Trace</div><div class="line">    <span class="keyword">if</span> pod != <span class="literal">nil</span> &#123;</div><div class="line">        trace = util.NewTrace(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        trace = util.NewTrace(<span class="string">"Scheduling &lt;nil&gt; pod"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</div><div class="line"></div><div class="line">    nodes, err := nodeLister.List() <span class="comment">// 获取所有节点</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, ErrNoNodesAvailable</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Used for all fit and priority funcs.</span></div><div class="line">    err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// TODO(harryz) Check if equivalenceCache is enabled and call scheduleWithEquivalenceClass here</span></div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Computing predicates"</span>)</div><div class="line">    filteredNodes, failedPredicateMap, err := findNodesThatFit(pod, g.cachedNodeInfoMap, nodes, g.predicates, g.extenders, g.predicateMetaProducer)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, &amp;FitError&#123;</div><div class="line">            Pod:              pod,</div><div class="line">            FailedPredicates: failedPredicateMap,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Prioritizing"</span>)</div><div class="line">    metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap)</div><div class="line">    priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Selecting host"</span>)</div><div class="line">    <span class="keyword">return</span> g.selectHost(priorityList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，GenericScheduler 进行调度为以下过程：</p>
<ol>
<li>从 <code>NodeList</code> 获取所有的节点</li>
<li>通过所给的断言函数（<code>predicates</code>）对所有节点进行过滤，选出符合的节点（<code>findNodesThatFit()</code>）</li>
<li>根据所给的打分函数（<code>prioritizers</code>）对过滤后的节点进行排序（<code>PrioritizeNodes()</code>）</li>
<li>通过 round-robin 方式依次获取分数最高的节点来运行 pod。</li>
</ol>
<h2 id="调度失败"><a href="#调度失败" class="headerlink" title="调度失败"></a>调度失败</h2><p>在 <code>Config</code> 类的 <code>Error</code> 参数中传入了调度失败的处理方法 <code>makeDefaultErrorFunc()</code> 对调度失败的 pod 进行重调度处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(factory *ConfigFactory)</span> <span class="title">makeDefaultErrorFunc</span><span class="params">(backoff *podBackoff, podQueue *cache.FIFO)</span> <span class="title">func</span><span class="params">(pod *api.Pod, err error)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(pod *api.Pod, err error)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> err == scheduler.ErrNoNodesAvailable &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"Unable to schedule %v %v: no nodes are registered to the cluster; waiting"</span>, pod.Namespace, pod.Name)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            glog.Errorf(<span class="string">"Error scheduling %v %v: %v; retrying"</span>, pod.Namespace, pod.Name, err)</div><div class="line">        &#125;</div><div class="line">        backoff.gc() <span class="comment">// 清空backoff列表</span></div><div class="line">        <span class="comment">// Retry asynchronously.</span></div><div class="line">        <span class="comment">// Note that this is extremely rudimentary and we need a more real error handling path.</span></div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">            <span class="keyword">defer</span> runtime.HandleCrash()</div><div class="line">            podID := types.NamespacedName&#123;</div><div class="line">                Namespace: pod.Namespace,</div><div class="line">                Name:      pod.Name,</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            entry := backoff.getEntry(podID)</div><div class="line">            <span class="keyword">if</span> !entry.TryWait(backoff.maxDuration) &#123;</div><div class="line">                glog.Warningf(<span class="string">"Request for pod %v already in flight, abandoning"</span>, podID)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Get the pod again; it may have changed/been scheduled already.</span></div><div class="line">            getBackoff := initialGetBackoff</div><div class="line">            <span class="keyword">for</span> &#123;</div><div class="line">                pod, err := factory.Client.Core().Pods(podID.Namespace).Get(podID.Name)</div><div class="line">                <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> &#123;</div><div class="line">                        podQueue.AddIfNotPresent(pod) <span class="comment">// 重新将pod加入调度队列</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">                    glog.Warningf(<span class="string">"A pod %v no longer exists"</span>, podID)</div><div class="line">                    <span class="keyword">return</span></div><div class="line">                &#125;</div><div class="line">                glog.Errorf(<span class="string">"Error getting pod %v for retry: %v; retrying..."</span>, podID, err)</div><div class="line">                <span class="keyword">if</span> getBackoff = getBackoff * <span class="number">2</span>; getBackoff &gt; maximalGetBackoff &#123;</div><div class="line">                    getBackoff = maximalGetBackoff</div><div class="line">                &#125;</div><div class="line">                time.Sleep(getBackoff)</div><div class="line">            &#125;</div><div class="line">        &#125;()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从该处理方法看出，一旦出现调度失败，k8s 并不会阻塞调度过程，而是将调度失败的 pod 扔到这个失败处理方法里，而这个方法是通过异步的方式进行重试。k8s 从 backoff 这个列表中拿出指定的 pod，然后将它再次放到 <code>FIFO</code> 队列里，期间如果继续失败，再扔进 backoff 里异步等待处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>k8s 的代码量非常庞大，需要快速定位源码比较困难，而采用这种根据从入口不断深入的阅读方式会减少很多工作量，只关心一部分的代码。当然这也无法从一个宏观的角度去看整个代码的设计，但是对于当前的工作已经足够。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="kubernetes" scheme="https://www.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="scheduler" scheme="https://www.jetmuffin.com/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>How to fix &#39;/bin/rm: Argument list too long</title>
    <link href="https://www.jetmuffin.com/2016/11/13/How-to-fix-bin-rm-Argument-list-too-long/"/>
    <id>https://www.jetmuffin.com/2016/11/13/How-to-fix-bin-rm-Argument-list-too-long/</id>
    <published>2016-11-13T08:09:57.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>做运维时发现系统的磁盘满了，检查发现磁盘的 <code>/tmp</code> 目录下装满了东西，于是很简单的想用 <code>rm -rf /tmp/*</code> 来删除，结果发现报错：<code>bash: /bin/rm: Argument list too long</code>。找了找方法解决它。<br><a id="more"></a></p>
<p>当执行命令时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/rm -rf ./*</div></pre></td></tr></table></figure>
<p>得到了错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash: /bin/rm: Argument list too long</div></pre></td></tr></table></figure>
<p>查看发现，<code>rm</code> 命令也有参数长度的限制，所以需要用管道将命令分批次输入到 <code>rm</code> 中去。</p>
<p>因此 <code>xargs</code> 就派上用场了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;_MEI*&quot; | xargs /bin/rm -rf</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;_MEI*&quot; -print0 | xargs /bin/rm -rf</div></pre></td></tr></table></figure>
<p>或者更直接的用 <code>find</code> 的 <code>-delete</code> 参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &quot;_MEI*&quot; -delete</div></pre></td></tr></table></figure>
<p>即可解决。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做运维时发现系统的磁盘满了，检查发现磁盘的 &lt;code&gt;/tmp&lt;/code&gt; 目录下装满了东西，于是很简单的想用 &lt;code&gt;rm -rf /tmp/*&lt;/code&gt; 来删除，结果发现报错：&lt;code&gt;bash: /bin/rm: Argument list too long&lt;/code&gt;。找了找方法解决它。&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://www.jetmuffin.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://www.jetmuffin.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Difference between Mesos and Kubernetes</title>
    <link href="https://www.jetmuffin.com/2016/10/24/Difference-between-Mesos-and-Kubernetes/"/>
    <id>https://www.jetmuffin.com/2016/10/24/Difference-between-Mesos-and-Kubernetes/</id>
    <published>2016-10-24T03:09:27.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>自 Docker 大火之后，Swarm，Mesos，Kubernetes 这类围绕 Docker 容器展开的集群开源管理项目也逐渐风起云涌。本文主要从多个方面整理当前主流的两个容器编排框架 Mesos 和 Kubernetes 的区别。</p>
<a id="more"></a>  
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache Mesos 始于加州大学伯克利分校的一个项目，用来驱动 Twitter 的底层基础架构，并且在之后成为许多大公司，如 eBay 和 Airbnb 的重要工具。之后 Mesos 的作者之一 Ben Hindman 创立了商业化公司 Mesosphere，并为 Mesos 社区贡献了许多持续性的开发和支持工具。</p>
<p>而 Kubernetes 则是出自 Google 公司，基于他们在 Borg 上的经验总结，推出的极具“谷歌风格”的开源集群容器管理平台。Kubernetes 和 Borg 的开发和维护是由 Google 的同一个团队进行的。</p>
<h2 id="社区人气"><a href="#社区人气" class="headerlink" title="社区人气"></a>社区人气</h2><p>在资源和容器管理方面，大公司（诸如微软、BAT 等）会自己造内部的轮子进行使用，而规模较小的公司则采用开源项目或基于开源项目进行二次开发。而在社区上，大家对 Docker 容器编排技术的选择更趋向于哪些方面？</p>
<p><img src="/uploads/images/2016/10/24/1.png" alt="rihe.png"></p>
<p>Caicloud 在 2016 年 2 月统计了包括 Kubernetes, Swarm, Compose, Mesos, Docker Machine, Hyper, Containerd 在内的7个项目在 Github 上的 fork 数和被 star 数等。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>在 fork 上的数据，Kubernetes 以 3699 次遥遥领先于其他所有的编排框架，而 Mesos 仅有 738 次 fork。而在笔者写这篇文章时（2016 年 10 月 24 日），Kubernetes 的 fork 数已经超过了 5800 次，而 Mesos 大概在 1050 次 fork。</p>
<p><img src="/uploads/images/2016/10/24/2.png" alt="fork.png"></p>
<h3 id="star"><a href="#star" class="headerlink" title="star"></a>star</h3><p>star 的数据上 Kubernetes 依然以 12888 颗星数雄踞榜首，而 Mesos 仅有 2056 次 star。而直到今天，Kubernetes 已经拿到了近 17800 颗 star，而 Mesos 的 star 数量仅在 2600 次。</p>
<p><img src="/uploads/images/2016/10/24/3.png" alt="star.png"></p>
<p>从 fork 和 star 数量可以看出两个框架在社区中的受欢迎程度，Kubernetes 远大于 Mesos。当然，由于 Kubernetes 出自名门，其中自然也带有一些来自于对 Google 公司的影响，而 Mesos 则更显得稍微小众一些。当然，社区的支持度越大，对开源框架的贡献者则越多，那么这个框架的发展则越迅速。</p>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>虽然同样被视为容器编排框架，但是 Kubernetes 和 Mesos 的设计理念完全不同。</p>
<p>## </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自 Docker 大火之后，Swarm，Mesos，Kubernetes 这类围绕 Docker 容器展开的集群开源管理项目也逐渐风起云涌。本文主要从多个方面整理当前主流的两个容器编排框架 Mesos 和 Kubernetes 的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="kubernetes" scheme="https://www.jetmuffin.com/tags/kubernetes/"/>
    
      <category term="docker" scheme="https://www.jetmuffin.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Debian下编译shadowsocks-qt5</title>
    <link href="https://www.jetmuffin.com/2016/10/18/Debian%E4%B8%8B%E7%BC%96%E8%AF%91shadowsocks-qt5/"/>
    <id>https://www.jetmuffin.com/2016/10/18/Debian下编译shadowsocks-qt5/</id>
    <published>2016-10-18T05:53:08.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时开发用的是 debian 的 linux 发行版，而 shadowsocks-qt5 没有提供 debian 的 release 版本，于是得自己动手编译，编译的时候会遇到许多坑，这里记录一下。</p>
<a id="more"></a>
<h3 id="libQtshadowsocks"><a href="#libQtshadowsocks" class="headerlink" title="libQtshadowsocks"></a>libQtshadowsocks</h3><p>首先需要编译 shadowsocks 的 lib 库 <code>libQtShadowsocks</code>，从 <a href="https://github.com/shadowsocks/libQtShadowsocks/releases" target="_blank" rel="external">github/libQtshadowsocks</a> 上找到稳定版本，直接下载源码的 .tar.gz 文件到本地，解压，并进入文件夹。</p>
<p>wiki 上对编译的依赖描述如下：</p>
<blockquote>
<p>Qt &gt;= 5.2 (qt5-qtbase-devel and qt5-qttools in Fedora, qtbase5-dev and qt5-qmake in Debian/Ubuntu)<br>Botan &gt;= 1.10 (botan-devel in Fedora, libbotan1.10-dev in Debian/Ubuntu)<br>A C++ Compiler that supports C++11 features (i.e. GCC &gt;= 4.7) </p>
</blockquote>
<p>但是只安装这些依赖，在 debian 下会出现 <code>botan-1.10 development package not found</code> 的错误，但是检查后发现 <code>libbotan1.10-dev</code> 包已经安装了。</p>
<p>后来发现是有其他的依赖没满足，所以干脆一次性把所有依赖全部装了，就不会出现问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libappindicator-dev libzbar-dev libbotan1.10-dev</div></pre></td></tr></table></figure>
<p>然后进入进行编译，编译时可以选择 <code>INSTALL_PREFIX</code>，它默认是 <code>/usr</code> 目录，如果自行更改会有另外的问题，下面会提到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qmake</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h3 id="shadowsocks-qt5"><a href="#shadowsocks-qt5" class="headerlink" title="shadowsocks-qt5"></a>shadowsocks-qt5</h3><p>编译安装完 <code>libQtShadowsocks</code> 后就可以编译 <code>shadowsocks-qt5</code> 了。从 <a href="https://github.com/shadowsocks/shadowsocks-qt5" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks-qt5</a> 上 clone ss-qt5 的源码，然后进入目录编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/shadowsocks/shadowsocks-qt5.git</div><div class="line">cd shadowsocks-qt5</div><div class="line">qmake</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>同样这里的 <code>qmake</code> 可以指定 <code>INSTALL_PREFIX</code>, 默认为 <code>/usr</code>。安装后 ss-qt5 会在 <code>/usr/bin</code> 文件夹中，命令行直接运行 <code>ss-qt5</code> 或者在图形界面中直接搜索就可以运行了。</p>
<h3 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h3><p>如果在运行时仍然碰到 <code>libQtShadowsocks.so.1 not found</code> 这个问题，那么原因就可能是上面所提到的编译 <code>libQtShadowsocks</code> 的问题了。默认指定的 <code>INSTALL_PREFIX</code> 为 <code>/usr</code>，即安装到 <code>/usr/lib</code> 中，而这个路径是自动被加到系统的链接库里的。</p>
<p>而如果自行指定了 <code>INSTALL_PREFIX</code>，例如我选择了 <code>/usr/local</code>，那么这个 so 文件会被安装到 <code>/usr/local/lib</code>，而这个目录不是默认被加到系统链接库里的，那么需要手动加进去，解决方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo &quot;/usr/local/lib&quot; &gt;&gt; &quot;/etc/ld.so.conf&quot;</div><div class="line">/sbin/ldconfig</div></pre></td></tr></table></figure>
<p>然后再运行 ss-qt5 就没有问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时开发用的是 debian 的 linux 发行版，而 shadowsocks-qt5 没有提供 debian 的 release 版本，于是得自己动手编译，编译的时候会遇到许多坑，这里记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="设计开发" scheme="https://www.jetmuffin.com/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="shadowsocks" scheme="https://www.jetmuffin.com/tags/shadowsocks/"/>
    
      <category term="debian" scheme="https://www.jetmuffin.com/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>使用 gh-md-doc 生成 markdown 文章结构</title>
    <link href="https://www.jetmuffin.com/2016/09/13/%E4%BD%BF%E7%94%A8-gh-md-doc-%E7%94%9F%E6%88%90-markdown-%E6%96%87%E7%AB%A0%E7%BB%93%E6%9E%84/"/>
    <id>https://www.jetmuffin.com/2016/09/13/使用-gh-md-doc-生成-markdown-文章结构/</id>
    <published>2016-09-13T12:23:11.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇技巧来自于我在 <a href="http://www.iqiyi.com" target="_blank" rel="external">iQiyi</a> 的云平台部门实习时的内部分享，主要用于文档编写。<br>在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 <a href="https://github.com/ekalinin/github-markdown-toc" target="_blank" rel="external">gh-md-toc</a>。</p>
<a id="more"></a>
<h2 id="生成-markdown-table-of-contents"><a href="#生成-markdown-table-of-contents" class="headerlink" title="生成 markdown table of contents"></a>生成 markdown table of contents</h2><hr>
<p>常常项目开发的文档都是用 markdown 格式编写，并且以代码的形式托管在 Git 上，<br>同时，那么就可以使用 <a href="https://github.com/ekalinin/github-markdown-toc" target="_blank" rel="external">gh-md-toc</a><br>来生成文档目录。</p>
<p>但是，gh-md-toc 会直接将结果打印到 stout，而我们想要的最好的效果是直接将其添加到文档头部，<br>而不是从 stdout 再复制粘贴，然后还要格式化空行。</p>
<p>以本文档为例，gh-md-toc 生成的 table of contents 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Table of Contents</div><div class="line">=================</div><div class="line"></div><div class="line">    * [生成 markdown table of contents](#生成-markdown-table-of-contents)</div><div class="line">    * [使用 gh-md-toc 的奇技淫巧](#使用-gh-md-toc-的奇技淫巧)</div><div class="line"></div><div class="line">Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)</div></pre></td></tr></table></figure>
<p>显然，我们需要将这段文字添加到文件的头部，并且<strong>删除第一行空行，在最后一行添加一行空行</strong>。</p>
<h2 id="使用-gh-md-toc-的奇技淫巧"><a href="#使用-gh-md-toc-的奇技淫巧" class="headerlink" title="使用 gh-md-toc 的奇技淫巧"></a>使用 gh-md-toc 的奇技淫巧</h2><p>OK，Let’s Rock!</p>
<p>先看一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gh-md-toc file.md | (tail -n +2 &amp;&amp; echo &quot;&quot; &amp;&amp; cat file.md) | sponge file.md</div></pre></td></tr></table></figure>
<p>你会惊讶的发现，这条命令就完成了所有事，为 file.md 生成了 table of<br>contents，并且自动添加在了 file.md 的头部，并且完美的处理了空行。</p>
<p>这里使用了一个好工具 <code>sponge</code>，想想为什么不能直接重定向到 file.md 呢？</p>
<p>但是，追求极致的程序员不会止步，因为上面的命令中 file.md 这个待处理的文件出现了<br>3 次，所以也挺烦人的，对吧，即使使用命令替换也来得不如一次直接。</p>
<p>OK，Let’s Rock Again!</p>
<p>添加一个函数，重定义 gh-md-toc，添加下面的函数定义到你的 shell rc，例如：</p>
<ul>
<li>bash，~/.bashrc</li>
<li>zsh，~/.zshrc</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> gh-md-<span class="function"><span class="title">toc</span></span>() &#123;</div><div class="line">  <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">"gh-md-toc &lt;markdown file&gt;"</span></div><div class="line">      <span class="built_in">return</span> 1</div><div class="line">  <span class="keyword">fi</span></div><div class="line">  /home/chengwei/Github/github-markdown-toc/gh-md-toc <span class="variable">$1</span> | (tail -n +2 &amp;&amp; <span class="built_in">echo</span> <span class="string">""</span> &amp;&amp; cat <span class="variable">$1</span>) | sponge <span class="variable">$1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将上面的 <code>/home/chengwei/Github/github-markdown-toc/gh-md-toc</code> 替换成 gh-md-doc<br>在你的系统上的路径。</p>
<p><strong>注意：如果你把 gh-md-doc 放在了 $PATH 中，必须用绝对路径调用，否则就无限递归了 :-)</strong></p>
<p>最后，source shell rc 配置文件，生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">source</span> ~/.bashrc</div><div class="line">OR</div><div class="line">$ <span class="built_in">source</span> ~/.zshrc</div></pre></td></tr></table></figure>
<p>现在，要为某个 markdown 文件添加 table of contents 只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gh-md-toc file.md</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇技巧来自于我在 &lt;a href=&quot;http://www.iqiyi.com&quot;&gt;iQiyi&lt;/a&gt; 的云平台部门实习时的内部分享，主要用于文档编写。&lt;br&gt;在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 &lt;a href=&quot;https://github.com/ekalinin/github-markdown-toc&quot;&gt;gh-md-toc&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="设计开发" scheme="https://www.jetmuffin.com/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="markdown" scheme="https://www.jetmuffin.com/tags/markdown/"/>
    
      <category term="gh-md-doc" scheme="https://www.jetmuffin.com/tags/gh-md-doc/"/>
    
  </entry>
  
  <entry>
    <title>Moore vote algorithm 多数投票算法</title>
    <link href="https://www.jetmuffin.com/2016/09/04/Moore-vote-algorithm-%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"/>
    <id>https://www.jetmuffin.com/2016/09/04/Moore-vote-algorithm-多数投票算法/</id>
    <published>2016-09-04T12:24:16.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在刷 leetcode 时，发现一道题目 <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="external">Majority Element</a>，要求求出数组中出现元素超过 <code>n/2</code> 的元素。思考了许久也只能写出 <code>O(nlogn)</code> 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 <code>O(n)</code> 时间和 <code>O(1)</code> 空间解决这个问题。</p>
<a id="more"></a>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>算法的思想很简单，每次从数组中取一对数，如果相同就叠加，如果不同就一起删去，很明显最后留下的肯定是数量最多的一个数。再深入一步实现，只要用一个变量记录<strong>标记元素</strong>和<strong>标记元素的出现次数</strong>，然后找下一个元素，分以下情况：</p>
<ul>
<li>如果下一个元素和标记元素相同，那么标记元素出现次数加1；</li>
<li>如果和标记元素不同，那么标记元素出现次数减1；</li>
<li>如果标记元素变为 0，那么取下一个元素作为标记元素，初始出现次数为1；</li>
</ul>
<p>举个说明性的例子，数列 <code>[2,3,2,2,4,1,2]</code>，标记元素变量 <code>now</code>，出现次数 <code>count</code></p>
<ol>
<li>初始状态（取第一个数）：<code>now:2</code>，<code>count:1</code></li>
<li>取第二个数 <code>3</code>，它和 <code>now</code> 不同，那么 <code>count--</code>，这时候 <code>count = 0</code>，那么拿下一个元素（第三个数）为标记元素 <code>now:2</code>，<code>count:1</code></li>
<li>取第四个数 <code>2</code>，它和 <code>now</code> 相同，那么 <code>count++</code>，状态变为 <code>now:2</code>，<code>count:2</code></li>
<li>取第五个数 <code>4</code>，它和 <code>now</code> 不同，那么 <code>count--</code>，状态变为 <code>now:2</code>，<code>count:1</code></li>
<li>重复以上过程直到结尾，最后 <code>now:2</code>，所以数量超过 <code>n/2</code> 的元素为 2</li>
</ol>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>为了更好实现上述过程，事实上程序的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">For i from 0 to len(arr):</div><div class="line">    if count == 0:</div><div class="line">        now = arr[i]</div><div class="line">        count = 1</div><div class="line">    else:</div><div class="line">        if now == arr[i]:</div><div class="line">            count ++</div><div class="line">        else:</div><div class="line">            count --</div></pre></td></tr></table></figure>
<p>即只要标记元素被删去了，那么访问的下一个元素就作为标记元素。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, now = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</div><div class="line">                now = nums[i];</div><div class="line">                count = <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span>(now == nums[i]) &#123;</div><div class="line">                    count ++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    count --;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> now;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/" target="_blank" rel="external">算法效果演示</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在刷 leetcode 时，发现一道题目 &lt;a href=&quot;https://leetcode.com/problems/majority-element/&quot;&gt;Majority Element&lt;/a&gt;，要求求出数组中出现元素超过 &lt;code&gt;n/2&lt;/code&gt; 的元素。思考了许久也只能写出 &lt;code&gt;O(nlogn)&lt;/code&gt; 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 &lt;code&gt;O(n)&lt;/code&gt; 时间和 &lt;code&gt;O(1)&lt;/code&gt; 空间解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="算法分析" scheme="https://www.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="moore vote algorithm" scheme="https://www.jetmuffin.com/tags/moore-vote-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础学习（二）类型</title>
    <link href="https://www.jetmuffin.com/2016/09/04/Golang-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F/"/>
    <id>https://www.jetmuffin.com/2016/09/04/Golang-基础学习（二）类型、变量、常量/</id>
    <published>2016-09-04T02:25:44.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>go 语言中有许多的类型，包括字符串、整形、浮点型、布尔型等等，这和一般的语言相同。这些类型之间可以进行基本的运算，这和 C, Java 等语言也是相同的。</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math/cmplx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    flag   <span class="keyword">bool</span>       = <span class="literal">false</span></div><div class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></div><div class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"go"</span> + <span class="string">"lang"</span>)</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"1+1 = "</span>, <span class="number">1</span>+<span class="number">1</span>)</div><div class="line">    fmt.Println(<span class="string">"7.0/3.0 ="</span>, <span class="number">7.0</span>/<span class="number">3.0</span>)</div><div class="line"></div><div class="line">    fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)</div><div class="line">    fmt.Println(<span class="literal">true</span> || <span class="literal">false</span>)</div><div class="line">    fmt.Println(!<span class="literal">true</span>)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> f = <span class="string">"%T(%v)\n"</span></div><div class="line">    fmt.Printf(f, flag, flag)</div><div class="line">    fmt.Printf(f, MaxInt, MaxInt)</div><div class="line">    fmt.Printf(f, z, z)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>go 语言中的基础数据类型包括以下几种：</p>
<ul>
<li>int，Rune（Rune 是 int 的别名，代表一个 Unicode 码）</li>
<li>int8，int16，int32，int64</li>
<li>byte，uint8，uint16，uint32，uint64（byte 是 uint8 的别名）</li>
<li>float32，float64</li>
<li>bool</li>
<li>string</li>
<li>complex128，complex64（复数）</li>
</ul>
<p>源码中 <code>runtime.h</code> 对几种简单的基本类型先做了定义，然后用它们对其他的类型进行定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>             int8;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>           uint8;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span>            int16;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>          uint16;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">int</span>              int32;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>            uint32;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>    int64;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>                   float32;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>                  float64;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> uint32                  uintptr</div><div class="line"><span class="keyword">typedef</span> int32                   intptr</div><div class="line"><span class="keyword">typedef</span> int32                   intgo</div><div class="line"><span class="keyword">typedef</span> uint32                  uintgo</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> uint8                   <span class="keyword">bool</span>;</div><div class="line"><span class="keyword">typedef</span> uint8                   byte;</div></pre></td></tr></table></figure>
<p>从中可以看出 go 中的每个类型在 c 中对应的类型和占用字节大小。另外其中还定义了 <code>intptr</code> 和 <code>intgo</code>，其中 <code>intptr</code> 用于指针运算，<code>intgo</code> 相当于在源码中给 <code>int</code> 起的一个别名。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string 类型事实上是一个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct String &#123;</div><div class="line">    byte*   str;</div><div class="line">    intgo   len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对于每个 string 类型，都确定了它的长度和字符数组，也就是说 golang 的字符串初始化话底层的结构就会被初始化。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>go 中使用 <code>var</code> 作为关键字来进行变量声明。但和 javascript 里不同，go 中的变量是强类型。声明的方式有多种，包括：</p>
<ul>
<li><code>var a int</code>（仅声明不初始化）</li>
<li><code>var a = 10</code>（声明同时初始化，但不指定类型，由编译器自动推导类型）</li>
<li><code>var a int = 10</code>（声明、指定类型以及初始化）</li>
<li><code>a := 10</code>（省略关键字，声明同时初始化，由编译器推导类型）</li>
</ul>
<p><strong>Note:</strong> 这里需要注意的是，<code>:=</code>是用于声明及赋值，而不是赋值，因此仅在变量定义时使用，开始写 go 的时候常常将 <code>:=</code> 用于赋值导致出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"initial"</span></div><div class="line">    fmt.Println(a)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b, c <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></div><div class="line">    fmt.Println(b, c)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></div><div class="line">    fmt.Println(d)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> e <span class="keyword">int</span></div><div class="line">    fmt.Println(e)</div><div class="line"></div><div class="line">    f := <span class="string">"short"</span></div><div class="line">    fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>对变量声明语句，编译器会对其进行自动的类型推导，可以用 <code>reflect</code> 包来查看变量的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></div><div class="line">    <span class="keyword">var</span> b <span class="keyword">byte</span> = <span class="number">10</span></div><div class="line"></div><div class="line">    c := <span class="number">10.0</span></div><div class="line">    d := <span class="string">"10"</span></div><div class="line"></div><div class="line">    fmt.Printf(<span class="string">"a type:%s\n"</span>, reflect.TypeOf(a))</div><div class="line">    fmt.Printf(<span class="string">"b type:%s\n"</span>, reflect.TypeOf(b))</div><div class="line">    fmt.Printf(<span class="string">"c type:%s\n"</span>, reflect.TypeOf(c))</div><div class="line">    fmt.Printf(<span class="string">"d type:%s\n"</span>, reflect.TypeOf(d))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a type:int</div><div class="line">b type:uint8</div><div class="line">c type:float64</div><div class="line">d type:string</div></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>正常情况下，将类型 V 转化为 T 需要显式声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a := 5 // typeof(a) is int32</div><div class="line">b := int64(10) // typeof(b) is int64</div></pre></td></tr></table></figure>
<p>若没有显式声明还需要进行类型转换 V -&gt; T，则需要满足 <code>assignability</code>，根据文档<a href="https://golang.org/ref/spec#Assignability" target="_blank" rel="external">assignability</a>，可能的条件如下：</p>
<ul>
<li>T 和 V 的类型相同</li>
<li>T 和 V 的基础类型相同，并且其中至少一个并未显式指定类型</li>
<li>T 是一个 <code>interface</code> 类型，并且 V 实现了 T (这在后面会提到)</li>
<li>V 是一个双向的 <code>channel</code>，而 T 是一个 <code>channel</code>，同时 V 和 T 的元素类型相同</li>
<li>V 是 nil 同时 T 是 <code>slice</code>, <code>function</code>, <code>map</code>, <code>channel</code>, <code>interface</code>, <code>pointer</code> 中的一种</li>
<li>V 是未声明类型的常量</li>
</ul>
<p>在这些条件下，不需要显式声明，直接可以将 T 的值赋予 V。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>go 中的常量和 c 相同，需要在编译时确定值，并在编译时被创建。常量需要满足以下几个要求：</p>
<ul>
<li>类型必须是数值、字符串和布尔值之一</li>
<li>可以使用表达式，但表达式必须在编译时可以计算的</li>
<li>声明常量同时必须指定值（初始化），并且不能再修改值</li>
</ul>
<p>常量的关键字和 cpp 相同，用 <code>const</code> 进行声明，声明时可以显式指定数据类型，也可以不指定。多个常量可以同时进行批量声明，常见的使用方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    s <span class="keyword">string</span> = <span class="string">"constant"</span></div><div class="line">    one, two = <span class="number">1</span>, <span class="number">2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(s)</div><div class="line">    fmt.Println(one)</div><div class="line">    fmt.Println(two)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> n = <span class="number">500000000</span></div><div class="line">    <span class="keyword">const</span> d = <span class="number">3e20</span> / n</div><div class="line">    fmt.Println(d)</div><div class="line"></div><div class="line">    fmt.Println(<span class="keyword">int64</span>(d))</div><div class="line"></div><div class="line">    fmt.Println(math.Sin(n))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota 在 go 中用于常量计数。iota 在 const 关键字出现时置 0，并且 const 内每增加一行讲使 itoa 计数一次，举个例子应该就很清楚了。</p>
<p>```go<br>const a = iota // a = 0<br>const b = iota // b = 0<br>const (<br>    c = iota   // c = 0<br>    d = iota   // d = 1<br>    e = iota   // e = 2<br>)<br>const (<br>    f, g = iota, 1 &lt;&lt; iota // f = 0, g = 1<br>    h, i = iota, 1 &lt;&lt; iota // h = 1, i = 2<br>)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://golang.org/ref/spec#Constant" target="_blank" rel="external">Golang Document</a></li>
<li><a href="http://www.cnblogs.com/howDo/archive/2013/04/15/GoLang-Constant.html" target="_blank" rel="external">老虞学GoLang笔记</a></li>
<li><a href="http://www.tuicool.com/articles/MJZvi27" target="_blank" rel="external">golang的类型转换的坑和分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h2&gt;&lt;p&gt;go 语言中有许多的类型，包括字符串、整形、浮点型、布尔型等等，这和一般的语言相同。这些类型之间可以进行基本的运算，这和 C, Java 等语言也是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://www.jetmuffin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://www.jetmuffin.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础学习（一）</title>
    <link href="https://www.jetmuffin.com/2016/09/03/Golang-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.jetmuffin.com/2016/09/03/Golang-基础学习（一）/</id>
    <published>2016-09-03T12:09:56.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>最初接触 go 是在 15 年，最开始对 go 的理解是写多线程的程序非常方便，于是学习了 go 的基本语法，并尝试写了一些 go 的简单应用，包括我的本科毕业设计也是使用 go 写的（<a href="https://github.com/icsnju/apt-mesos" target="_blank" rel="external">apt-mesos</a>）。但是对 go 也是停留在最基本的语法认识，有很多特性并未了解。所以想要从头再屡一遍 go 的所有内容。对每一块儿内容，以重学的角度深入学习。</p>
<a id="more"></a>
<h2 id="教程与代码"><a href="#教程与代码" class="headerlink" title="教程与代码"></a>教程与代码</h2><p>学习的过程将使用教程（<a href="https://gobyexample.com/" target="_blank" rel="external">https://gobyexample.com/</a>），它对 go 的每块儿内容提供了 demo，可以更易于理解。教程中的例程，将对其进行理解和实现，然后将代码整理在仓库 [<a href="https://github.com/JetMuffin/golearning.git" target="_blank" rel="external">JetMuffin/golearning</a>]中。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>任何语言的入门，都需要编写一个 Hello World 程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"hello world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一段使用 <code>fmt</code> 进行输出 <code>hello world</code> 字符的代码，从语言的风格上看，go 使用 <code>package</code> 作为关键字进行包管理，这和 java 很像；而导入包的部分则又像 python；而主函数部分也比较独特。庆幸的是，go 中也不需要添加分号。</p>
<p>go 和 python，ruby 等不同，它是解释型语言，因此在每次运行前需要进行编译，然后才可以进行执行，或者直接进行编译执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ go run helloworld.go</div><div class="line">hello world</div><div class="line"></div><div class="line">$ go build helloworld.go</div><div class="line">$ ls</div><div class="line">helloworld      helloworld.go</div><div class="line"></div><div class="line">$ ./helloworld</div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>这里需要知道的一点是，编译好后生成了 binary 文件，可以在同平台下直接进行运行，但并无法做到 runing everywhere，因为可能需要涉及到交叉编译的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;最初接触 go 是在 15 年，最开始对 go 的理解是写多线程的程序非常方便，于是学习了 go 的基本语法，并尝试写了一些 go 的简单应用，包括我的本科毕业设计也是使用 go 写的（&lt;a href=&quot;https://github.com/icsnju/apt-mesos&quot;&gt;apt-mesos&lt;/a&gt;）。但是对 go 也是停留在最基本的语法认识，有很多特性并未了解。所以想要从头再屡一遍 go 的所有内容。对每一块儿内容，以重学的角度深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://www.jetmuffin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://www.jetmuffin.com/tags/golang/"/>
    
      <category term="hello world" scheme="https://www.jetmuffin.com/tags/hello-world/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix配合lm_sensors监控服务器CPU温度</title>
    <link href="https://www.jetmuffin.com/2016/09/01/Zabbix%E9%85%8D%E5%90%88lm-sensors%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E6%B8%A9%E5%BA%A6/"/>
    <id>https://www.jetmuffin.com/2016/09/01/Zabbix配合lm-sensors监控服务器CPU温度/</id>
    <published>2016-09-01T06:18:06.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。</p>
<p>首先是获取 CPU 温度的方法，常见的有两种：</p>
<ul>
<li>IPMI</li>
<li>lm_sensors</li>
</ul>
<p>其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>lm_sensors 的安装很简单，repo 里已经有这个包了，所以直接通过 yum 安装就行了（集群是用的 CentOS，Debian系的也差不多）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install lm_sensors</div></pre></td></tr></table></figure>
<p>考虑到大多数集群是无法直接通外网的，所以可以在一台可以通外网的机器上下好 rpm 包，再传到 NFS 上或者直接 <code>scp</code>进去。下载 rpm 包可以使用 <code>yumdownloader</code>，刚好 lm_sensors 没有要依赖的包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yumdownloader install lm_sensors</div></pre></td></tr></table></figure>
<h2 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h2><p>采集数据之前，先看一下 zabbix 的自定义监控项的定义方法。在 <code>zabbix_agentd</code> 中对自定义监控项的定义格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserParameter=&lt;key&gt;,&lt;shell command&gt;</div></pre></td></tr></table></figure>
<p>其中可以看出监控项通过一句 shell 命令获得，并且获得的需要是一个数值。这样我们大概明确了需要采集的目标。</p>
<p>然后先简单过掉下 lm_sensors 需要的配置，即监测 sensors 的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sensors-detect</div><div class="line">This program will <span class="built_in">help</span> you determine <span class="built_in">which</span> kernel modules you need</div><div class="line">to load to use lm_sensors most effectively. It is generally safe</div><div class="line">and recommended to accept the default answers to all questions,</div><div class="line">unless you know what you<span class="string">'re doing.</span></div><div class="line"></div><div class="line">Some south bridges, CPUs or memory controllers contain embedded sensors.</div><div class="line">Do you want to scan for them? This is totally safe. (YES/no):</div></pre></td></tr></table></figure>
<p>一路敲 <code>yes</code> 即可，然后执行 <code>sensors</code> 命令可以看到 CPU 的温度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ sensors</div><div class="line">power_meter-acpi-0</div><div class="line">Adapter: ACPI interface</div><div class="line">power1:     18446.74 GW  (interval =   2.00 s)</div><div class="line"></div><div class="line">coretemp-isa-0000</div><div class="line">Adapter: ISA adapter</div><div class="line">Physical id 0: +41.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 0:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +28.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +34.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line"></div><div class="line">coretemp-isa-0001</div><div class="line">Adapter: ISA adapter</div><div class="line">Physical id 1: +38.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 0:        +33.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +34.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div></pre></td></tr></table></figure>
<p>命令显示的结果是每个核心的温度以及物理核的温度，最后要聚合到一个数值上。这里可以选择两个方向，一是对每个核心进行监控，这样较为复杂，但是细节明显；二是对每个核心取平均值，处理比较简单。这里我选择了后者，那么就需要从命令输出中获取到需要的信息了。这里就用 <code>grep</code>，<code>cut</code>，<code>awk</code> 乱处理一通了。</p>
<p>首先用 <code>grep</code> 拿到每个核心的温度行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ sensors | grep <span class="string">"Core"</span></div><div class="line">Core 0:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +34.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 0:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 1:        +33.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 2:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 3:        +30.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 4:        +32.0°C  (high = +75.0°C, crit = +85.0°C)</div><div class="line">Core 5:        +31.0°C  (high = +75.0°C, crit = +85.0°C)</div></pre></td></tr></table></figure>
<p>然后用 <code>cut</code> 或者 <code>awk</code> 获取每行的温度数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ sensors | grep <span class="string">"Core"</span> | awk <span class="string">'&#123;print $3&#125;'</span> | awk -F <span class="string">'.'</span> <span class="string">'&#123;print $1&#125;'</span> | awk -F <span class="string">'+'</span> <span class="string">'&#123;print $2&#125;'</span></div><div class="line">30</div><div class="line">33</div><div class="line">29</div><div class="line">34</div><div class="line">30</div><div class="line">30</div><div class="line">31</div><div class="line">34</div><div class="line">32</div><div class="line">32</div><div class="line">32</div><div class="line">30</div></pre></td></tr></table></figure>
<p>最后对这些输出按行取平均，再四舍五入到整数就行了（也可以不四舍五入）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sensors | grep <span class="string">'Core'</span> | awk <span class="string">'&#123;print $3&#125;'</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $1&#125;'</span> | awk -F <span class="string">"+"</span> <span class="string">'&#123;print $2&#125;'</span> | \</div><div class="line">awk <span class="string">'&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;'</span> | awk -F. <span class="string">'&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;'</span></div><div class="line">31</div></pre></td></tr></table></figure>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>做完数据的采集工作，那么就要集成进 Zabbix 里了。首先需要在 zabbix_agentd 里定义这个监控项，在 <code>zabbix_agentd.conf</code> 里加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UserParameter=system.cpu.temperature,/usr/bin/sensors | grep &apos;Core&apos; | awk &apos;&#123;print $3&#125;&apos; | awk -F &quot;.&quot; &apos;&#123;print $1&#125;&apos; | awk -F &quot;+&quot; &apos;&#123;print $2&#125;&apos; | awk  &apos;&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;&apos; | awk -F. &apos;&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;&apos;</div></pre></td></tr></table></figure>
<p>然后重启 agent 服务即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ service zabbix_agentd restart</div><div class="line">Shutting down zabbix_agentd:                               [  OK  ]</div><div class="line">Starting zabbix_agentd:                                    [  OK  ]</div></pre></td></tr></table></figure>
<p>回到 Zabbix 的界面，选择一个合适的模板，进到它的监控项中，点击新建监控项，然后如下图填入信息即可。注意这里的键值即上面填的 <code>UserParameters</code> 里的 <code>key</code>。</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-0@2x.png" alt="add-new-metric"></p>
<p>然后对相应的主机应用这个模板，那么就可以获取到这台主机的 CPU 温度了。</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-1@2x.png" alt="metric-data"></p>
<p>报警设置和普通监控项相同，如下：</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-2@2x.png" alt="alert"></p>
<p>最后，如果对 Zabbix 增加了 grafana 的话，还可以在 grafana 里去显示 CPU 温度。</p>
<p><img src="/uploads/images/2016/09/01/QQ20160901-3@2x.png" alt="grafana"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。&lt;/p&gt;
&lt;p&gt;首先是获取 CPU 温度的方法，常见的有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPMI&lt;/li&gt;
&lt;li&gt;lm_sensors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。&lt;br&gt;
    
    </summary>
    
      <category term="系统运维" scheme="https://www.jetmuffin.com/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="zabbix" scheme="https://www.jetmuffin.com/tags/zabbix/"/>
    
      <category term="lm_sensors" scheme="https://www.jetmuffin.com/tags/lm-sensors/"/>
    
      <category term="cpu" scheme="https://www.jetmuffin.com/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>使用slurm进行集群的资源管理（vagrant）</title>
    <link href="https://www.jetmuffin.com/2016/05/30/Ubuntu-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8Slurm/"/>
    <id>https://www.jetmuffin.com/2016/05/30/Ubuntu-安装与使用Slurm/</id>
    <published>2016-05-30T01:42:48.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。</p>
</blockquote>
<a id="more"></a>
<p>slrum相当于一个集群管理器，可以伸缩至大型节点集群，容错好，而更重要的是他开源。而现在，slurm已经成为很多强大的超级计算机上使用的资源管理器。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://www.ibm.com/developerworks/cn/linux/l-slurm-utility/figure2.gif" alt="slurm架构"><br>slurm的架构和一般的集群管理架构相类似，顶部是一对冗余集群控制器，它充当计算集群的管理器并实现一个管理守护程序（<code>slurmctld</code>），<code>slurmctld</code>提供了对计算资源的监视，同时它将进入的作业映射到基本的计算资源。</p>
<p>此外，每个计算节点上有一个守护程序<code>slurmd</code>，<code>slurmd</code>负责管理在其上执行的节点包括运行的任务，来自控制器的工作，以及接受控制器的请求等。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装上，为了模拟集群的环境，需要使用多个节点，所以我们用<code>vagrant</code>创建多个虚拟机。<code>Vagrantfile</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- mode: ruby -*-</div><div class="line"># vi: set ft=ruby :</div><div class="line">Vagrant.configure(2) do |config|</div><div class="line">  config.vm.box = &quot;ubuntu/trusty64&quot;</div><div class="line">  config.ssh.insert_key = false</div><div class="line">  config.vm.define &quot;master&quot; do |node|</div><div class="line">	node.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.10&quot;</div><div class="line">	node.vm.hostname = &quot;master&quot;</div><div class="line">	node.vm.provider &quot;virtualbox&quot; do |v|</div><div class="line">	  v.memory = 2048</div><div class="line">	  v.cpus = 2</div><div class="line">	end</div><div class="line">  end</div><div class="line">  config.vm.define &quot;compute&quot; do |slave|</div><div class="line">	slave.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot;</div><div class="line">	slave.vm.hostname = &quot;compute&quot;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>分别使用<code>vagrant up master</code>和<code>vagrant up compute</code>启动控制节点和计算节点。</p>
<p>Ubuntu源里提供了munge，所以可以直接通过源进行安装。在控制节点和计算节点分别安装slurm包，这个包里包含了<code>slurmctld</code>和<code>slurmd</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install slurm-llnl</div></pre></td></tr></table></figure>
<p>由于计算节点和控制节点需要通信，而通信之间需要进行认证，所以这里需要生成key并启动认证服务。这里使用的是llnl的munge。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo create-munge-key</div><div class="line">Generating a pseudo-random key using /dev/urandom complete.</div></pre></td></tr></table></figure>
<p>然后启动munge的认证服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service munge start</div></pre></td></tr></table></figure>
<p>接下来配置slurm的配置文件，然而笔者在使用时，slrum的配置工具<a href="https://computing.llnl.gov/linux/slurm/configurator.html" target="_blank" rel="external">Slurm Configuration Tool</a>失效了，所以可以去slurm的源码里复制一份<a href="https://github.com/SchedMD/slurm/blob/master/etc/slurm.conf.example" target="_blank" rel="external">example</a>。我的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">ClusterName=vagrant</div><div class="line">ControlMachine=master</div><div class="line">#ControlAddr=</div><div class="line">#</div><div class="line">SlurmUser=slurm</div><div class="line">SlurmctldPort=6817</div><div class="line">SlurmdPort=6818</div><div class="line">AuthType=auth/munge</div><div class="line">StateSaveLocation=/tmp</div><div class="line">SlurmdSpoolDir=/tmp/slurmd</div><div class="line">SwitchType=switch/none</div><div class="line">MpiDefault=none</div><div class="line">SlurmctldPidFile=/var/run/slurmctld.pid</div><div class="line">SlurmdPidFile=/var/run/slurmd.pid</div><div class="line">ProctrackType=proctrack/pgid</div><div class="line">ReturnToService=0</div><div class="line">#</div><div class="line"># TIMERS</div><div class="line">SlurmctldTimeout=300</div><div class="line">SlurmdTimeout=300</div><div class="line">InactiveLimit=0</div><div class="line">MinJobAge=300</div><div class="line">KillWait=30</div><div class="line">Waittime=0</div><div class="line">#</div><div class="line"># SCHEDULING</div><div class="line">SchedulerType=sched/backfill</div><div class="line">SelectType=select/linear</div><div class="line">FastSchedule=1</div><div class="line">#</div><div class="line"># LOGGING</div><div class="line">SlurmctldDebug=3</div><div class="line">SlurmdDebug=3</div><div class="line">JobCompType=jobcomp/none</div><div class="line">#</div><div class="line"># ACCOUNTING</div><div class="line">#</div><div class="line"># COMPUTE NODES</div><div class="line">NodeName=compute Procs=1 State=UNKNOWN</div><div class="line">PartitionName=debug Nodes=compute Default=YES MaxTime=INFINITE State=UP</div></pre></td></tr></table></figure>
<p>这份配置文件在计算节点上同样要使用，所以要复制到计算节点上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo scp /etc/slurm-llnl/slurm.conf vagrant@compute/~</div></pre></td></tr></table></figure>
<p>然后启动控制节点上的slurmctld服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo service slurm-llnl start</div><div class="line">* Starting slurm central management daemon slurmctld</div></pre></td></tr></table></figure>
<p>接着是计算节点的配置，同样需要使用munge，将控制节点生成的<code>munge.key</code>拷贝到计算节点上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo scp /etc/munge/munge.key vagrant@compute:/~</div></pre></td></tr></table></figure>
<p>然后进入计算节点，将<code>munge.key</code>拷贝到munge的目录并启动munge,<strong>注意要修改key的owner和group为munge</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo mv ~/munge.key /etc/munge/</div><div class="line">$ sudo chown munge:munge /etc/munge/munge.key</div></pre></td></tr></table></figure>
<p>然后就可以启动munge服务了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service munge start</div></pre></td></tr></table></figure>
<p>再将之前复制的<code>slurm.conf</code>放到指定位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mv ~/slurm.conf /etc/slurm-llnl/slurm.conf</div></pre></td></tr></table></figure>
<p>接着启动计算节点上的slurmd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service slurm-llnl start</div></pre></td></tr></table></figure>
<p>这样，slurm就配置完毕了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里就简单测试下slurm的功能（在控制节点上运行），首先运行<code>sinfo</code>查看集群状况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sinfo</div><div class="line">PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST</div><div class="line">debug*       up   infinite      1   idle compute</div></pre></td></tr></table></figure>
<p>然后启动一个任务（<code>/bin/hostname</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ srun -N1 /bin/hostname</div><div class="line">compute</div></pre></td></tr></table></figure>
<h2 id="错误与解决方案"><a href="#错误与解决方案" class="headerlink" title="错误与解决方案"></a>错误与解决方案</h2><p><strong>1. 启动munge报错误munged: Error: Logfile is insecure: group-writable permissions set on “/var/log”</strong></p>
<p>在Ubuntu 14.04下启动munge会出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo service munge start</div><div class="line"> * Starting MUNGE munged [fail]</div><div class="line">munged: Error: Logfile is insecure: group-writable permissions set on &quot;/var/log&quot;</div></pre></td></tr></table></figure>
<p>原因是因为Ubuntu 14.04将<code>/var/log</code>目录的权限从0755 root:root调整为0755 root:syslog，因此直接启动会报group-writable permissions的错误。</p>
<p>解决方案是启动munge时加上<code>--force</code>或<code>--syslog</code>的参数。</p>
<ul>
<li><code>--force</code>会将errors转为warnings，跳过错误</li>
<li><code>--syslog</code>会跳过<code>/var/log</code>目录的权限检查</li>
</ul>
<p>如果是使用<code>/etc/init.d/munge start</code>或者<code>service munge start</code>的话，可以将Option写到配置文件<code>/etc/default/munge</code>里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OPTIONS=&quot;--force&quot;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="资源管理" scheme="https://www.jetmuffin.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
      <category term="集群" scheme="https://www.jetmuffin.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>OSX系统列举USB设备方法</title>
    <link href="https://www.jetmuffin.com/2016/03/13/OSX%E7%B3%BB%E7%BB%9F%E5%88%97%E4%B8%BEUSB%E8%AE%BE%E5%A4%87%E6%96%B9%E6%B3%95/"/>
    <id>https://www.jetmuffin.com/2016/03/13/OSX系统列举USB设备方法/</id>
    <published>2016-03-13T13:38:34.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 用户在列举USB设备时，可以使用<code>lsusb</code>命令来查看所有已经连接的usb设备，或者进入<code>/dev/bus/usb/001</code>之类进行查看。</p>
<a id="more"></a>
<p>而在Mac OS下，系统自带的命令则是<code>system_profiler SPUSBDataType</code>，使用这条命令可以查看所有连接的USB设备，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"> jeff@promote ⮀ ~ ⮀ system_profiler SPUSBDataType</div><div class="line">USB:</div><div class="line"></div><div class="line">    USB 3.0 Bus:</div><div class="line"></div><div class="line">      BSD Name: en4</div><div class="line">      Host Controller Driver: AppleUSBXHCIWPT</div><div class="line">      PCI Device ID: 0x9cb1</div><div class="line">      PCI Revision ID: 0x0003</div><div class="line">      PCI Vendor ID: 0x8086</div><div class="line"></div><div class="line">        USB3.0 Hub:</div><div class="line"></div><div class="line">          Product ID: 0x0612</div><div class="line">          Vendor ID: 0x05e3  (Genesys Logic, Inc.)</div><div class="line">          Version: 92.16</div><div class="line">          Speed: Up to 5 Gb/sec</div><div class="line">          Manufacturer: GenesysLogic</div><div class="line">          Location ID: 0x14400000 / 6</div><div class="line">          Current Available (mA): 1800</div><div class="line">          Current Required (mA): 0</div><div class="line">          Extra Operating Current (mA): 0</div><div class="line"></div><div class="line">        Bluetooth USB Host Controller:</div><div class="line"></div><div class="line">          Product ID: 0x8290</div><div class="line">          Vendor ID: 0x05ac  (Apple Inc.)</div><div class="line">          Version: 1.11</div><div class="line">          Speed: Up to 12 Mb/sec</div><div class="line">          Manufacturer: Broadcom Corp.</div><div class="line">          Location ID: 0x14300000 / 2</div><div class="line">          Current Available (mA): 1000</div><div class="line">          Current Required (mA): 0</div><div class="line">          Extra Operating Current (mA): 0</div><div class="line">          Built-In: Yes</div><div class="line"></div><div class="line">        Razer DeathAdder:</div><div class="line"></div><div class="line">          Product ID: 0x0016</div><div class="line">          Vendor ID: 0x1532</div><div class="line">          Version: 1.00</div><div class="line">          Speed: Up to 12 Mb/sec</div><div class="line">          Manufacturer: Razer</div><div class="line">          Location ID: 0x14200000 / 4</div><div class="line">          Current Available (mA): 1000</div><div class="line">          Current Required (mA): 100</div><div class="line">          Extra Operating Current (mA): 0</div><div class="line"></div><div class="line">        USB2.0 Hub:</div><div class="line"></div><div class="line">          Product ID: 0x0610</div><div class="line">          Vendor ID: 0x05e3  (Genesys Logic, Inc.)</div><div class="line">          Version: 92.16</div><div class="line">          Speed: Up to 480 Mb/sec</div><div class="line">          Manufacturer: GenesysLogic</div><div class="line">          Location ID: 0x14100000 / 5</div><div class="line">          Current Available (mA): 1000</div><div class="line">          Current Required (mA): 100</div><div class="line">          Extra Operating Current (mA): 0</div><div class="line">          BSD Name: en4</div><div class="line"></div><div class="line">            Apple USB Ethernet Adapter:</div><div class="line"></div><div class="line">              Product ID: 0x1402</div><div class="line">              Vendor ID: 0x05ac  (Apple Inc.)</div><div class="line">              Version: 0.01</div><div class="line">              Serial Number: 1460AB</div><div class="line">              Speed: Up to 480 Mb/sec</div><div class="line">              Manufacturer: Apple Inc.</div><div class="line">              Location ID: 0x14140000 / 7</div><div class="line">              Current Available (mA): 1000</div><div class="line">              Current Required (mA): 250</div><div class="line">              Extra Operating Current (mA): 0</div><div class="line">              BSD Name: en4</div><div class="line"></div><div class="line">            iPhone:</div><div class="line"></div><div class="line">              Product ID: 0x12a8</div><div class="line">              Vendor ID: 0x05ac  (Apple Inc.)</div><div class="line">              Version: 7.02</div><div class="line">              Serial Number: 1ba089f6c8745ae921e95dea83879c7e36b43b9c</div><div class="line">              Speed: Up to 480 Mb/sec</div><div class="line">              Manufacturer: Apple Inc.</div><div class="line">              Location ID: 0x14130000 / 8</div><div class="line">              Current Available (mA): 1000</div><div class="line">              Current Required (mA): 500</div><div class="line">              Extra Operating Current (mA): 0</div><div class="line">              Sleep current (mA): 500</div></pre></td></tr></table></figure>
<p>而在图形界面上<code>EL Capitan</code>的操作步骤为：</p>
<ul>
<li>点击左上角苹果标志</li>
<li>点击<code>关于本机</code>-&gt; <code>系统报告</code> -&gt; <code>USB</code></li>
<li>然后则可以查看系统总线上挂载的USB信息了</li>
</ul>
<p><strong>最后说下为啥写这个：</strong>最近在研究怎么在<code>docker container</code>中挂载USB，首先要获取总线上的USB设备，这是个开头吧。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 用户在列举USB设备时，可以使用&lt;code&gt;lsusb&lt;/code&gt;命令来查看所有已经连接的usb设备，或者进入&lt;code&gt;/dev/bus/usb/001&lt;/code&gt;之类进行查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统运维" scheme="https://www.jetmuffin.com/tags/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>运行Mesos Framework报no mesos in java.library.path解决方法</title>
    <link href="https://www.jetmuffin.com/2016/01/05/%E8%BF%90%E8%A1%8CMesos-Framework%E6%8A%A5no-mesos-in-java-library-path%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://www.jetmuffin.com/2016/01/05/运行Mesos-Framework报no-mesos-in-java-library-path解决方法/</id>
    <published>2016-01-05T07:08:33.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在运行自己用scala编写的Framework时遇到了一个巨大的问题，即<br><a id="more"></a><br>在执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp xxxx.jar -Djava.library.path=libs xxxx.xxxx.xxx</div></pre></td></tr></table></figure>
<p>之后报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: no mesos in java.library.path</div><div class="line">    at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1758)</div><div class="line">    at java.lang.Runtime.loadLibrary0(Runtime.java:823)</div><div class="line">    at java.lang.System.loadLibrary(System.java:1045)</div><div class="line">    at org.apache.mesos.MesosNativeLibrary.load(MesosNativeLibrary.java:46)</div></pre></td></tr></table></figure>
<p>尝试了把build之后的<code>mesos-0.25.0.jar</code>和<code>protobuf-2.5.0.jar</code>加入，依然不生效，查询了<code>stackoverflow</code>后发现是<code>MESOS_NATIVE_LIBRARY</code>环境变量未加入。</p>
<p>因此只要执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> # For Linux</div><div class="line">$ export MESOS_NATIVE_LIBRARY=&apos;/usr/local/lib/libmesos.so&apos;</div><div class="line"></div><div class="line"> # For OSX</div><div class="line">$ export MESOS_NATIVE_LIBRARY=&apos;/usr/local/lib/libmesos.dylib&apos;</div></pre></td></tr></table></figure>
<p>就行了。</p>
<p>为了方便，可以把这个语句加到.bashrc中</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在运行自己用scala编写的Framework时遇到了一个巨大的问题，即&lt;br&gt;
    
    </summary>
    
      <category term="设计开发" scheme="https://www.jetmuffin.com/categories/%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="bugfix" scheme="https://www.jetmuffin.com/tags/bugfix/"/>
    
  </entry>
  
  <entry>
    <title>DCOS上的cron 分布式作业调度器 Chronos</title>
    <link href="https://www.jetmuffin.com/2015/12/28/DCOS%E4%B8%8A%E7%9A%84cron-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E5%99%A8-Chronos/"/>
    <id>https://www.jetmuffin.com/2015/12/28/DCOS上的cron-分布式作业调度器-Chronos/</id>
    <published>2015-12-28T13:34:27.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chronos是Aribnb公司开发的替代<code>cron</code>的Mesos框架。它是一个运行在<code>Apache Mesos</code>上的分布式的，高容错的任务编排、定时任务的框架。</p>
<a id="more"></a>
<p>Chronos作为DCOS中的一部分，它默认所处的环境下存在任务的环境。例如Chronos会执行Hadoop任务脚本，即使执行的slave上并没有Hadoop环境（但是这样会导致任务的失败）。此外，Chronos支持任务脚本传输文件到远程机器上，并执行文件，同时接受异步的回调，通知Chronos任务成功或是失败。比较重要的一点是，Chronos同样支持在<code>Docker</code>容器中进行执行任务。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://7xpl2y.com1.z0.glb.clouddn.com/chronos.png" alt="architecture"></p>
<p>Chronos通过Mesos Master下的<code>Scheduler</code>选择指定slave执行job，来完成相应的task。而在Chronos中并不会对环境进行选择，而只是对从Mesos Master接受的<code>Resource offers</code>进行筛选。</p>
<h2 id="JobGraph"><a href="#JobGraph" class="headerlink" title="JobGraph"></a>JobGraph</h2><p>Chronos中比较重要的一点是利用JobGraph来确定各个job之间的依赖关系，以确定任务执行的先后顺序。</p>
<p>Chronos中根据JobGraph计算出job执行的优先级，然后再根据当前的job执行情况，然后确定每个任务是否进行执行。</p>
<p>如图，我创建了2个任务:</p>
<p><img src="http://7xpl2y.com1.z0.glb.clouddn.com/QQ20151228-3%402x.png" alt="create-job"></p>
<p>指定<code>sleep2</code>的父元素为<code>sleep</code>，则<code>sleep2</code>依赖于<code>sleep</code>，先后顺序也应该为先执行<code>sleep</code>然后是<code>sleep2</code>，如下图(绿色代表已经执行，白色代表未执行)</p>
<p><img src="http://7xpl2y.com1.z0.glb.clouddn.com/QQ20151228-2%402x.png" alt="job-run"></p>
<p>而实际生产中JobGraph的图是非常复杂的，因此Chronos利用JobGraph能够很有效的进行任务的调度。</p>
<h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><p>这里主要分析framework部分的主要核心代码：</p>
<p><strong>resourceOffers()</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该方法实现调用mesos的scala接口，进行offer的分配</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resourceOffers</span></span>(schedulerDriver: <span class="type">SchedulerDriver</span>, receivedOffers: java.util.<span class="type">List</span>[<span class="type">Offer</span>]) &#123;</div><div class="line">    log.info(<span class="string">"Received resource offers"</span>)</div><div class="line">    <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</div><div class="line"></div><div class="line">    <span class="keyword">val</span> offers = receivedOffers.asScala.toList</div><div class="line">    <span class="keyword">val</span> offerResources = mutable.<span class="type">HashMap</span>(offers.map(o =&gt; (o, <span class="type">Resources</span>(o))).toSeq: _*)</div><div class="line">    <span class="comment">//生成可以执行的task(详细见下文)</span></div><div class="line">    <span class="keyword">val</span> tasksToLaunch = generateLaunchableTasks(offerResources)</div><div class="line"></div><div class="line">    log.info(<span class="string">"Declining unused offers."</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 创建一个Set保存已经使用的offer</span></div><div class="line">    <span class="keyword">val</span> usedOffers = mutable.<span class="type">HashSet</span>(tasksToLaunch.map(_._3.getId.getValue): _*)</div><div class="line">	</div><div class="line">	<span class="comment">//如果当前的offer已经被使用了（在usedOffers里出现），则decline掉</span></div><div class="line">    offers.foreach(o =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!usedOffers.contains(o.getId.getValue))</div><div class="line">        mesosDriver.get().declineOffer(o.getId, declineOfferFilters)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    log.info(<span class="string">s"Declined unused offers with filter refuseSeconds=<span class="subst">$&#123;declineOfferFilters.getRefuseSeconds&#125;</span> "</span> +</div><div class="line">      <span class="string">s"(use --<span class="subst">$&#123;config.declineOfferDuration.name&#125;</span> to reconfigure)"</span>)</div><div class="line">	</div><div class="line">	<span class="comment">//执行任务</span></div><div class="line">    launchTasks(tasksToLaunch)</div><div class="line"></div><div class="line">    <span class="comment">// Perform a reconciliation, if needed.</span></div><div class="line">    reconcile(schedulerDriver)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>generateLaunchableTasks（）</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">generateLaunchableTasks</span></span>(offerResources: mutable.<span class="type">HashMap</span>[<span class="type">Offer</span>, <span class="type">Resources</span>]): mutable.<span class="type">Buffer</span>[(<span class="type">String</span>, <span class="type">BaseJob</span>, <span class="type">Offer</span>)] = &#123;</div><div class="line">   <span class="keyword">val</span> tasks = mutable.<span class="type">Buffer</span>[(<span class="type">String</span>, <span class="type">BaseJob</span>, <span class="type">Offer</span>)]()</div><div class="line">   </div><div class="line"><span class="comment">// 属性约束检查</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">checkConstraints</span></span>(attributes: <span class="type">Seq</span>[<span class="type">Protos</span>.<span class="type">Attribute</span>], constraints: <span class="type">Seq</span>[<span class="type">Constraint</span>]): <span class="type">Boolean</span> = &#123;</div><div class="line">   	<span class="comment">//遍历所有的属性约束</span></div><div class="line">     constraints.foreach &#123; c =&gt;</div><div class="line">       <span class="keyword">if</span> (!c.matches(attributes)) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="literal">true</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">//尾递归注解</span></div><div class="line">   <span class="meta">@tailrec</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">generate</span></span>() &#123;</div><div class="line">     taskManager.getTask <span class="keyword">match</span> &#123;</div><div class="line">       <span class="keyword">case</span> <span class="type">None</span> =&gt; log.info(<span class="string">"No tasks scheduled or next task has been disabled.\n"</span>)</div><div class="line">       <span class="keyword">case</span> <span class="type">Some</span>((taskId, job)) =&gt;</div><div class="line">         <span class="keyword">if</span> (runningTasks.contains(job.name)) &#123;</div><div class="line">         	<span class="comment">// 若当前的task正在执行，则从taskManager里将其去除</span></div><div class="line">           <span class="keyword">val</span> deleted = taskManager.removeTask(taskId)</div><div class="line">           log.warning(<span class="string">"The head of the task queue appears to already be running: "</span> + job.name + <span class="string">"\n"</span>)</div><div class="line">           <span class="comment">// 递归调用</span></div><div class="line">           generate()</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">           tasks.find(_._2.name == job.name) <span class="keyword">match</span> &#123;</div><div class="line">             <span class="keyword">case</span> <span class="type">Some</span>((subtaskId, subJob, offer)) =&gt;</div><div class="line">               <span class="comment">//若发现已经调度的任务出现在队列中，则将其删除</span></div><div class="line">               <span class="keyword">val</span> deleted = taskManager.removeTask(subtaskId)</div><div class="line">               log.warning(<span class="string">"Found job in queue that is already scheduled for launch with this offer set: "</span> + subJob.name + <span class="string">"\n"</span>)</div><div class="line">               <span class="comment">//递归调用</span></div><div class="line">               generate()</div><div class="line">             <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">             	<span class="comment">//生产当前任务所需的资源，并且判断每个offer的各个资源是否能够满足</span></div><div class="line">               <span class="keyword">val</span> neededResources = <span class="keyword">new</span> <span class="type">Resources</span>(job)</div><div class="line">               offerResources.toIterator.find &#123; ors =&gt;</div><div class="line">                 ors._2.canSatisfy(neededResources) &amp;&amp; checkConstraints(ors._1.getAttributesList.asScala, job.constraints)</div><div class="line">               &#125; <span class="keyword">match</span> &#123;</div><div class="line">                 <span class="keyword">case</span> <span class="type">Some</span>((offer, resources)) =&gt;</div><div class="line">                 	<span class="comment">//若存在资源能够满足</span></div><div class="line">                   <span class="comment">// Subtract this job's resource requirements from the remaining available resources in this offer.	</span></div><div class="line">                   <span class="comment">//计算新资源，执行任务</span></div><div class="line">                   resources -= neededResources</div><div class="line">                   tasks.append((taskId, job, offer))</div><div class="line">                   <span class="comment">//继续递归</span></div><div class="line">                   generate()</div><div class="line">                 <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">                 	<span class="comment">// 资源不足，则将task重新加回队列（taskManager）</span></div><div class="line">                   <span class="keyword">val</span> foundResources = offerResources.toIterator.map(_._2.toString()).mkString(<span class="string">","</span>)</div><div class="line">                   log.warning(</div><div class="line">                     <span class="string">"Insufficient resources remaining for task '%s', will append to queue. (Needed: [%s], Found: [%s])"</span></div><div class="line">                       .stripMargin.format(taskId, neededResources, foundResources)</div><div class="line">                   )</div><div class="line">                   taskManager.enqueue(taskId, job.highPriority)</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   generate()</div><div class="line">   tasks</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从这段源码中可以看出来taskManaer事实上是一个task的<code>优先队列</code>。同时从generateLaunchableTasks()这个函数看出Chronos利用Scala的尾递归巧妙地处理了所有情况，保证调度器工作的执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Chronos是一个非常好的Mesos框架，同时它的源码采用scala语言进行编写，函数式编程也让代码看起来非常的舒畅。由于笔者毕业设计打算写一个Mesos Framework，所以Chronos是一个很好的典范！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chronos是Aribnb公司开发的替代&lt;code&gt;cron&lt;/code&gt;的Mesos框架。它是一个运行在&lt;code&gt;Apache Mesos&lt;/code&gt;上的分布式的，高容错的任务编排、定时任务的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="chronos" scheme="https://www.jetmuffin.com/tags/chronos/"/>
    
      <category term="批处理" scheme="https://www.jetmuffin.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
      <category term="脚本" scheme="https://www.jetmuffin.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Mesos Authentication详解</title>
    <link href="https://www.jetmuffin.com/2015/12/28/Mesos-Authentication%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.jetmuffin.com/2015/12/28/Mesos-Authentication详解/</id>
    <published>2015-12-28T09:01:24.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Authentication模块是Mesos中较为重要的一部分，涉及了整个系统的安全性。Mesos 0.15.0引入了framework authentication，0.19.0引入了slave authentication。Mesos Authentication只允许信任的实体可以和Mesos集群进行交互。</p>
<a id="more"></a>
<p>Mesos中的Authentication模块常用使用方法有三种：</p>
<ol>
<li>要求framework必须被授权才能向master注册</li>
<li>要求slaves必须被授权才能获得resources offer</li>
<li>限制<code>/teardown</code>端的访问</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Mesos的Authentication模块使用了<code>Cyrus SASL Library</code>实现验证。SASL提供了多种验证机制，包括（<code>ANOYMOUS</code>,<code>PLAIN</code>,’CRAM-MD5<code>,</code>GSSAPI`等）。</p>
<p>现在Mesos默认支持<code>CRAM-MD5</code>进行验证，单用户可以拓展自己的<code>authentication modules</code>（详见之后的文章<a href="#">mesos modules</a>）。<code>CRAM-MD5</code>使用<code>principal</code>和<code>secret</code>对进行验证，其中<code>principal</code>代表framework的身份。<strong>注意，这里的framework并不是执行framework的user而是framework自身</strong></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在启动mesos节点时可以通过配置项来选择是否启用authentication模块，对哪些部分启用authentication。</p>
<h3 id="Masters"><a href="#Masters" class="headerlink" title="Masters"></a>Masters</h3><ul>
<li>-authenticate/-no-authenticate 前者只允许授权的framework接入集群，后者还允许未授权的framework接入</li>
<li>-authenticate_slaves/-no-authenticate_slaves 前者只允许授权的slave介入集群，后者还允许未授权的framework接入</li>
<li>-authenticators 指定选用的<code>authenticator module</code>默认是<code>crammd5</code>，用户可以通过<code>-modules</code>选项进行拓展</li>
<li>-credentials 指定证书路径（可能因<code>authenticator module</code>不同而不一定使用该选项）</li>
</ul>
<h3 id="Slaves"><a href="#Slaves" class="headerlink" title="Slaves"></a>Slaves</h3><ul>
<li>-authenticatee 指定slave使用哪个<code>authenticator module</code>和master的<code>authenticators</code>进行授权。默认是<code>crammd5</code></li>
<li>-credential 指定证书路径</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里使用默认的<code>CRAM-MD5</code>进行验证。</p>
<p><strong>1.创建credentials文件</strong></p>
<p>首先为master创建credentials文件，其中的内容像如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">principal1 secret1</div><div class="line">principal2 secret2</div></pre></td></tr></table></figure>
<p><strong>2. 启动master</strong></p>
<p>然后启动master,并使用我们刚刚生成的credentials文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --authenticate --authenticate_slaves --credentials=~/credentials</div></pre></td></tr></table></figure></p>
<p><strong>3.创建slave的credentials</strong></p>
<p>像步骤1一样创建slave的credentials</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">principal1 secret1</div></pre></td></tr></table></figure>
<p><strong>4.启动slave</strong></p>
<p>启动slave并进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/mesos-slave.sh --master=127.0.0.1:5050 --credential=~/slave_credential</div></pre></td></tr></table></figure>
<p><strong>6.framework验证</strong></p>
<p>不同的framework的验证方法可能不同，可以写入<code>scheduler driver</code>的构造方法中，也可以在启动框架时加入，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MESOS_AUTHENTICATE=true DEFAULT_PRINCIPAL=principal2 DEFAULT_SECRET=secret2 ./src/test-framework --master=127.0.0.1:5050</div></pre></td></tr></table></figure>
<p>结果：</p>
<p>使用credentials验证成功的slave:</p>
<p><img src="http://7xpl2y.com1.z0.glb.clouddn.com/QQ20151228-0.png" alt="authenticate_success"></p>
<p>未使用credentials验证的slave:</p>
<p><img src="http://7xpl2y.com1.z0.glb.clouddn.com/QQ20151228-1.png" alt="authenticate_failed"></p>
<p>可以看到未使用的slave无法进行注册</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Authentication模块是Mesos中较为重要的一部分，涉及了整个系统的安全性。Mesos 0.15.0引入了framework authentication，0.19.0引入了slave authentication。Mesos Authentication只允许信任的实体可以和Mesos集群进行交互。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="authentication" scheme="https://www.jetmuffin.com/tags/authentication/"/>
    
  </entry>
  
  <entry>
    <title>Mesos Monitoring机制总结</title>
    <link href="https://www.jetmuffin.com/2015/12/23/Mesos-Monitoring%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://www.jetmuffin.com/2015/12/23/Mesos-Monitoring机制总结/</id>
    <published>2015-12-23T14:24:56.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mesos的master和slave提供了一组统计数据和指标，使用户能够方便地监控资源使用情况并且尽早发现异常状态。Mesos的监控包括可用资源，已经使用的资源，已经注册的框架，活跃的slave和任务的状态等。开发者可以利用这些监控信息实现自动化的报警，也可以在监控界面里绘制动态的监控图表。</p>
<a id="more"></a>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>Mesos提供了两种不同的指标：<code>counter</code>和<code>gauge</code>。</p>
<p><code>counter</code>（计数器）用来跟踪不连续的事件。它是单向递增的，并且它的类型是自然数。典型的例子就是失败的任务数量、注册的slave数量等。对于这类指标，变化率比数值本身更加重要。</p>
<p><code>gauge</code>(我也不知道怎么翻译好）代表一瞬间的某个属性的测量值。例如当前集群中使用内存的总量，在线的slave连接数量。这类指标通常用来监控其是否在一段时间内高于或低于一个阈值（即是否异常）。</p>
<h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>Master节点的指标对外提供了api，具体可通过浏览器访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://&lt;master-ip&gt;:5050/metrics/snapshot</div></pre></td></tr></table></figure></p>
<p>来进行获取，访问该链接(GET请求）会返回一组JSON串，内容为指标名称和内容的键值对。</p>
<h3 id="1-指标内容：Slave总资源"><a href="#1-指标内容：Slave总资源" class="headerlink" title="1. 指标内容：Slave总资源"></a>1. 指标内容：Slave总资源</h3><p>属于该类别的指标主要包括整个集群的可用资源总量和当前已经使用的资源部分。如果资源使用量持续高举不下，说明应该增加集群的资源总量，或者集群内的某个Framework已经运行失常。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master/cpus_percent</code></td>
<td>已使用的CPU占总量百分比</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/cpus_used</code></td>
<td>已使用的CPU的个数</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/cpus_total</code></td>
<td>CPU的总数</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/cpus_revocable_percent</code></td>
<td>可回收</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/cpus_revocable_total</code></td>
<td>Number of revocable CPUs</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/cpus_revocable_used</code></td>
<td>Number of allocated revocable CPUs</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_percent</code></td>
<td>已使用的磁盘空间占总量百分比</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_used</code></td>
<td>已使用的磁盘空间(MB为单位)</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_used</code></td>
<td>已使用的磁盘空间(MB为单位)</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_total</code></td>
<td>磁盘总空间(MB为单位)</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_revocable_percent</code></td>
<td>Percentage of allocated revocable disk space</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_revocable_total</code></td>
<td>Revocable disk space in MB</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/disk_revocable_used</code></td>
<td>Allocated revocable disk space in MB</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/mem_percent</code></td>
<td>已使用的内存占总量百分比</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/mem_used</code></td>
<td>已使用的内存（MB为单位）</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/mem_total</code></td>
<td>内存总量（MB为单位）</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/mem_revocable_percent</code></td>
<td>Percentage of allocated revocable memory</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/mem_revocable_total</code></td>
<td>Revocable memory in MB</td>
<td>Gauge</td>
</tr>
<tr>
<td><code>master/mem_revocable_used</code></td>
<td>Allocated revocable memory in MB</td>
<td>Gauge</td>
</tr>
</tbody>
</table>
<h3 id="2-指标内容：Master状态"><a href="#2-指标内容：Master状态" class="headerlink" title="2. 指标内容：Master状态"></a>2. 指标内容：Master状态</h3><p>这部分的指标主要说明Master是否是leading master，它已经启动运行了多长时间。当一个集群经过一段时间依然没有选出leading master，则认为这个集群已经处于故障状态。这说明要么竞选过程出现问题（检查 ZooKeeper 的连接），要么选出的 Master 有故障。此外较短的已经运行时间表明Master近期有过重启。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master/elected</code></td>
<td>是否是 leading master</td>
<td>Gaude</td>
</tr>
<tr>
<td><code>master/uptime_secs</code></td>
<td>已经运行时间（秒）</td>
<td>Gaude</td>
</tr>
</tbody>
</table>
<h3 id="3-指标内容：Master资源"><a href="#3-指标内容：Master资源" class="headerlink" title="3. 指标内容：Master资源"></a>3. 指标内容：Master资源</h3><p>这部分的指标主要说明指定Master的资源总量和使用情况。Master节点资源使用率长期高居不下，可能会影响集群的整体性能。区别于1中的资源，以下的system的资源特指Master的资源，而1中为Slave的总体资源情况</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>system/cpus_total</code></td>
<td>在这个master的可用 CPU 的数量</td>
<td>Guage</td>
</tr>
<tr>
<td><code>system/load_15min</code></td>
<td>过去15分钟的平均负载</td>
<td>Guage</td>
</tr>
<tr>
<td><code>system/load_5min</code></td>
<td>过去5分钟的平均负载</td>
<td>Guage</td>
</tr>
<tr>
<td><code>system/load_1min</code></td>
<td>过去1分钟的平均负载</td>
<td>Guage</td>
</tr>
<tr>
<td><code>system/mem_free_bytes</code></td>
<td>空闲内存的字节数</td>
<td>Guage</td>
</tr>
<tr>
<td><code>system/mem_total_bytes</code></td>
<td>全部内存的字节数</td>
<td>Guage</td>
</tr>
</tbody>
</table>
<h3 id="4-指标内容：Slave状态"><a href="#4-指标内容：Slave状态" class="headerlink" title="4. 指标内容：Slave状态"></a>4. 指标内容：Slave状态</h3><p>改部分的指标主要包括Slave的事件、Slave数量和Slave状态的信息。活跃的Slave数量过少表明这个集群的Slave不健康，或者它们无法连接到当前的leading master。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master/slave_registrations</code></td>
<td>能够顺利地完成与Master断开然后                                                             重联的Slave的数量</td>
<td>Counter</td>
</tr>
<tr>
<td><code>master/slave_removals</code></td>
<td>各种原因被删除的Slave数量，包括维护</td>
<td>Counter</td>
</tr>
<tr>
<td><code>master/slave_reregistrations</code></td>
<td>重新注册的 slave 的数目</td>
<td>Counter</td>
</tr>
<tr>
<td><code>master/slave_shutdowns_scheduled</code></td>
<td>因为健康检查失败而被计划删除                                                             的 slave 的数量。由于对删除 slave 的速度有限制（Slave Removal Rate-Limit），所以它们不一定会立即被删除。                                                             当他们真正被删掉，指标 master/slave_shutdowns_completed 会增加。</td>
<td>Counter</td>
</tr>
<tr>
<td><code>master/slave_shutdowns_cancelled</code></td>
<td>被取消的删除 slave 操作的数量。                                                               发生在因为删除 Slave 有限速，slave 在被删除之前有机会成功重连并且发送 PONG 给 master</td>
<td>Counter</td>
</tr>
<tr>
<td><code>master/slave_shutdowns_completed</code></td>
<td>成功地被删除了的 Slave 的数量</td>
<td>Counter</td>
</tr>
<tr>
<td><code>master/slaves_active</code></td>
<td>活跃的 slave 的数量</td>
<td>Guage</td>
</tr>
<tr>
<td><code>master/slaves_connected</code></td>
<td>连接在线的 slave 的数量</td>
<td>Guage</td>
</tr>
<tr>
<td><code>master/slaves_disconnected</code></td>
<td>断开离线的 slave 的数量</td>
<td>Guage</td>
</tr>
<tr>
<td><code>master/slaves_inactive</code></td>
<td>不活跃的 slave 的数量</td>
<td>Guage</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mesos的master和slave提供了一组统计数据和指标，使用户能够方便地监控资源使用情况并且尽早发现异常状态。Mesos的监控包括可用资源，已经使用的资源，已经注册的框架，活跃的slave和任务的状态等。开发者可以利用这些监控信息实现自动化的报警，也可以在监控界面里绘制动态的监控图表。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="监控" scheme="https://www.jetmuffin.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>FZUOJ 1759 Super A^B mod C 指数循环节</title>
    <link href="https://www.jetmuffin.com/2015/12/08/FZUOJ-1759-Super-A-B-mod-C-%E6%8C%87%E6%95%B0%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    <id>https://www.jetmuffin.com/2015/12/08/FZUOJ-1759-Super-A-B-mod-C-指数循环节/</id>
    <published>2015-12-08T12:38:44.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://acm.fzu.edu.cn/problem.php?pid=1759" target="_blank" rel="external">http://acm.fzu.edu.cn/problem.php?pid=1759</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定A，B和C的值，求$A^{B}modC的值，其中<code>1&lt;=A,C&lt;=1e10,1&lt;=B&lt;=10e1000000</code></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>今天刚刚学到一个内容，指数降幂公式，即$A^{B}modC=A^{Bmodphi(c)+phi(c)}modC$</p>
<p>用这个公式，可以很方便地对大指数问题进行降维处理。<br><a id="more"></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="keyword">char</span> str[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> res = n;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)&#123;</div><div class="line">	<span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</div><div class="line">	  res = res - res / i;</div><div class="line">	  <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</div><div class="line">	res = res - res / n;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">multi</span><span class="params">(ll a, ll b, ll m)</span></span>&#123;</div><div class="line">	ll ans = <span class="number">0</span>;</div><div class="line">	a %= m;</div><div class="line">	<span class="keyword">while</span>(b)&#123;</div><div class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</div><div class="line">			ans = (ans + a) % m;</div><div class="line">			b--;</div><div class="line">		&#125;</div><div class="line">		b &gt;&gt;= <span class="number">1</span>;</div><div class="line">		a = (a + a) % m;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">quickmod</span><span class="params">(ll a, ll b, ll m)</span></span>&#123;</div><div class="line">	ll ans = <span class="number">1</span>;</div><div class="line">	a %= m;</div><div class="line">	<span class="keyword">while</span>(b)&#123;</div><div class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</div><div class="line">			ans = multi(ans, a, m);</div><div class="line">			b--;</div><div class="line">		&#125;</div><div class="line">		b &gt;&gt;= <span class="number">1</span>;</div><div class="line">		a = multi(a,a,m);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"> 	ll a,c;</div><div class="line"> 	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d%s%I64d"</span>, &amp;a, str, &amp;c))&#123;</div><div class="line"> 		ll len = <span class="built_in">strlen</span>(str);</div><div class="line"> 		ll ans = <span class="number">0</span>;</div><div class="line"> 		ll p = phi(c);</div><div class="line"> 		<span class="keyword">if</span>(len &lt;= <span class="number">15</span>)&#123;</div><div class="line"> 			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)</div><div class="line"> 				ans = ans * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</div><div class="line"> 		&#125;<span class="keyword">else</span>&#123; <span class="comment">// A^B%C = A^(B%phi(C)+phi(C))%C</span></div><div class="line"> 			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</div><div class="line"> 				ans = ans * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</div><div class="line"> 				ans %= p;</div><div class="line"> 			&#125;</div><div class="line"> 			ans += p;</div><div class="line"> 		&#125;</div><div class="line"> 		<span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, quickmod(a,ans,c));</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://acm.fzu.edu.cn/problem.php?pid=1759&quot;&gt;http://acm.fzu.edu.cn/problem.php?pid=1759&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定A，B和C的值，求$A^{B}modC的值，其中&lt;code&gt;1&amp;lt;=A,C&amp;lt;=1e10,1&amp;lt;=B&amp;lt;=10e1000000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;今天刚刚学到一个内容，指数降幂公式，即$A^{B}modC=A^{Bmodphi(c)+phi(c)}modC$&lt;/p&gt;
&lt;p&gt;用这个公式，可以很方便地对大指数问题进行降维处理。&lt;br&gt;
    
    </summary>
    
      <category term="算法题解" scheme="https://www.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="https://www.jetmuffin.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉函数" scheme="https://www.jetmuffin.com/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="循环节" scheme="https://www.jetmuffin.com/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>杭电校赛部分赛题题解</title>
    <link href="https://www.jetmuffin.com/2015/11/29/%E6%9D%AD%E7%94%B5%E6%A0%A1%E8%B5%9B%E9%83%A8%E5%88%86%E8%B5%9B%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.jetmuffin.com/2015/11/29/杭电校赛部分赛题题解/</id>
    <published>2015-11-29T14:16:08.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>下午大家在做题的时候我把后面几个题目写了写，写一个题解和大家分享。简单题大家自己讨论下，可能有什么坑的，自己细心点就行了。这里主要写一下<code>1003</code>，<code>1005</code>，<code>1006</code>，<code>1007</code>的题解。下午没怎么认真做，代码写的乱七八糟，大家见谅。</p>
<a id="more"></a>
<h2 id="1003-玩骰子"><a href="#1003-玩骰子" class="headerlink" title="1003 玩骰子"></a>1003 玩骰子</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>两个人扔骰子，根据规则（有三条、对子、散牌什么的，具体看题）比较大小，大的人赢。现在主角已经扔了一个结果了，然后对方也扔了一个结果，主角有一个机会选择一个数重新扔一次，问获胜的几率有多少。</p>
<p>这里有个需要理解一下的地方，<strong>因为主角很机智</strong>，所以肯定不会选择毫无胜算的数字来重新扔（就是选择了一个数字，重新扔骰子，扔出来的数字不管是多少都不会改变输的结果），所以算概率的时候分母注意一下不是全部的可能性，而是选择的可能性。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题就是个大模拟。。写一个结构体把比较函数写清楚了（<strong>注意罗列所有情况</strong>），然后暴力枚举吧，注意如果win的数量为0，就不要加tot了，然后取所有数里面赢的概率最大的为结果。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> x &gt; y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> vis[<span class="number">6</span>];</div><div class="line"><span class="keyword">struct</span> node</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n[<span class="number">3</span>];</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="keyword">int</span> tn;</div><div class="line">    <span class="keyword">int</span> tnn;</div><div class="line">    node(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)&#123;</div><div class="line">        n[<span class="number">0</span>] = a;</div><div class="line">        n[<span class="number">1</span>] = b;</div><div class="line">        n[<span class="number">2</span>] = c;</div><div class="line">        sort(n, n+<span class="number">3</span>, cmp);</div><div class="line">        <span class="keyword">if</span>(n[<span class="number">0</span>] == n[<span class="number">2</span>])&#123;</div><div class="line">            t = <span class="number">3</span>;</div><div class="line">            tn = n[<span class="number">0</span>];</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n[<span class="number">0</span>] == n[<span class="number">1</span>])&#123;</div><div class="line">            t = <span class="number">2</span>;</div><div class="line">            tn = n[<span class="number">1</span>];</div><div class="line">            tnn = n[<span class="number">2</span>];</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n[<span class="number">1</span>] == n[<span class="number">2</span>])&#123;</div><div class="line">            t = <span class="number">2</span>;</div><div class="line">            tn = n[<span class="number">1</span>];</div><div class="line">            tnn = n[<span class="number">0</span>];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            t = <span class="number">1</span>;</div><div class="line">            tn = n[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ncmp</span><span class="params">(node y)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(t == y.t)&#123;</div><div class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(n[<span class="number">0</span>] == y.n[<span class="number">0</span>])&#123;</div><div class="line">                    <span class="keyword">if</span>(n[<span class="number">1</span>] == y.n[<span class="number">1</span>])&#123;</div><div class="line">                        <span class="keyword">if</span>(n[<span class="number">2</span>] == y.n[<span class="number">2</span>])&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">                        &#125;<span class="keyword">else</span>&#123;</div><div class="line">                            <span class="keyword">return</span> n[<span class="number">2</span>] &gt; y.n[<span class="number">2</span>];</div><div class="line">                        &#125;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        <span class="keyword">return</span> n[<span class="number">1</span>] &gt; y.n[<span class="number">1</span>];</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> n[<span class="number">0</span>] &gt; y.n[<span class="number">0</span>];</div><div class="line">                &#125;                </div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(tn == y.tn)&#123;</div><div class="line">                    <span class="keyword">return</span> tnn &gt; y.tnn;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> tn &gt; y.tn;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> n[<span class="number">0</span>] &gt; y.n[<span class="number">0</span>]; </div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> t &gt; y.t;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;n[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;n[<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;n[<span class="number">2</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a, b, c,d,e,f;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);</div><div class="line">        node x = node(a,b,c);</div><div class="line">        node y = node(d,e,f);</div><div class="line">        <span class="comment">// x.print();</span></div><div class="line">        <span class="comment">// y.print();</span></div><div class="line">        <span class="comment">// cout&lt;&lt;x.ncmp(y)&lt;&lt;endl;        </span></div><div class="line">        <span class="keyword">if</span>(x.ncmp(y)==<span class="number">1</span>)&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, <span class="number">1.0</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> tot = <span class="number">6</span>;</div><div class="line">        <span class="keyword">int</span> win = <span class="number">0</span>;</div><div class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++)&#123;</div><div class="line">            node z = node(i,b,c);</div><div class="line">            <span class="keyword">if</span>(z.ncmp(y)==<span class="number">1</span>)&#123;</div><div class="line">                win++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ans = max(ans,(<span class="keyword">double</span>)win/(<span class="keyword">double</span>)tot);</div><div class="line"></div><div class="line">        win = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++)&#123;</div><div class="line">            node z = node(a,i,c);</div><div class="line">            <span class="keyword">if</span>(z.ncmp(y)==<span class="number">1</span>)&#123;</div><div class="line">                win++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ans = max(ans,(<span class="keyword">double</span>)win/(<span class="keyword">double</span>)tot);</div><div class="line"></div><div class="line">        win = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++)&#123;</div><div class="line">            node z = node(a,b,i);</div><div class="line">            <span class="keyword">if</span>(z.ncmp(y)==<span class="number">1</span>)&#123;</div><div class="line">                win++;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        ans = max(ans,(<span class="keyword">double</span>)win/(<span class="keyword">double</span>)tot);</div><div class="line">       </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>, ans);      </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ACM组队安排"><a href="#ACM组队安排" class="headerlink" title="ACM组队安排"></a>ACM组队安排</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>n个人组队，每队人数可以为1或2或3，问组队的方案数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void dfs(int a, int b, int c)&#123;</div><div class="line">	//a为组队人数3的队伍数，b为组队人数2的队伍数，类推。。。</div><div class="line">	dfs(a,b+1,c-2) //取两个孤立的人组成一队2个人的</div><div class="line">	dfs(a+1,b-1,c-1) //取1个孤立的人和1队2人的组成1队3人的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了把所有状态都搜遍，我们从<code>dfs(0,0,n)</code>开始，按上述的搜索方法进行搜索，标记已经访问过的状态vis[a][b][c]。</p>
<p>然后对于某个状态<code>(a,b,c)</code>，求方案数用排列组合的思路搞搞就出来了。</p>
<p>例如<code>(1,2,1)</code>，方案数是<code>C(3,8)/1! * (C(2,5) * C(2,3))/2! * C(1,1)/1!</code>。具体就是，8个人挑3个人，5个人挑2个，3个人挑2个，剩下1个人, 各算出方案数，然后乘法原理乘一下就是的了。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">ll ans = <span class="number">0</span>;</div><div class="line">ll fact[<span class="number">11</span>];</div><div class="line"><span class="keyword">int</span> vis[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    fact[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)&#123;</div><div class="line">        fact[i] = fact[i<span class="number">-1</span>]*i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">ll <span class="title">c2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> n*(n<span class="number">-1</span>)/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">ll <span class="title">c3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">6</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</div><div class="line">    ll t = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> k = a*<span class="number">3</span>+b*<span class="number">2</span>+c;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)&#123;</div><div class="line">        t *= c3(k);</div><div class="line">        k -= <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(a)</div><div class="line">        t/=fact[a];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++)&#123;</div><div class="line">        t *= c2(k);</div><div class="line">        k -= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(b)</div><div class="line">        t/=fact[b];    </div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</div><div class="line">    vis[a][b][c] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;sum(a,b,c)&lt;&lt;endl;</span></div><div class="line">    ans += sum(a,b,c);</div><div class="line">    <span class="keyword">if</span>(c<span class="number">-2</span>&gt;=<span class="number">0</span> &amp;&amp; !vis[a][b+<span class="number">1</span>][c<span class="number">-2</span>])&#123;</div><div class="line">        dfs(a, b+<span class="number">1</span>, c<span class="number">-2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(b<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; c<span class="number">-1</span> &gt;=<span class="number">0</span> &amp;&amp; !vis[a+<span class="number">1</span>][b<span class="number">-1</span>][c<span class="number">-1</span>])&#123;</div><div class="line">        dfs(a+<span class="number">1</span>, b<span class="number">-1</span>, c<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    init();</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</div><div class="line">        ans = <span class="number">0</span>;</div><div class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</div><div class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,n);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="comment">// cout&lt;&lt;sum(1, 1, 0)&lt;&lt;endl;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>以上思路为错误方法~~~</strong>(虽然可以过这道题)。</p>
<p>在写的时候忽然发现这是一道<strong>很简单的dp</strong>…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f[i]=f[i-1];//第i个人自己组队</div><div class="line">f[i]+=f[i-2]*(i-1);//第i个人与前面i-1个人中的一个人组队，有i-1种方法，剩下的i-2个人进行组队，即f[i-2]种方法。</div><div class="line">f[i]+=f[i-3]*(i-1)*(i-2)/2;//前面的i-1个人中，挑2个人和第i个人组队(C(2,n-1)，剩余i-3个人组队(f(i-3))</div></pre></td></tr></table></figure>
<p>然后f[1]，f[2]，f[3]都告诉你了，然后你懂的了。。</p>
<p>所以大家还是按正确的方法写吧…ORZ~</p>
<h2 id="1006-逆袭指数"><a href="#1006-逆袭指数" class="headerlink" title="1006 逆袭指数"></a>1006 逆袭指数</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个数n，求n的最长的连续的因子，输出为<code>i*(i+1)*(i+2)...</code>。同时乘起来的因子还是n的因子。<br>如<code>630：5*6*7</code>，5*6*7=210是630的因子。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>直接上去暴力搞，枚举n的所有因子p，然后从p开始向后枚举，枚举到最长的时候就行。由于大多数因子连续都在前面的数里，所以复杂度不会很高。</p>
<p><strong>注意：</strong>从p向后枚举时要枚举到n为止而不是sqrt(n)。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fac;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="keyword">bool</span> vis[<span class="number">1000000</span>];</div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = n;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(t % i == <span class="number">0</span>)&#123;</div><div class="line">            t /= i;</div><div class="line">            vis[i] = <span class="literal">true</span>;</div><div class="line">            len++;</div><div class="line">            v.push_back(i);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len &gt; ans)&#123;</div><div class="line">        ans = len;</div><div class="line">        <span class="keyword">int</span> size = v.size();</div><div class="line">        path.clear();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++)</div><div class="line">            path.push_back(v[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n))&#123;</div><div class="line">        ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> size = fac.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)&#123;</div><div class="line">                dfs(i);</div><div class="line">        &#125;</div><div class="line">        size = path.size();</div><div class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>)&#123;</div><div class="line">            <span class="built_in">puts</span>(<span class="string">"1"</span>);</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(i &lt; ans<span class="number">-1</span>)</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="string">"*"</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="built_in">cout</span>&lt;&lt;path[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1007-油菜花王国"><a href="#1007-油菜花王国" class="headerlink" title="1007 油菜花王国"></a>1007 油菜花王国</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>现在有n个精力，输入他们的能力k[i]，如果k[i]是斐波那契数，那么他的威望值f[i]为1，反之为0.然后给了m个关系(u,v)表示u和v是同一个家族，家族的威望是他们的和。最后求威望最大的家族的威望。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>额，非常裸的<strong>并查集</strong>。</p>
<p>首先，斐波那契判断很方便，预处理一下存数组就行了。<strong>注意：不用快速幂什么的。。因为大概第45项就超过1000000000了。。</strong>，然后判断也就从前往后扫如果相等就返回。。反之随便搞搞。。</p>
<p>然后是并查集，直接上模板，记得合并<code>merge</code>操作的时候，把子节点的威望加到父节点上去。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line">ll fibo[<span class="number">50</span>];</div><div class="line"><span class="keyword">int</span> f[<span class="number">1050</span>];</div><div class="line"><span class="keyword">int</span> fa[<span class="number">1050</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    fibo[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    fibo[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">45</span>; i++)&#123;</div><div class="line">        fibo[i] = fibo[i<span class="number">-2</span>] + fibo[i<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">45</span>; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(n == fibo[i])</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(n &lt; fibo[i])</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(x != fa[x])</div><div class="line">        fa[x] = find(fa[x]);</div><div class="line">    <span class="keyword">return</span> fa[x];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a = find(x),b = find(y);</div><div class="line">    <span class="keyword">if</span>(a != b)&#123;</div><div class="line">        fa[b] = a;</div><div class="line">        f[a] += f[b];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    init();</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</div><div class="line">        <span class="keyword">int</span> u,v,t;</div><div class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">        <span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="keyword">sizeof</span>(fa));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)&#123;</div><div class="line">            fa[i] = i;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">            f[i] = check(t);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</div><div class="line">            merge(u,v);            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(f[i] &gt; ans)&#123;</div><div class="line">                ans = f[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>题目都很简单，大家最好在之后都去把没做出来的题目再做做，继续刷题！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下午大家在做题的时候我把后面几个题目写了写，写一个题解和大家分享。简单题大家自己讨论下，可能有什么坑的，自己细心点就行了。这里主要写一下&lt;code&gt;1003&lt;/code&gt;，&lt;code&gt;1005&lt;/code&gt;，&lt;code&gt;1006&lt;/code&gt;，&lt;code&gt;1007&lt;/code&gt;的题解。下午没怎么认真做，代码写的乱七八糟，大家见谅。&lt;/p&gt;
    
    </summary>
    
      <category term="算法题解" scheme="https://www.jetmuffin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="https://www.jetmuffin.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="记忆化搜索" scheme="https://www.jetmuffin.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
      <category term="模拟" scheme="https://www.jetmuffin.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mesos 调度机制及调度算法初探</title>
    <link href="https://www.jetmuffin.com/2015/11/23/Mesos-%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/"/>
    <id>https://www.jetmuffin.com/2015/11/23/Mesos-调度机制及调度算法初探/</id>
    <published>2015-11-23T12:59:17.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>再次分析Mesos的工作原理，将Mesos中出现的各个名词串联到一起。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核,Mesos将集群的所有节点的数据统一进行管理，打造一个DCOS(Data Center Operation System)的概念。调度算法是Mesos最核心也是灵魂部分。</p>
<h2 id="调度架构"><a href="#调度架构" class="headerlink" title="调度架构"></a>调度架构</h2><h3 id="1-两层架构"><a href="#1-两层架构" class="headerlink" title="1. 两层架构"></a>1. 两层架构</h3><p><strong>第一层，由Mesos将资源分配给框架；第二层，框架自己的调度器将资源分配给自己内部的任务。</strong>两层框架可以使得Mesos不需要知道任务的资源需求量，不需要知道任务的类型和数据存储，只需要和框架进行交互就行了。</p>
<h3 id="2-Resource-Offer"><a href="#2-Resource-Offer" class="headerlink" title="2. Resource Offer"></a>2. Resource Offer</h3><p>Mesos中的调度机制被称为<strong>“Resource Offer”</strong>，采用了基于资源量的调度机制。在Mesos中，Slave直接将资源量（CPU和内存）汇报给Master，由master将资源量按照某种机制分配给Framework，其中，“某种机制”是<code>“Dominant Resource Fairness（DRF）”</code>，在后面会提到该内容。</p>
<p>Framework可以根据是否符合任务对资源的约束，选择接受或拒绝<code>offer</code>。一旦<code>offer</code>被接受，Framework将与Master协作调度任务，并在数据中心的相应Slave节点上运行任务。</p>
<p>两个使<code>Resource Offer</code>高效且具有鲁棒性的附加机制：</p>
<ol>
<li><p><strong>filters机制：</strong> 每次调度，<code>mesos-master</code>和<code>framework-scheduler</code>需要进行通信，如果过多的拒绝<code>offer</code>会带来额外的通信开销，因此mesos提供了<code>filters</code>机制，允许Framework只接收<strong>资源量大于L的offer</strong>（换句话说被过滤的offer不会发送到Framework)</p>
</li>
<li><p><strong>rescinds机制：</strong> 如果某个Framework接受了某个<code>offer</code>，然而长时间没有为该<code>offer</code>分配任务，而占有该<code>offer</code>（占着xx不xx），Mesos会回收其<code>offer</code>，并将其分配给其他Framework</p>
</li>
</ol>
<h2 id="调度工作流程"><a href="#调度工作流程" class="headerlink" title="调度工作流程"></a>调度工作流程</h2><p><img src="/uploads/images/2015/11/23/mesos-workflow.png" alt="mesos-workflow"></p>
<p>如上图所示，整个资源调度的工作过程为：</p>
<ol>
<li><p><code>Slave</code>定期向<code>Master</code>汇报其机器上的资源情况（包括cpu,mem,disk,port等）。</p>
</li>
<li><p><code>Master</code>上的模块<code>Allocator</code>根据<code>DRF</code>算法决定要讲资源分配给哪个<code>Framework</code>，并将资源以<code>offer</code>形式发送给分配的<code>Framework</code>。（一层调度）</p>
</li>
<li><p><code>Framework</code>编写时约束了每个<code>Task</code>执行需要的资源（cpu,mem,disk等），Framework根据约束筛选分配到的<code>offer</code>，可以选择接受<code>offer</code>，或者拒绝<code>offer</code>。若拒绝，<code>offer</code>随即可以被给其他<code>Framework</code>。（二层调度）</p>
</li>
<li><p>每个<code>Task</code>对应一个<code>offer</code>，也对应一个<code>Slave</code>，则该<code>Task</code>会被该<code>Slave</code>上的守护进程<code>Executor</code>执行。同时，为了<strong>资源隔离</strong>，Mesos为任务的执行提供了<code>Isolator</code>隔离器，为了保证资源不会被其他<code>Task</code>访问，可用的Isolator有<code>Linux Container</code>，<code>Docker</code>等。</p>
</li>
<li><p>由于<code>Master</code>很有可能出现单点故障，因此需要设立多<code>Master</code>，利用<code>Zookeeper</code>容错，保证集群运行的一致性。</p>
</li>
</ol>
<p><strong>补充：</strong>Mesos提供了拓展模块，使得我们如果要修改Mesos的部分内容，可以不用修改源码重新编译，而在以上流程中的<code>Allocator（重写调度方法）</code>、<code>Isolator（重写资源隔离方法）</code>均可以进行拓展，此外我还发现了Slave上的<code>Estimator</code>也能进行重写拓展，具体内容之后补充。</p>
<h2 id="DRF算法"><a href="#DRF算法" class="headerlink" title="DRF算法"></a>DRF算法</h2><p>如何作出offer分配的决定是由资源分配模块<code>Allocator</code>实现的，该模块存在于Master之中。资源分配模块确定Framework接受offer的顺序，与此同时，确保在资源利用最大化的条件下公平地共享资源。</p>
<p>由于Mesos为跨数据中心调度资源并且是异构的资源需求时，资源分配相比普通调度将会更加困难。因此Mesos采用了<code>DRF（主导资源公平算法 Dominant Resource Fairness）</code>,该算法同样出自于UC Berkeley。DRF的目标是确保每一个用户，即Mesos中的Framework，在异质环境中能够接收到其最需资源的公平份额。</p>
<p>Framework拥有的全部资源类型份额中占最高百分比的就是Framework的<code>主导份额</code>。DRF算法会使用所有已注册的Framework来计算<code>主导份额</code>，以确保每个Framework能接收到其<code>主导资源</code>的<code>公平份额</code>。</p>
<p>Mesos源码中默认的Allocator，即<code>HierarchicalDRFAllocator</code>的位置在<code>$MESOS_HOME/src/master/allocator/mesos/hierarchical.hpp</code>，而DRF中对每个Framework排序的<code>Sorter</code>位于<code>$MESOS_HOME/src/master/allocator/sorter/drf/sorter.cpp</code>，可以查看其源码了解它的工作原理。</p>
<h3 id="一个说明性的例子"><a href="#一个说明性的例子" class="headerlink" title="一个说明性的例子"></a>一个说明性的例子</h3><p>考虑一个<code>9CPU，18GBRAM</code>的系统，拥有两个用户，其中用户A运行的任务的需求向量为<code>{1CPU, 4GB}</code>，用户B运行的任务的需求向量为<code>{3CPU，1GB}</code>，用户可以执行尽量多的任务来使用系统的资源。</p>
<p>在上述方案中，A的每个任务消耗总cpu的<code>1/9</code>和总内存的<code>2/9</code>，所以A的<strong>dominant resource</strong>是<code>内存</code>；B的每个任务消耗总cpu的<code>1/3</code>和总内存的<code>1/18</code>，所以B的<strong>dominant resource</strong>为<code>CPU</code>。DRF会均衡用户的<strong>dominant shares</strong>，执行3个用户A的任务，执行2个用户B的任务。三个用户A的任务总共消耗了{3CPU，12GB}，两个用户B的任务总共消耗了{6CPU，2GB}；在这个分配中，每一个用户的<strong>dominant share</strong>是相等的，用户A获得了2/3的RAM，而用户B获得了2/3的CPU。</p>
<p>以上的这个分配可以用如下方式计算出来：x和y分别是用户A和用户B的分配任务的数目，那么用户A消耗了{xCPU，4xGB}，用户B消耗了{3yCPU，yGB}，在图三中用户A和用户B消耗了同等dominant resource；用户A的dominant share为4x/18，用户B的dominant share为3y/9。所以DRF分配可以通过求解以下的优化问题来得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">max(x,y)            	#(Maximize allocations)</div><div class="line">	subject to</div><div class="line">		x + 3y &lt;= 9 		#(CPU constraint)</div><div class="line">		4x + y &lt;= 18 		#(Memory Constraint)</div><div class="line">			2x/9 = y/3 	#(Equalize dominant shares)</div></pre></td></tr></table></figure>
<p>最后解出<code>x=3</code>以及<code>y=2</code>，因而用户A获得{3CPU，12GB}，B得到{6CPU， 2GB}。</p>
<h3 id="DRF在Mesos中的一个例子"><a href="#DRF在Mesos中的一个例子" class="headerlink" title="DRF在Mesos中的一个例子"></a>DRF在Mesos中的一个例子</h3><p>换个使用场景，假设有数据中心包含一个offer为9核CPU和18GB内存。Framework 1运行的任务需要（1核CPU、4GB内存），Framework 2运行的任务需要（3核CPU、2GB内存）。Framework 1的任务会消耗CPU总数的1/9、内存总数的2/9，Framework 1的主导资源是内存。同样，Framework 2的每个任务会CPU总数的1/3、内存总数的1/18，Framework 2的主导资源是CPU。</p>
<p><img src="http://cdn3.infoqstatic.com/statics_s1_20151118-0143/resource/articles/analyse-mesos-part-04/zh/resources/0604003.jpg" alt="DRF-Table"></p>
<p>上面表中的每一行提供了以下信息：</p>
<ul>
<li><strong>Framework chosen：</strong>收到最新offer的Framework。</li>
<li><strong>Resource Shares：</strong>给定时间内Framework接受的资源总数，包括CPU和内存，以占资源总量的比例表示。</li>
<li><strong>Dominant Share（主导份额：</strong>给定时间内Framework主导资源占总份额的比例，以占资源总量的比例表示。</li>
<li><strong>Dominant Share %（主导份额百分比）：</strong>给定时间内Framework主导资源占总份额的百分比，以占资源总量的百分比表示。</li>
<li><strong>CPU Total Allocation：</strong>给定时间内接受的所有Framework的总CPU资源。</li>
<li><strong>RAM Total Allocation：</strong>给定时间内接受的所有Framework的总内存资源。</li>
</ul>
<p>最初，两个Framework的主导份额是0％，我们假设DRF首先选择的是Framework 2，当然我们也可以假设Framework 1，但是最终的结果是一样的。</p>
<ol>
<li>Framework 2接收offer并运行任务，使其主导资源成为CPU，主导份额增加至33％。</li>
<li>由于Framework 1的主导份额维持在0％，它接收offer并运行任务，主导份额的主导资源（内存）增加至22％。</li>
<li>由于Framework 1仍具有较低的主导份额，它接收offer并运行任务，增 加其主导份额至44％。</li>
<li>然后DRF将offer发送给Framework 2，因为它现在拥有更低的主导份额。</li>
<li>该过程继续进行，直到由于缺乏可用资源，不能运行新的任务。在这种情况下，CPU资源已经饱和。</li>
<li>然后该过程将使用一组新的offer重复进行。</li>
</ol>
<p><strong>需要注意的是</strong>：可以创建一个资源分配模块，使用加权的DRF使其偏向某个Framework或某组Framework。如前面所提到的，也可以创建一些自定义模块来提供组织特定的分配策略。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><ul>
<li>细粒度分配资源（细到每个任务在哪个机器上跑）,这是最显而易见的好处，也是Mesos社区和Mesosphere经常津津乐道的。</li>
</ul>
<p><img src="http://cdn2.infoqstatic.com/statics_s2_20151118-0143/resource/articles/analyse-mesos-part-02/zh/resources/mesos-elastic-cea4da90b3c819bd96b3158da1a6f86b.jpg" alt="Elastic Sharing"></p>
<ul>
<li>支持各类应用资源共同管理，不用担心各个应用的资源冲突。</li>
</ul>
<p><img src="http://cdn2.infoqstatic.com/statics_s2_20151118-0143/resource/articles/analyse-mesos-part-02/zh/resources/mesos_frameworks.png" alt="Mesos Frameworks"></p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>在众多文章中看到大家对Mesos缺陷评价的一些共同点:</p>
<ul>
<li><p>Mesos中的DRF调度算法过分的追求公平，没有考虑到实际的应用需求。</p>
</li>
<li><p>Mesos采用了Resource Offer机制，这种调度机制面临着资源碎片问题，即：每个节点上的资源不可能全部被分配完，剩下的一点可能不足以让任何任务运行，这样，便产生了类似于操作系统中的内存碎片问题。</p>
</li>
<li><p>由于Mesos采用了双层调度机制，在实际调度时，将面临设计决策问题：第一层和第二层调度器分别实现哪几个调度机制，即：将大部分调度机制放到第一层调度器，还是第一层调度器仅支持简单的资源分配</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再次分析Mesos的工作原理，将Mesos中出现的各个名词串联到一起。&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="资源调度" scheme="https://www.jetmuffin.com/tags/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"/>
    
      <category term="分布式系统" scheme="https://www.jetmuffin.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>给Mesos换一个新的WebUI</title>
    <link href="https://www.jetmuffin.com/2015/11/23/%E7%BB%99Mesos%E6%8D%A2%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84WebUI/"/>
    <id>https://www.jetmuffin.com/2015/11/23/给Mesos换一个新的WebUI/</id>
    <published>2015-11-23T10:29:00.000Z</published>
    <updated>2016-12-02T07:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然Mesos已经给用户提供了一个webui(<code>http://master:5050</code>)，然而这个UI无法很直观地显示集群的资源状况，因此可以给Mesos换一个更帅气的UI！</p>
<a id="more"></a>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>由于项目需要<code>nodejs</code>和<code>npm</code>环境，所以最好先配置好<code>nodejs</code>环境，最好<code>node</code>版本高于4.0，不然可能会出现错误。</p>
<p>然后是构建项目需要的<code>gulp</code>，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g gulp</div></pre></td></tr></table></figure>
<p>就可以了</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里使用的是<a href="https://github.com/Capgemini" target="_blank" rel="external">Capgemini</a> group写的开源UI，首先感谢一下作者们~</p>
<p>项目地址为<a href="https://github.com/Capgemini/mesos-ui" target="_blank" rel="external">Capgemini/mesos-ui</a></p>
<p>首先把整个项目clone下来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/Capgemini/mesos-ui mesos-ui</div></pre></td></tr></table></figure>
<p>然后安装相关的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd mesos-ui</div><div class="line">sudo npm install</div></pre></td></tr></table></figure>
<p>最后使用<code>gulp</code>对项目进行build就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp build</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Mesos配置web地址非常方便，只需要在启动Mesos时添加<code>webui_dir=your_webui_dir</code>就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --webui_dir=your_webui_dir</div></pre></td></tr></table></figure>
<p>如果你的Mesos是以service的形式存在（换句话说就是不用自己手动启），也可以这么搞<code>export MESOS_WEBUI_DIR=/your-path/mesos-ui/build/</code>，然后重启服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service mesos-master restart</div></pre></td></tr></table></figure>
<p>也就OK了</p>
<p>然后可以登陆<code>127.0.0.1:5050</code>去看看新UI了~</p>
<p><img src="/uploads/images/2015/11/23/mesos-ui.png" alt="mesos-ui"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然Mesos已经给用户提供了一个webui(&lt;code&gt;http://master:5050&lt;/code&gt;)，然而这个UI无法很直观地显示集群的资源状况，因此可以给Mesos换一个更帅气的UI！&lt;/p&gt;
    
    </summary>
    
      <category term="基础架构" scheme="https://www.jetmuffin.com/categories/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="mesos" scheme="https://www.jetmuffin.com/tags/mesos/"/>
    
      <category term="webui" scheme="https://www.jetmuffin.com/tags/webui/"/>
    
  </entry>
  
</feed>
