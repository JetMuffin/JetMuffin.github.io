{"pages":[{"title":"","permalink":"http://blog.jetmuffin.com/404.html","text":""},{"title":"关于 「我」","permalink":"http://blog.jetmuffin.com/about/index.html","text":"jetmuffin.com1234567891011&#123; \"nickname\": \"/JetMuffin/\", \"locality\": \"Nanjing\", \"school\": \"NJU\", \"skills\": [\"Cloud Computing\", \"Web Development\", \"Algorithm\",], \"tags\": [\"Geek?\", \"ACMer\"], \"contact\": &#123; \"email\": [\"jeffchen328@gmail.com\", \"564936642@qq.com\"] \"weibo\": \"@JetMmmmmmuffin\", &#125;,&#125; Links GitHub WeiBo NJU ICS NAP Group 欢迎留言！"},{"title":"映画","permalink":"http://blog.jetmuffin.com/gallery/index.html","text":""},{"title":"Categories","permalink":"http://blog.jetmuffin.com/categories/index.html","text":""},{"title":"guestbook","permalink":"http://blog.jetmuffin.com/guestbook/index.html","text":"念念不忘，必有回响 最近访客"},{"title":"友情链接","permalink":"http://blog.jetmuffin.com/links/index.html","text":"友人帐 Sloriac legend4917 BLKstone Innerac ying-zhang co2y"},{"title":"Tags","permalink":"http://blog.jetmuffin.com/tags/index.html","text":""}],"posts":[{"title":"使用Ansible进行服务器自动化运维","permalink":"http://blog.jetmuffin.com/2017/04/05/use-ansible-for-automatic-cluster-operation/","text":"ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。 测试环境Virtualbox &amp;&amp; Vagrant，安装 CentOS 7。用 Vagrant 自动分配 CPU、内存以及 IP。共两台虚拟机，一台为 master，一台为 slave，以模拟集群下环境。 IP: 192.168.32.10(master) 192.168.32.11(slave) 子网掩码：255.255.255.0 用户：root Ansible 脚本使用流程安装 AnsibleAnsible 可以直接通过 yum 的 epel 源进行安装。 12yum -y install epel-releaseyum -y install ansible 配置 ssh 无密码登陆Ansible 在集群的机器之间所有的操作都是基于 ssh 进行的，因此需要配置每台机器上 master 的无密码登陆。这里我们只要配置 slave 这台机器即可。 12ssh-keygen -t rsa -P \"\"ssh-copy-id slave 配置完 ssh-key 后尝试从 master 登录 slave，若不需密码则配置成功。 Ansible 脚本使用从 gitlab 上 clone Ansible 运维的 playbooks 至 master，playbooks 的目录层级如下： 123456789101112131415161718192021cd ics-cluster/ansibletree├── bin│ └── setup.sh├── firewall.yml├── group_vars│ └── all├── hosts├── keys.yml├── roles│ ├── authorized_keys│ ├── autofs│ ├── common│ ├── firewalld│ ├── nfs│ ├── nis│ ├── ntp│ └── user├── setup.retry├── setup.yml└── user.yml 其中根目录下的 yml 文件为指定功能的 playbook，运行方法为： 1ansible-playbook -i host xxx.yml 若需要对过程进行 debug，在命令后加上 -vvv 参数即可。 Playbook 编写编写 playbook 需要按照在单机上配置软件的过程，大体包括三个部分：安装软件、配置软件和启动服务。因此 package，template 和 service 是经常使用的三个模块。 根据具体需要部署的软件的部署流程，依次在 playbook 中写好每个阶段的任务。其中可能还会涉及到选择分支等高级用法，具体详询 Ansible Playbook Documents。 具体问题解决在配置集群环境以及编写 ansible playbooks 的过程中，会遇到非常多的坑，这里记录了一些可能会遇到的问题。 1. ansible 在某个节点 setup 阶段卡住Setup 阶段 ansible 主要收集机器节点的一些信息，而在这个阶段卡住原因可能出在文件系统（fs）和挂载点（mounts）上。因此登录到这个节点上使用 df 或者 mount 去人为检查文件系统是否出现问题。 2. 在 / 目录下 df 或 ls 卡住出现这种状况极有可能的原因是挂载点的问题。检查 /etc/fstab 中所有挂载点是否正常。如果在 /etc/fstab 中配置了自动挂载 nfs，那么如果 nfs-server 挂掉了，就会导致 nfs-client 上的 df 或 ls 卡住。 当然在这种状况下使用 umount /exports 也会卡住，需要使用 umount -l /exports 来解除挂载。 3. ypbind 服务无法启动配置 NIS 时，在 client 上启动 ypbind 服务时会出现启动超时的问题，主要的原因是 client 无法和 server 端通信。以下是两个排查的方向： 检查 server 端的防火墙配置（iptables 或 firewalld），打开 ypserv 和 yppasswdd 的端口 server 端在初次启动 ypserv 后需要对 yp 进行初始化，运行 ypinit -m 参考文档 Ansible Documentation 鸟哥的Linux 私房菜– NFS 服务器 Configure NIS Server Configure NIS Client"},{"title":"除法取模（逆元求法）总结","permalink":"http://blog.jetmuffin.com/2017/03/15/method-of-computing-inverse-of-number/","text":"最近刷的笔试题和以前打 ACM 中经常遇到求某个公式，最后的结果需要对某个数取模。我们都知道除法无法直接取模，即 $\\frac{a}{b} \\bmod c \\neq \\frac{a \\bmod c}{b \\bmod c} \\bmod c$（当然，$ a \\mid b $）。因此需要对 $b$ 求逆元，即 $\\frac{a}{b} \\bmod c = (a \\bmod c)*(b^{‘} \\bmod c) \\bmod c $ 。这里总结一下求逆元的方法。 定义对于正整数 $a$ 和 $m$，如果有 $ax \\equiv 1 \\pmod m$，那么把同余方程组里 $x$ 的最小正整数解称为 $a$ 模 $m$ 的逆元。 求法费马小定理前提：$a$ 与 $m$ 互质。 一般情况下题目会给小于 int 的最大素数 1e9+7，那么费马小定力就可以用了。 $$ a^{m-1} \\equiv 1 \\pmod m \\Rightarrow a \\cdot a^{m-2} \\equiv 1 \\pmod m \\Rightarrow a^{m-2} \\equiv \\frac{1}{a} \\pmod m $$ 那么逆元即为 $a^{m-2} \\bmod m$ 123456789101112131415const int mod = 1000000007;long long quick_pow(long long a, long long b) &#123; long long res = 1; while(b) &#123; if(b &amp; 1) &#123; res = a * res % mod; &#125; a = a * a % mod; a &gt;&gt;= 1; &#125; return res;&#125;long long inv(long long x) &#123; return quick_pow(a, mod - 2) % mod;&#125; 扩展欧几里得前提：$a$ 与 $m$ 互质 由逆元定义可知，给定模数 $m$，求 $a$ 的逆相当于求解 $ax \\equiv 1 \\pmod m$。方程可以转化为 $ax-my=1$。那么当 $gcd(a, m) = 1$ 时，可以通过扩展欧几里得算法算出解，再将算出的特解转化到 $[0,m−1]$ 即可。 1234567891011121314151617void ext_gcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123; if(b == 0) &#123; x = 1; y = 0; &#125; else &#123; ext_gcd(b, a % b, x, y); long long t; t = x; x = y; y = t - a / b * y; &#125;&#125;long long inv(long long x) &#123; long long now, t; ext_gcd(x, mod, now, t); return (now % mod + mod) % mod;&#125; 欧拉函数TBD"},{"title":"矩形计数 hihocoder 1476","permalink":"http://blog.jetmuffin.com/2017/03/05/counting-rectangle-hihocoder-1476/","text":"题目题目地址 http://hihocoder.com/problemset/problem/1476 如图所示， 给定的矩形中有 K 个单位正方形是黑色的，其余是白色的，求多少个不同的子矩形是完全由白色的正方形组成的。 思路直接算由白色正方形组成的不好计数，需要反向通过减去包含黑色方块的计算更方便。但是减去黑色方块时需要用容斥原理。即总矩形数减去包含 1 个黑色方格的矩形数，加上包含 2 个黑色方格的矩形数，减去包含 3 个黑色方格的矩形数……依次类推。 可以想到的是，对于 n m 大小的矩形，包含的所有子矩形的个数的 $\\binom{n}{2} \\binom{m}{2}$。 而包含 t 个黑色方格的矩形数，可以首先处理出所有这些黑色方格的范围的四条线，$x_1$，$x_2$， $y_1$，$y_2$，那么如果矩形要包括所有的黑格，它的上横线必然从 $[0, x_1]$ 取，下横线从 $[x_2, n]$ 取，那么横线的取法有 $\\binom{x_1}{1} \\binom{n - x_2 + 1}{1}$ 种，同理可得纵线取值，最后可以得到包含黑色方格的取法一共有 $x_1(n-x_2+1)y_1(m-y_2+1)$ 种。 最后通过容斥原理统计一遍即可。 代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst int maxn = 1010;const int inf = 0x3f3f3f;ll n, m, k;ll r[maxn], c[maxn];int main() &#123; while(~scanf(\"%lld%lld%lld\", &amp;n, &amp;m, &amp;k)) &#123; for(int i = 0; i &lt; k; i++) &#123; scanf(\"%lld%lld\", &amp;r[i], &amp;c[i]); &#125; ll ans = n * (n + 1) / 2 * m * (m + 1) / 2; for(int i = 1; i &lt; (1 &lt;&lt; k); i++) &#123; int num = __builtin_popcount(i); int x1 = inf, x2 = 0, y1 = inf, y2 = 0; for(int j = 0; j &lt; k; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; if(x1 &gt; r[j]) x1 = r[j]; if(x2 &lt; r[j]) x2 = r[j]; if(y1 &gt; c[j]) y1 = c[j]; if(y2 &lt; c[j]) y2 = c[j]; &#125; &#125; if(num % 2 == 0) ans += x1 * y1 * (n - x2 + 1) * (m - y2 + 1); else ans -= x1 * y1 * (n - x2 + 1) * (m - y2 + 1); &#125; printf(\"%lld\\n\", ans); &#125;&#125;"},{"title":"Counting Hamming Numbers","permalink":"http://blog.jetmuffin.com/2017/02/18/Counting-Hamming-Numbers/","text":"Hamming Number 是一类特殊的数，他们的因数仅为2，3，5 中的任意组合。形式化地说即： $$x = 2^i \\times 3^j \\times 5^k, i,j,k \\geq 0, \\forall x \\in H$$ 求解若要求解 Hamming Number，第一反应是使用一个最小堆来维护整个数列，不断从堆里取出最小的数 top，再往堆里放入 2*top，3*top，5*top，同时对拿出来的数进行去重，整个计算的复杂度是 O(logn) 的。 大概的解决代码如下： 12345678910111213141516171819long countHammingNumber(long n) &#123; priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt; &gt; q; long peak = 1; q.push(2); q.push(3); q.push(5); for(int i = 1; i &lt; n; i++) &#123; peak = q.top(); q.pop(); if(!q.empty()) &#123; while(q.top() == peak) &#123; q.pop(); &#125; &#125; q.push(peak * 2); q.push(peak * 3); q.push(peak * 5); &#125;&#125; 通过这样处理，最小堆每次取出的数放进一个数组里则这个数组里就全是 Hamming Number 了。 然而这样的处理比较耗时，再仔细分析 Hamming Number 的由来可以想到： x（Hamming Number） 的因数仅存在 2、3、5，那么只要 count 2、3、5 的个数即可了。列一个表可以表示为： n-th 5 3 2 value 1 0 0 0 1 2 0 0 1 2 3 0 1 0 3 4 0 0 2 4 5 1 0 0 5 6 0 1 1 6 7 0 0 3 8 … … … … … 从表中可以看出 Hamming Number 的递推过程存在一定规律，可以用 dp 的思路去解决，大体可以表示成： 1dp[i] = min(dp[j]*2, dp[k]*3, dp[l]*5) 即我们维护上表中的 5、3、2 因子为 j、k、l，那么当计算某个 n-th 即 i 时，dp[i] 就通过上式子递推得出。这样求解的话复杂度为 O(n) 代码大致如下： 123456789101112int countHammingNumber(int n) &#123; int dp[1690]; int j = 1, k = 1, l = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; dp[i] = min(2 * dp[j], min(3 * dp[k], 5 * dp[l])); if(dp[i] == 2 * dp[j]) j++; if(dp[i] == 3 * dp[k]) k++; if(dp[i] == 5 * dp[l]) l++; &#125; return dp[n];&#125; 题目 Ugly Number Ugly Number II"},{"title":"集群调度架构的发展","permalink":"http://blog.jetmuffin.com/2017/01/02/The-evoolution-of-cluster-scheduler-architectures/","text":"文章翻译自《The evolution of cluster scheduler architectures》，原作者为 Cambridge 的 Sys@Scale 实验室。 集群调度器作为当今基础设施架构中重要的组件，在近几年中发展非常迅速。它们的结构从整体化的设计逐渐松散化，分布式化，变得更为灵活。然而，许多现在的开源实现要么仍然采用整体化设计，要么缺少重要的功能，而这些功能则正是关系到现实世界的用户所关心的问题，即他们要求实现的高利用。 这篇文章是我们撰写的一个系列中的第一篇。这个系列阐述关于如何在大型集群调度任务，像那些互联网公司如 Amazon，Google，Facebook，Microsoft，Yahoo!等所在生产实践中所做的那样。调度是一个重要的主题，因为它直接影响着操作一个集群的代价。例如一个差的调度器会导致集群的使用率低下，这就意味着昂贵的服务器大部分在空闲着，必然造成经济上的损失。然而集群高使用率不仅仅是针对单个任务而言，因为任务之间往往会相互影响，这也就要求调度器在决策上更加地细致，小心。 架构发展这篇文章讨论调度器的结构在近几年来是如何发展的，以及为什么这么发展。如图一所示，当前的调度器主要有以下几种不同的调度模式。其中灰色的正方形表示机器节点，彩色的圆形表示任务，而带有“S”的圆角矩形则代表调度器。箭头显示了调度器的调度决策，而三种不同的颜色（红黄蓝）则表示了不同的任务类型（例如 web 服务，批处理分析以及机器学习任务）。 中央调度架构许多集群调度器是中央调度架构的，例如大多数的高性能计算中的调度器，Borg 调度器，一些早期的 Hadoop 中的调度器以及现在 Kubernetes 中的调度器。这种模式会在集群的某台机器上允许一个单独的调度进程（例如 Hadoop v1 中的 JobTracker 和 Kubernetes 中的 kube-scheduler），而这个调度进程负责分配任务到每台机器节点上。所有任务都是由一个调度器处理，也就是说所有的任务均是由一个调度逻辑进行分配的（如图 1a 所示）。这种架构简单一致，在许多越来越复杂的调度器中采用。例如 Paragon 和 Quasar，使用机器学习的方法来防止任务之间的资源竞争的调度器，也使用了这种调度模式。 相比于早些时候的 Hadoop 上的 MapReduce 任务，当前的集群允许的应用种类越来越多，不再针对单一的任务。然而，维护一个中央调度器来处理多类型混合任务是相当棘手的，原因有以下几点： 很明显调度器在应该用不同方式处理长时间服务作业（Long-running service jobs）和批处理作业（batch jobs）。 不同的应用有不同的需求，需要满足他们所有的需求相当于不断在调度器上增加功能，这也使得调度器的逻辑和实现越来越复杂。 调度器处理任务的顺序也会成为一个问题，队列的影响（例如 head-of-line blocking）和任务存储将难以处理，除非调度器是精心设计的。 总之，这些问题将造成工程上的噩梦，调度器的维护者将收到源源不断的功能需求而没法实现它。 两层调度架构两层调度架构通过分离资源分配和任务调度这两部分来解决了这个问题。它上层允许针对不同的应用定制不同的任务分配逻辑，同时维持他们共用集群的能力。Mesos最先使用了这种架构，YARN也在某个版本之后开始支持。在 Mesos 中，底层资源管理器将资源以 offer 的形式提供给应用级的调度器，这些调度器可以在其中选择适合的 offer 并使用它来运行任务。而 YARN 中则允许应用级的调度器向底层资源管理器请求资源。图 1b 显示了这种架构模式：针对任务定制的调度器（S0-S2）和资源管理器进行交互，动态地对资源进行分片，分配给各个任务。总体而言，这是一种灵活的，允许根据任务类型进行定制的架构模式。 但是，两层调度框架分层的思想也存在着缺陷。应用层的调度器无法获得上帝视角，例如他们无法看到所有可能的调度选项。相反，他们仅仅能够看到通过资源管理器提供的资源对应的调度选项。这就存在着一些缺点： 优先级将难以实现：在基于 offer 的调度模型（Mesos）中，上层调度器无法看到分配给正在运行的任务的资源；在基于请求（YARN）的调度模型中，底层的资源管理器必须知道优先级策略（这和两层调度模式相矛盾）。 因为调度器无法看到所有的资源，它无法确认运行任务是否会影响降低资源的质量。 根据应用定制的调度器可能需要关注来自下层的资源中的许多不同的方面的信息，而他们仅仅能通过和底层资源管理器的接口获知这些内容，这也就导致这些接口可能会变得十分复杂。 共享状态架构共享状态架构采用了一种半分布式的模型来解决上述的这些问题。在这个架构中，每个应用层的调度器相互独立地更新集群状态的多个副本，如图 1c 中所示。在这些变化在本地进行以后，调度器会进行启动一个乐观一致的事物去更新共享集群状态。当然这个事物也会失败，不同的调度器在同一时间进行了进行的变动可能会存在矛盾。 共享状态架构最典型的设计例子就是 Google 的 Omega 了，其次就是微软的 Apollo，以及 Hashicorp 的 [Nomad] 容器调度器。这些调度器都是将集群的共享状态储存在单个位置上，例如 Omega 中的 cell state，Apollo 中的 resource monitor 以及 Nomad 中的 plan queue。区别于其他两个调度框架，Apollo 中共享状态是只读的，同时调度事务是直接通过集群机器提交的。这些机器会自己确认是否存在矛盾，以及接受和拒绝这些变动。这也使得 Apollo 在集群共享状态暂时不可访问时也能短暂工作。 逻辑上的共享状态架构设计允许不在整个集群上实现完全的状态共享。在这种设计中（类似 Apollo 的设计），每台机器维护它自己的状态，发送要更新的状态到不同的 agent 上，例如调度器，机器的健康监控器，以及资源监控系统。每台机器局部的共享状态构成了整个集群的全局共享状态。 然而共享状态架构同样也有缺陷。和中央调度不同的是，共享状态总是处理着旧的集群状态信息，而不是实时的信息。这可能在高并发的场景下会降低调度器的性能。 完全分布式架构完全分布式架构则将结构分解的更加彻底，如图 1d 所示，它甚至在调度器中没有协调者，仅仅是使用各个独立的调度器来对任务提供调度服务。这种架构中，每个调度器只是处理它本地的，部分的，常常过时的集群信息。作业可以提交到任意的调度器上，每个调度器可以调配任务到集群中的任意一个位置。和两层调度架构不同的是，它的调度器不负责对集群资源进行分片。相反，所有的调度和资源分片是任务在统计学上的多元性和随机性以及调度器的决策形成的结果。 虽然在之前有关于相关概念（利用多元随机决策）在1996年发表，最近的关于完全分布式架构的调度器的文章大概是从 Sparrow 的文章开始的。Sparrow 的主要前提是基于一个假设，即我们在集群中运行的任务在执行时间上在不断缩短，因为任务的划分粒度变得更加细粒度了。因此，作者假设瞬时任务数量变得更加庞大，这也就意味着调度器的决策吞吐量将会变得很大。而单个调度器可能支撑不了这么大的吞吐量（可能达到每秒百万个任务），Sparrow 想要将负载分配到多个调度器上。 这可能带来一些完美的作用，从概念上可以显示省去了中央的控制，同时它非常满足一些任务的需求——在之后的文章中会提到。在这里，以下一些原因足以显示这种分布式的，无中心协调的调度模式，在逻辑上相比比中央控制的，两层调度的，或共享状态的调度器，过于简单。例如： 分布式的调度器通常基于简单的 &quot;slot&quot; 概念，把每台机器细分成 n 个一致的 slot，在其中运行 n 个并行的任务。这简化了任务的资源需求不一致的问题，然而在现实中这个不一致的问题是存在的。 它同样会在 worker 上使用一些特定的队列（例如 Sparrow 中的 FIFO），这会限制调度的灵活性，因为这种架构下的调度器只能从集群中选择一台机器来讲一个任务入队。 因为分布式调度器没有中心控制，它在使用全局约束上回存在问题（例如要求公平性策略或者严格的优先级顺序时） 由于它是为了基于最少的信息来做快速的决策而设计的，分布式调度器难以支持复杂的或者应用指定的调度策略。换言之，这种调度目前能架构处理的任务相对比较简单。例如对相互影响的任务它在处理上将会十分棘手。 混合式架构最近在学术上提出了混合式架构，为了解决完全分布式架构的问题，它将中央调度和共享状态调度设计相结合。它的工作方式是，将所有任务通过两种途径进行调度，对于短任务和低优先级批处理任务通过分布式调度来进行分配，而其他的任务则通过中央调度来分配，例如 Tarcil，Mercury 和 Hawk，图 1e 显示了这种设计模式的工作原理。这种设计的好处是，混合调度器混用了上述几种调度架构模式来避免各自的缺点。但据笔者所知，目前没有这种调度器用于生产实践中。 在实践中的结果讨论不同调度架构之间相对的优缺点不仅仅是学术上的话题，同样需要在工业界生产实践中去考虑考虑诸如 Borg，Mesos 和 Omega 之类的文章。更进一步的是，许多上面讨论到的系统已经在许多大企业中投入生产使用，例如微软的 Apollo，谷歌的 Borg 和 Apple 的 Mesos，它们同样启示其他的系统可能作为开源项目在生产中使用也是可行的。 最近几年，许多集群允许容器华的任务，导致了许多不同的基于容器的“编排框架”开始出现。这也和谷歌以及其他公司声称的“集群管理者”相类似。然而，集群调度器上仍然有许多细节需要讨论，例如他们的设计原则，他们关注的调度 API等。更重要的是，许多用户既不知道调度器架构起到什么作用，也不知道这些调度器适合哪些应用。 图 2 显示了一系列开源的编排框架的概况，以及它们的架构和它们的调度器支持的功能。在表格的最底部，我们同样引用了谷歌和微软的非开源的系统。Resource granularity 这一列表示资源使用固定的 slots，还是用多维的形式分配资源。 其中一个帮助你确定调度框架是否合适的重要方面是你的集群是否允许不同的任务。例如在同一个集群中既有前端服务（负载均衡 web server 和 memcached）以及数据批处理分析（例如 MapReduce 或者 Spark）。在同一个集群上运行这两类任务可以提高该集群的使用率，但是不同的应用可能有不同的调度需求。在这种情况下，中央调度的调度器可能导致一个局部最优的调度结果，因为它在逻辑上无法做到根据每个任务进行的多样性调度。而两层调度和共享状态调度可能就更加适合一些。 大多数用户面对的服务任务是用服务时的峰值需求来设定的资源分配量的，但是在实际中通常这些服务的资源使用率是低于他们的分配需求。在这种情况下，能够适当的超售资源给低优先级的任务（同时保证服务的 QoS）是集群效率的关键。Mesos 是当前的开源系统中唯一支持资源超售的，而 Kubernetes 则是把它作为一个长远的目标。我们应该更加关注这个方面，因为根据谷歌 Borg 的报告指出，大多数集群的使用率仍然是低于 60-70% 的。我们将在未来的这个系列的文章中更加关注资源评估，资源超配和高效的机器使用率。 最后，特定的分析和 OLAP 风格的应用（例如 Dremel 或 SparkSQL queries）适用于完全分布式调度器。然而，完全分布式调度器（例如 Sparrow）受到一系列的约束，而在任务相同时工作效果最好。我们会在之后的文章中更加详细地解释完全分布式调度器和混合调度器中的分布式组件部分的内容。而现在足以说明从观察的结果看出，这种架构在调度策略上过于简单，以致于没法支持多类资源类型，资源超售和资源重分配等功能。 总体的说，从图 2 的表格中可以看出目前的开源调度框架还有很多的功能需要去支持和改进。这应该成为一个行动号召，解决这些框架中缺少的功能，低下的使用率，不可预测的任务性能等问题。 然而，一个好消息是，许多框架采用中央调度模式的调度框架正在往更加灵活的设计上发展。Kubernetes 已经支持了可插件化的调度器（kube-scheduler pod 可以被其他兼容 API 的调度器 pod 替代），从 v1.2 开始支持多调度器，以及正在开发的支持用户自定义的调度策略等。Docker Swarm 在未来可能同样会变得可插件化。 下回预告本系列的下篇文章会关注完全分布式架构的主要问题。同时，我们会关注 resource-fitting 策略，以及最后讨论为什么我们的 Firmament scheduling 平台综合了其他调度架构所有的优点。 参考文献 Verma A, Pedrosa L, Korupolu M, et al. Large-scale cluster management at Google with Borg[C]//Proceedings of the Tenth European Conference on Computer Systems. ACM, 2015: 18. Hindman B, Konwinski A, Zaharia M, et al. Mesos: A Platform for Fine-Grained Resource Sharing in the Data Center[C]//NSDI. 2011, 11: 22-22. Vavilapalli V K, Murthy A C, Douglas C, et al. Apache hadoop yarn: Yet another resource negotiator[C]//Proceedings of the 4th annual Symposium on Cloud Computing. ACM, 2013: 5. Boutin E, Ekanayake J, Lin W, et al. Apollo: scalable and coordinated scheduling for cloud-scale computing[C]//11th USENIX Symposium on Operating Systems Design and Implementation (OSDI 14). 2014: 285-300. Schwarzkopf M, Konwinski A, Abd-El-Malek M, et al. Omega: flexible, scalable schedulers for large compute clusters[C]//Proceedings of the 8th ACM European Conference on Computer Systems. ACM, 2013: 351-364. Ousterhout K, Wendell P, Zaharia M, et al. Sparrow: distributed, low latency scheduling[C]//Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles. ACM, 2013: 69-84. Delimitrou C, Kozyrakis C. Paragon: QoS-aware scheduling for heterogeneous datacenters[C]//ACM SIGPLAN Notices. ACM, 2013, 48(4): 77-88. Delimitrou C, Kozyrakis C. Quasar: resource-efficient and QoS-aware cluster management[C]//ACM SIGPLAN Notices. ACM, 2014, 49(4): 127-144. Delimitrou C, Sanchez D, Kozyrakis C. Tarcil: Reconciling scheduling speed and quality in large shared clusters[C]//Proceedings of the Sixth ACM Symposium on Cloud Computing. ACM, 2015: 97-110. Delgado P, Dinu F, Kermarrec A M, et al. Hawk: Hybrid datacenter scheduling[C]//2015 USENIX Annual Technical Conference (USENIX ATC 15). 2015: 499-510. Karanasos K, Rao S, Curino C, et al. Mercury: Hybrid centralized and distributed scheduling in large shared clusters[C]//2015 USENIX Annual Technical Conference (USENIX ATC"},{"title":"kubernetes源码阅读 - storage part 1 - cache","permalink":"http://blog.jetmuffin.com/2016/12/04/kubernetes-code-reading-storage-part-1-cache/","text":"kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 Storage，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？ 123456789101112// pkg/client/cache/fifo.gotype Queue interface &#123; Store // Queue事实上也是一种Storage，而在FIFOQueue中具体对Add,List,Delete等方法进行了重写 Pop(PopProcessFunc) (interface&#123;&#125;, error) AddIfNotPresent(interface&#123;&#125;) error // Return true if the first batch of items has been popped HasSynced() bool&#125; Cache在 pkg/client/cache 包里实现了 cache 的一些基本结构，其中最核心的，也是最顶层的结构是 Store 接口： 1234567891011121314151617// pkg/client/cache/store.gotype Store interface &#123; Add(obj interface&#123;&#125;) error // 增 Update(obj interface&#123;&#125;) error // 改 Delete(obj interface&#123;&#125;) error // 删 List() []interface&#123;&#125; // 列举 ListKeys() []string // 列举 key Get(obj interface&#123;&#125;) (item interface&#123;&#125;, exists bool, err error) // 查 GetByKey(key string) (item interface&#123;&#125;, exists bool, err error) // 按key查 // Replace will delete the contents of the store, using instead the // given list. Store takes ownership of the list, you should not reference // it after calling this function. Replace([]interface&#123;&#125;, string) error // 替换 Resync() error // 同步&#125; Store 接口定义了 cache 中的所有数据类型的最通用的一层抽象，包括对 cache 存储的增删改查列举等操作。Store 具体的接口实现包括前面提到的 FIFO，DeltaFIFO，以及后面会提到的 ThreadSafeStore，UnDeltaStore 和 ExpirationCache。 ThreadSafeStoreThreadSafeStore 是 k8s 中用的最多，也是默认的 cache 存储。它允许对数据并行的访问，同时使用加锁的机制保证数据在多线程中是线程安全的。 1234567891011// pkg/client/cache/thread_safe_store.gotype threadSafeMap struct &#123; lock sync.RWMutex // 锁 items map[string]interface&#123;&#125; // 存储数据的map // indexers maps a name to an IndexFunc indexers Indexers // 存储Indexer的map // indices maps a name to an Index indices Indices // 存储Index的map&#125; ThreadSafeStore 的实现上也比较简单，数据放在 map 的数据结构里，同时使用 sync.RWMutex 对这个 map 的 Add，Update，Delete，Get 等操作加读锁和写锁。此外，它还允许对同一作用的 items 加一个共同的索引方便直接获取，而这个索引放在 indices 里，获得索引的函数放在 indexers 里。 1234567891011121314151617181920212223242526272829303132// pkg/client/cache/thread_safe_store.gofunc (c *threadSafeMap) Index(indexName string, obj interface&#123;&#125;) ([]interface&#123;&#125;, error) &#123; c.lock.RLock() defer c.lock.RUnlock() indexFunc := c.indexers[indexName] // 通过给的索引名称拿到索引函数 if indexFunc == nil &#123; return nil, fmt.Errorf(\"Index with name %s does not exist\", indexName) &#125; indexKeys, err := indexFunc(obj) // 用索引函数拿到索引的keys if err != nil &#123; return nil, err &#125; index := c.indices[indexName] // need to de-dupe the return list. Since multiple keys are allowed, this can happen. returnKeySet := sets.String&#123;&#125; for _, indexKey := range indexKeys &#123; // 对索引的keys进行去重 set := index[indexKey] for _, key := range set.UnsortedList() &#123; returnKeySet.Insert(key) &#125; &#125; list := make([]interface&#123;&#125;, 0, returnKeySet.Len()) for absoluteKey := range returnKeySet &#123; list = append(list, c.items[absoluteKey]) // 根据keys拿到实际的items放到list里 &#125; return list, nil&#125; UndeltaStoreUndeltaStore 在 Store 上做了一层封装，在实例化时传入了一个回调函数 PushFunc，每当 Store 进行了 Add，Update，Delete 等操作，会调用 PushFunc 来告知这个数据的操作已经完成，可以进行后续的工作。 123456789// pkg/client/cache/undelta_store.gofunc (u *UndeltaStore) Add(obj interface&#123;&#125;) error &#123; if err := u.Store.Add(obj); err != nil &#123; return err &#125; u.PushFunc(u.Store.List()) return nil&#125; 在实现上其实也很简单，在每个操作的最后调用一次传入的 PushFunc()。 ExpirationCacheExpirationCache 同样是对 Store 做了一层的封装，和 UndeltaStore 不同的是它是在 ThreadSafeStore 上进行的封装，实现了带过期期限的 cache 功能。 1234567891011// pkg/client/cache/expiration_cache.gotype ExpirationCache struct &#123; cacheStorage ThreadSafeStore // 实际存储的storage keyFunc KeyFunc clock clock.Clock // 标记创建时间的时间戳 expirationPolicy ExpirationPolicy // 失效策略 // expirationLock is a write lock used to guarantee that we don't clobber // newly inserted objects because of a stale expiration timestamp comparison expirationLock sync.Mutex // 失效检查的锁&#125; 当 ExpirationCache 中的每个 item 被创建的时候会为其打上时间戳，而这个 item 在查询的时候会检查这个时间戳到目前的时间间隔是否超过了失效的阈值，若超过了则返回 nil 并把这个 item 从 map 里删掉。（这里相当于做了一个 lazy 操作，如果 item 失效了但是一直没有查询，那么它会一直在 map 里待着）。 默认使用的失效策略比较简单，就是给定一个时间范围阈值 TTL(TimeToLive)，然后判断这个时间戳到现在的时间距离是否大于这个阈值。 12345678910111213// pkg/client/cache/expiration_cache.gotype TTLPolicy struct &#123; // &gt;0: Expire entries with an age &gt; ttl // &lt;=0: Don't expire any entry Ttl time.Duration // 过期阈值 // Clock used to calculate ttl expiration Clock clock.Clock&#125;func (p *TTLPolicy) IsExpired(obj *timestampedEntry) bool &#123; return p.Ttl &gt; 0 &amp;&amp; p.Clock.Since(obj.timestamp) &gt; p.Ttl // 判断是否失效（间隔是否大于TTL）&#125; 相比于 ThreadSafeStore，ExpirationCache 在使用时还需要检查 item 是不是失效了，而这个检查的过程也是加锁的，而我们知道 ThreadSafeStore 自身本来就是带锁的操作的，所以它的操作会比 ThreadSafeStore 慢一些。 Others除了上面提到的几种 cache 中用到的数据结构外，cache 包里还提供了一些其他的类来进行辅助工作： Indexer（pkg/client/cache/index.go）允许用多种方法对 items 进行过滤（索引） Lister（pkg/client/cache/lister.go）提供了各种列举 items 的方法 MutationDetection（pkg/client/cache/mutation_dectector.go）检测某个 item 是否发生变化了 … Reflectorcache 包里的各个类定义了不同场景下 k8s 使用的数据结构，我们也知道 k8s 里实际存储 pods 等资源是放在 ThreadSafeStore 里的，那么 k8s 是如何将 APIServer 里的 RESTful API 和 cache 相联系起来的呢？ 在 pkg/client/cache/reflector.go 里，k8s 提供了一种叫做 Reflector 的类，用于作为 APIServer 和 cache 之间的桥梁。对每一类 Resource 为它创建一个从 RESTful Resource 到 cache item 的 Reflector。 12345678910111213141516171819202122232425// pkg/client/cache/reflector.gotype Reflector struct &#123; // name identifies this reflector. By default it will be a file:line if possible. name string // The type of object we expect to place in the store. expectedType reflect.Type // item的类型 // The destination to sync up with the watch source store Store // item 的实际存储 // listerWatcher is used to perform lists and watches. listerWatcher ListerWatcher // 用于监听item变化的watcher // period controls timing between one watch ending and // the beginning of the next one. period time.Duration //watch的间隔 resyncPeriod time.Duration // now() returns current time - exposed for testing purposes now func() time.Time // lastSyncResourceVersion is the resource version token last // observed when doing a sync with the underlying store // it is thread safe, but not synchronized with the underlying store lastSyncResourceVersion string // lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion lastSyncResourceVersionMutex sync.RWMutex&#125; Reflector 有两种允许方式： Run() RunUntil(stopCh &lt;-chan struct{}) 两者的区别在于后者传入了一个 stopCh，当收到停止信号会停止这个 Run() 方法，而前者则是 Run forever 的。而两者的方法的主题都是一致的，都在启动了一个 goroutine 去一直执行 ListAndWatch() 方法。 123456789// pkg/client/cache/reflector.gofunc (r *Reflector) Run() &#123; glog.V(3).Infof(\"Starting reflector %v (%s) from %s\", r.expectedType, r.resyncPeriod, r.name) go wait.Until(func() &#123; if err := r.ListAndWatch(wait.NeverStop); err != nil &#123; // 一直执行ListAndWatch utilruntime.HandleError(err) &#125; &#125;, r.period, wait.NeverStop)&#125; 那么来看一看这个 ListAndWatch() 是做什么的： 1234567891011121314151617181920212223242526272829303132333435// pkg/client/cache/reflector.go//...w, err := r.listerWatcher.Watch(options) // 获得一个watch.Interfaceif err != nil &#123; switch err &#123; case io.EOF: // watch closed normally case io.ErrUnexpectedEOF: glog.V(1).Infof(\"%s: Watch for %v closed with unexpected EOF: %v\", r.name, r.expectedType, err) default: utilruntime.HandleError(fmt.Errorf(\"%s: Failed to watch %v: %v\", r.name, r.expectedType, err)) &#125; // If this is \"connection refused\" error, it means that most likely apiserver is not responsive. // It doesn't make sense to re-list all objects because most likely we will be able to restart // watch where we ended. // If that's the case wait and resend watch request. if urlError, ok := err.(*url.Error); ok &#123; if opError, ok := urlError.Err.(*net.OpError); ok &#123; if errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123; time.Sleep(time.Second) continue &#125; &#125; &#125; return nil&#125;if err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != nil &#123; // 处理这个 watch.Interface if err != errorStopRequested &#123; glog.Warningf(\"%s: watch of %v ended with: %v\", r.name, r.expectedType, err) &#125; return nil&#125;//... 在 ListAndWatch() 中前面先开了一个独立的 goroutine 去同步 Store 这里就不细说了。核心的内容在后面，首先是 r.listerWatcher.Watch(options) 获取到一个 watch.Interface 对象，然后对这个对象进行处理，即 r.watchHandler()。 首先看这个 watch.Interface，寻找引用它的路径可以按着 pkg/client/cache/listwatch.go: ListerWatcher.Watch() -&gt; pkg/client/cache/listwatch.go: ListWatch.WatchFunc -&gt; pkg/client/cache/listwatch.go: NewListWatchFromClient() 的一个思路去看。 那么最终关注这个 NewListWatchFromClient() 方法，它事实上就是连接着 API 的那一头，传入了 API 的一个 Resource，而 ListerWatcher 的 Watch() 方法就是这个 Resource 中的 Watch() 方法。具体实例化是在每个资源的包中，例如 pkg/kubelet/config/apiserver.go 中： 123456// pkg/kubelet/config/apiserver.gofunc NewSourceApiserver(c *clientset.Clientset, nodeName types.NodeName, updates chan&lt;- interface&#123;&#125;) &#123; lw := cache.NewListWatchFromClient(c.Core().RESTClient(), \"pods\", v1.NamespaceAll, fields.OneTermEqualSelector(api.PodHostField, string(nodeName))) newSourceApiserverFromLW(lw, updates)&#125; 这里为 pods 创建了一个 RESTClient，同时用这个 Client 作为参数创建一个 ListWatcher，ListAndWatch 中的 Watch 方法就是 Client 中的 Watch 方法。 那么搞清楚了这一头了以后看一看检测到变化以后 Reflector 是怎么处理的。在 ListAndWatch 方法中还有一个重要的方法 watchHandler() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// pkg/client/cache/reflector.gofunc (r *Reflector) watchHandler(w watch.Interface, resourceVersion *string, errc chan error, stopCh &lt;-chan struct&#123;&#125;) error &#123; //... for &#123; select &#123; case &lt;-stopCh: return errorStopRequested case err := &lt;-errc: return err case event, ok := &lt;-w.ResultChan(): // 从ResultChan中拿出一个event if !ok &#123; break loop &#125; if event.Type == watch.Error &#123; return apierrs.FromObject(event.Object) &#125; if e, a := r.expectedType, reflect.TypeOf(event.Object); e != nil &amp;&amp; e != a &#123; utilruntime.HandleError(fmt.Errorf(\"%s: expected type %v, but watch event object had type %v\", r.name, e, a)) continue &#125; meta, err := meta.Accessor(event.Object) //用event.Object获取meta信息 if err != nil &#123; utilruntime.HandleError(fmt.Errorf(\"%s: unable to understand watch event %#v\", r.name, event)) continue &#125; newResourceVersion := meta.GetResourceVersion() switch event.Type &#123; // 根据event的不同类型对cache做不同处理 case watch.Added: r.store.Add(event.Object) case watch.Modified: r.store.Update(event.Object) case watch.Deleted: // TODO: Will any consumers need access to the \"last known // state\", which is passed in event.Object? If so, may need // to change this. r.store.Delete(event.Object) default: utilruntime.HandleError(fmt.Errorf(\"%s: unable to understand watch event %#v\", r.name, event)) &#125; *resourceVersion = newResourceVersion r.setLastSyncResourceVersion(newResourceVersion) eventCount++ &#125; &#125; //...&#125; watchHandler() 的核心是这个 loop，Reflector 会从 watch.Interface 中拿到一个叫做 ResultChan 的 chanel，watch.Interface 在 API 的那一头会根据 HTTP Request 源源不断往这个 chanel 里扔进去事件 Event（pkg/watch/watch.go: Event），而 Reflector 从 chanel 的这一头不断的拿出这些事件，获取他们的 meta 信息，再根据事件的不同类型对 cache 做增删改查操作。 也就是说 k8s 对各种操作事实上是统一通过这个 chanel 里以事件的形式市传过来的，这也解释了为什么 cache 和 Store 中的实现所有的方法都是传进去一个 object 的 interface。 总结到这里所有的路径都打通了，再最后理一遍 k8s 是如何从 API 到 cache 的 Store 的： APIServer 为每类资源（例如 pods）创建一个 RESTClient（client）用于处理诸如 POST，PUT，GET 的 RESTful HTTP requsts APIServer 用 client 创建一个 ListWatcher（lw）用于监控每类资源的变化 APIServer 用 lw，指定的 store，创建一个 Reflector（reflector），将这个变化作用到 store 上 当发生 HTTP Requests 时，client 的 Watch 方法会把资源和资源变化类型打包成 event 放进 lw 的 ResultChan 中 reflector 从 ResultChan 里拿出 event，根据 event.EventType 把 event.Object 作用到 store 里去 整个过程中用了许多的 goroutine 来完成这么一件事。相比于 k8s 的实现，常见的 webapp 的处理相对就简单了好多，也可以看出 k8s 在设计上的精妙。"},{"title":"kubernetes源码阅读 - queue","permalink":"http://blog.jetmuffin.com/2016/12/03/kubernetes-code-reading-queue/","text":"上篇文章中对 k8s 的 scheduler 部分进行了简单的源码阅读和分析，现在接着上次的位置继续往下阅读。 引入在 plugin/pkg/scheduler/factory/factory.go 的代码中，scheduler 在创建时引用了一个 getNextPod 方法，获取下一个待调度的 pod。 1234567891011// plugin/pkg/scheduler/factory/factory.gofunc (f *ConfigFactory) getNextPod() *v1.Pod &#123; for &#123; pod := cache.Pop(f.PodQueue).(*v1.Pod) // 获取下一个待调度的 Pod if f.responsibleForPod(pod) &#123; glog.V(4).Infof(\"About to try and schedule pod %v\", pod.Name) return pod &#125; &#125;&#125; 当时没有继续下去，这些 pod 在 k8s 的调度队列里是如何管理的，这也是这篇文章想从源码里学到的。 Queue和上篇文章一样，由于 k8s 的代码量非常大，那么我们还是一点一点追溯到代码的源头。从 cache.Pop() 方法往上头寻找，IDE 会把你带到 pkg/client/cache/fifo.go 这个文件。从名字很明显看出这是一个先进先出的队列，那么我们就需要看看 k8s 在队列上是如何进行设计的。 首先是 Queue 的接口： 1234567891011121314151617181920// pkg/client/cache/fifo.gotype Queue interface &#123; Store // 实际存储的后端 // Pop blocks until it has something to process. // It returns the object that was process and the result of processing. // The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item // should be requeued before releasing the lock on the queue. Pop(PopProcessFunc) (interface&#123;&#125;, error) // pop 的抽象方法 // AddIfNotPresent adds a value previously // returned by Pop back into the queue as long // as nothing else (presumably more recent) // has since been added. AddIfNotPresent(interface&#123;&#125;) error // 如同注释所说。。加入队列如果它不在队列中 // Return true if the first batch of items has been popped HasSynced() bool&#125; 这个接口实际上是对所有类型的队列进行抽象，Pop() 方法是它们共有的方法，FIFO 是一种队列的实现方式，队列还可能有其他的实现方式，诸如 FILO 等。 FIFO Queuek8s 中默认使用的是 FIFO 队列： 12345678910111213141516171819// pkg/client/cache/fifo.gotype FIFO struct &#123; lock sync.RWMutex // 读写锁 cond sync.Cond // 读写锁基础上的消息通知对象 // We depend on the property that items in the set are in the queue and vice versa. items map[string]interface&#123;&#125; // 存储对象的内容 queue []string // 存储对象的 id // populated is true if the first batch of items inserted by Replace() has been populated // or Delete/Add/Update was called first. populated bool // initialPopulationCount is the number of items inserted by the first call of Replace() initialPopulationCount int // keyFunc is used to make the key used for queued item insertion and retrieval, and // should be deterministic. keyFunc KeyFunc // 用于获取item的key的function&#125; FIFO 队列中有两个重要的数据结构： items map[string]interface{} 用于 map 的 键值对形式实际存 items，便于 items 的增删改查 queue []string 用于维护每个 items 进入 FIFO 队列的先后顺序，只存 id 这里和其他用 chanel 实现的 FIFO 队列稍有不同，用一个 map 和一个 list 就成功的实现了可以增删改查的先进先出队列。 而这个先进先出的 FIFO 队列共有以下操作： Add() （添加一个 item） AddIfNotPresent() （如果 item 不在队列中，那么就把它加进队列里） Update() （更新指定 item） Delete() （删除制定 item） List() （列举所有的 item） ListKeys() （列举所有的 key） Get() (按对象获取 item） GetByKey() （按 key 获取 item） Pop() Replace() （替换整个队列的内容） Resync() 前几个方法比较常规，就是一些增删改查的方法。不过需要注意的是，这个 FIFO 在 Delete 时只是删去它在 map 里的对象，不会删去 queue 里的 id，而是在 Pop 时检查一下这个 id 是不是存在于 map 里就行了，相当于是一种 lazy 操作，因为动态维护 queue 队列里的顺序比较麻烦。 当然因为这个 lazy 操作会出现一种情况，就是 queue 里的 id 数和 map 里的 item 数不一致，那么就需要 Resync() 方法来进行同步了。它会直接遍历比较 queue 和 map，把不在 queue 里的 item 全部加到 queue 的末尾。 123456789101112131415161718192021// pkg/client/cache/fifo.go// Resync will touch all objects to put them into the processing queuefunc (f *FIFO) Resync() error &#123; f.lock.Lock() defer f.lock.Unlock() inQueue := sets.NewString() for _, id := range f.queue &#123; inQueue.Insert(id) // queue 里现在有的所有id &#125; for id := range f.items &#123; // 遍历map里的所有key,如果不在queue里就扔到queue末尾曲 if !inQueue.Has(id) &#123; f.queue = append(f.queue, id) &#125; &#125; if len(f.queue) &gt; 0 &#123; f.cond.Broadcast() &#125; return nil&#125; 最重要的是 Pop 方法的实现： 1234567891011121314151617181920212223242526272829// pkg/client/cache/fifo.gofunc (f *FIFO) Pop(process PopProcessFunc) (interface&#123;&#125;, error) &#123; f.lock.Lock() defer f.lock.Unlock() for &#123; for len(f.queue) == 0 &#123; f.cond.Wait() &#125; id := f.queue[0] f.queue = f.queue[1:] // 从队列里拿出第一个item的id if f.initialPopulationCount &gt; 0 &#123; f.initialPopulationCount-- &#125; item, ok := f.items[id] if !ok &#123; // Item may have been deleted subsequently. continue &#125; // 如果id在map里不存在，那么跳过它 delete(f.items, id) // 删掉map里对应的item err := process(item) // process方法会阻塞这个Pop方法直到这个item变为ready状态 if e, ok := err.(ErrRequeue); ok &#123; f.addIfNotPresent(id, item) err = e.Err &#125;// 如果出现错误再次放回队列里 return item, err &#125;&#125; Pop 方法里会从 queue 中拿出第一个 item 的 id，检查它是不是在 map 里，然后调用 process() 方法判断它是不是 ready 状态，最后返回这个 item。 阅读这里比较疑惑的是，实际 k8s 代码中貌似并没有实现这个 process 方法，可以看到在 pkg/client/cache/fifo.go 中有一个 Pop 方法的 helper，对方法进行了封装，而在封装中可以看到，传入的 process() 方法是个匿名函数，只是简单的把传入的 item 赋值给外部的 result 然后返回，并没有 check 这个 item 是否 ready。 12345678910// pkg/client/cache/fifo.gofunc Pop(queue Queue) interface&#123;&#125; &#123; var result interface&#123;&#125; queue.Pop(func(obj interface&#123;&#125;) error &#123; result = obj return nil &#125;) return result&#125; 最后需要提一下的就是这个 keyFunc 了。从 FIFO 类的定义上看，它是用于获取一个 item 的 key 的方法。而在 FIFO 实例化时，实际上传入的是 MetaNamespaceKeyFunc() 方法，获取 Pod 的 meta 信息里 namespace/name 或者 name。 123456789101112131415//pkg/client/cache/store.gofunc MetaNamespaceKeyFunc(obj interface&#123;&#125;) (string, error) &#123; if key, ok := obj.(ExplicitKey); ok &#123; return string(key), nil &#125; meta, err := meta.Accessor(obj) if err != nil &#123; return \"\", fmt.Errorf(\"object has no meta: %v\", err) &#125; if len(meta.GetNamespace()) &gt; 0 &#123; return meta.GetNamespace() + \"/\" + meta.GetName(), nil &#125; return meta.GetName(), nil&#125; DeltaFIFO Queue在 k8s 的 cache 中还提供了一种叫做 DeltaFIFO 的队列，相比于 FIFO 队列，它的作用不一样，它是用于储存每个 Pod 的事件（包括 Delete, Update, Add）。这个方法是在 ISSUE#4877 中提出的，因为某些情况下控制器需要知道调度器中队列的操作事件，并且添加 watcher 来针对事件来做出响应，这里也简单的过一下。 首先 delta 的类型定义有 Added，Updated，Deleted，Sync 这四种，分别是在队列进行添加、更新、删除和同步操作时加入的事件。 123456789101112// pkg/client/cache/delta_fifo.goconst ( Added DeltaType = \"Added\" Updated DeltaType = \"Updated\" Deleted DeltaType = \"Deleted\" // The other types are obvious. You'll get Sync deltas when: // * A watch expires/errors out and a new list/watch cycle is started. // * You've turned on periodic syncs. // (Anything that trigger's DeltaFIFO's Replace() method.) Sync DeltaType = \"Sync\") Delta 对象存储了修改的类型（Type）和修改在哪个对象上（Object)。 123456// pkg/client/cache/delta_fifo.gotype Delta struct &#123; Type DeltaType Object interface&#123;&#125;&#125; 同样这个队列和 FIFO 类似，也是用 map 存 Deltas，用 queue 存 id。稍微不同的地方上，对这个队列的 Add()，Update()， Delete() 操作是把相应的 Delta 添加 到队列里去，也就是说这个队列始终是在往里添加东西（Delta)，而外部的 Watcher 则在不断的从这个 DeltaFIFO 中取 Delta 来处理。也就是我们常说的 Producer/Consumer 的模型。 总结和之前看的 Mesos 中的 DRF 算法不同，k8s 中使用 FIFO 队列来维护每个 Pod 进入调度器的顺序。当然 Mesos 用 DRF 也是考虑在两层调度框架上进行公平调度，而 k8s 只关心进来的 Pod 的先后顺序。 再和上篇文章说到的内容结合，k8s 的调度实际上是基于先后顺序（FIFO），节点过滤（predicates）和节点打分（prioritizers）来做到从 Pod 到 Node 的调度过程。 最后，调度器中 FIFO 当然也是最简单和最常使用的队列模式，或许之后可以为 k8s 增加更多模式的调度器。"},{"title":"kubernetes源码阅读 - scheduler","permalink":"http://blog.jetmuffin.com/2016/11/24/kubernetes-code-reading-scheduler/","text":"阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。 Scheduler 入口首先定位到 plugin/cmd/scheduler.go 这个文件。 1234567891011121314// plugin/cmd/scheduler.gofunc main() &#123; s := options.NewSchedulerServer() s.AddFlags(pflag.CommandLine) // 解析参数 flag.InitFlags() logs.InitLogs() defer logs.FlushLogs() verflag.PrintAndExitIfRequested() app.Run(s) // 启动调度器&#125; 从上面这段代码可以看出这是从 command 启动 scheduler 的入口，它解析了 scheduler 的参数，同时调用了 app.Run(s)来启动 scheduler。 按着这个走向找到 app.Run(s) 的具体实现： 123456789101112131415// plugin/cmd/kube-scheduler/app/server.go// Run runs the specified SchedulerServer. This should never exit.func Run(s *options.SchedulerServer) error &#123; //... sched := scheduler.New(config) // 新建调度器 run := func(_ &lt;-chan struct&#123;&#125;) &#123; sched.Run() // 正式启动调度器入口 select &#123;&#125; &#125; //...&#125; 可以看到在这段代码片段中，通过 sched := scheduler.New(config) 新建了一个 scheduler 对象，并且调用它的 Run() 成员方法，同时需要特意留意 config。继续追踪到 scheduler 类的定义中取： 123456// plugin/pkg/scheduler/scheduler.go// Run begins watching and scheduling. It starts a goroutine and returns immediately.func (s *Scheduler) Run() &#123; go wait.Until(s.scheduleOne, 0, s.config.StopEverything)&#125; 在 Scheduler.Run() 方法中，Scheduler 通过 wait.Until() 工具，不停得调用 Scheduler.scheduleOne() 方法直到收到停止信号。我们接着看 scheduleOne() 方法： 1234567891011121314151617181920212223// plugin/pkg/scheduler/scheduler.gofunc (s *Scheduler) scheduleOne() &#123; pod := s.config.NextPod() // 获取下一个待调度的pod glog.V(3).Infof(\"Attempting to schedule pod: %v/%v\", pod.Namespace, pod.Name) start := time.Now() dest, err := s.config.Algorithm.Schedule(pod, s.config.NodeLister) // 调用算法进行调度 if err != nil &#123; glog.V(1).Infof(\"Failed to schedule pod: %v/%v\", pod.Namespace, pod.Name) s.config.Error(pod, err) s.config.Recorder.Eventf(pod, api.EventTypeWarning, \"FailedScheduling\", \"%v\", err) s.config.PodConditionUpdater.Update(pod, &amp;api.PodCondition&#123; Type: api.PodScheduled, Status: api.ConditionFalse, Reason: api.PodReasonUnschedulable, &#125;) return &#125; metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start)) // ...&#125; Scheduler 首先通过 config.NextPod() 来获取到当前要进行调度的一个 pod，然后调用 config.Algorithm.Schedule() 方法来对这个 pod 实际进行调度。从这种写法上我们可以猜测到 Algorithm 这儿用的是工厂模式。若根据该算法调度成功，那么将这个时间进行记录。否则调用 config.Error() 来进行错误处理。 这里有三个比较重点的内容： config.NextPod() config.Algorithm.schedule() config.Error() 它们均来自 Config 类，那么我们先看这个类，再接下去探索这两个方法。Config 类的定义也在这个文件中： 123456789101112131415161718192021222324252627282930// plugin/pkg/scheduler/scheduler.gotype Config struct &#123; // It is expected that changes made via SchedulerCache will be observed // by NodeLister and Algorithm. SchedulerCache schedulercache.Cache NodeLister algorithm.NodeLister Algorithm algorithm.ScheduleAlgorithm // 调度算法 Binder Binder // PodConditionUpdater is used only in case of scheduling errors. If we succeed // with scheduling, PodScheduled condition will be updated in apiserver in /bind // handler so that binding and setting PodCondition it is atomic. PodConditionUpdater PodConditionUpdater // NextPod should be a function that blocks until the next pod // is available. We don't use a channel for this, because scheduling // a pod may take some amount of time and we don't want pods to get // stale while they sit in a channel. NextPod func() *api.Pod // 获取下一个pod的抽象方法 // Error is called if there is an error. It is passed the pod in // question, and the error Error func(*api.Pod, error) // 处理调度出现的错误 // Recorder is the EventRecorder to use Recorder record.EventRecorder // Close this to shut down the scheduler. StopEverything chan struct&#123;&#125; // 停止信号&#125; Config 类传入了 scheduler 必要的各种参数，相当于原来隶属于 scheduler 的成员变量通过它传入。Config 类在 plugin/pkg/scheduler/factory 中被实例化，相应的抽象方法也被传入实际的引用方法。 12345678910111213141516171819// plugin/pkg/scheduler/factory// ...algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)// ... return &amp;scheduler.Config&#123; SchedulerCache: f.schedulerCache, // The scheduler only needs to consider schedulable nodes. NodeLister: f.NodeLister.NodeCondition(getNodeConditionPredicate()), Algorithm: algo, Binder: &amp;binder&#123;f.Client&#125;, PodConditionUpdater: &amp;podConditionUpdater&#123;f.Client&#125;, NextPod: func() *api.Pod &#123; return f.getNextPod() &#125;, Error: f.makeDefaultErrorFunc(&amp;podBackoff, f.PodQueue), StopEverything: f.StopEverything, &#125;, nil 获取待调度的 Pod首先看 NextPod 参数，从类 Config 的定义中的注释可以看到，这个参数是一个获取下一个 pod，并且阻塞该方法直到下一个 pod 可用为止。并且它的实现没有用 chanel，原因是一旦放到 chanel 里，这个 pod 便无法修改。这个 参数是在实例化时传入的获取下一个 pod 的方法。传入的代码也在这个文件中： 1234567891011// plugin/pkg/scheduler/factoryfunc (f *ConfigFactory) getNextPod() *api.Pod &#123; for &#123; pod := cache.Pop(f.PodQueue).(*api.Pod) if f.responsibleForPod(pod) &#123; glog.V(4).Infof(\"About to try and schedule pod %v\", pod.Name) return pod &#125; &#125;&#125; 从这段代码可以看出，获取下一个待调度的 pod 似乎是从一个队列中 pop 出一个 pod 来实现的。使用的来源是 pkg/client/cache，继续追踪： 12345678910// pkg/client/cachefunc Pop(queue Queue) interface&#123;&#125; &#123; var result interface&#123;&#125; queue.Pop(func(obj interface&#123;&#125;) error &#123; result = obj return nil &#125;) return result&#125; 这个方法是个代理方法，是对 Queue 类中的 Pop() 方法进行了一层封装，于是自然看到对应的 Queue.Pop()，它是在类 FIFO 中的，那么这块儿也逐渐明了了: 12345678910111213141516171819202122232425262728293031323334// pkg/client/cache/fifo.go// Pop waits until an item is ready and processes it. If multiple items are// ready, they are returned in the order in which they were added/updated.// The item is removed from the queue (and the store) before it is processed,// so if you don't successfully process it, it should be added back with// AddIfNotPresent(). process function is called under lock, so it is safe// update data structures in it that need to be in sync with the queue.func (f *FIFO) Pop(process PopProcessFunc) (interface&#123;&#125;, error) &#123; f.lock.Lock() defer f.lock.Unlock() for &#123; for len(f.queue) == 0 &#123; f.cond.Wait() &#125; id := f.queue[0] f.queue = f.queue[1:] if f.initialPopulationCount &gt; 0 &#123; f.initialPopulationCount-- &#125; item, ok := f.items[id] if !ok &#123; // Item may have been deleted subsequently. continue &#125; delete(f.items, id) err := process(item) if e, ok := err.(ErrRequeue); ok &#123; f.addIfNotPresent(id, item) err = e.Err &#125; return item, err &#125;&#125; 这个方法算是这条路径的最后一个追踪的节点了。总结一下这条路径： kubernetes 的 cache 中维护了一个先进先出的队列 FIFO，它不同于 golang 中的 chanel，它支持对队列中的元素进行更新、删除等操作。 这个队列的 FIFO.Pop() 方法会队首元素（一个 pod）到达 ready 状态，然后将它弹出，否则阻塞该方法。 Scheduler 类初始化时使用参数 Config，Config 中的 NextPod() 默认使用 FIFO.Pop()，当 Scheduler 需要进行调度时使用该方法得到下一个待调度的 pod。 使用调度算法进行实时调度回到 Config 类的第二个重要参数 Algorithm,它是对 pod 进行调度的实体： 123// plugin/pkg/scheduler/factory/factory.goalgo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders) 可以看到默认情况下，Algorithm 是用的通用调度器，接着看这个 GenericScheduler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// plugin/pkg/scheduler/generic_scheduler.go// Schedule tries to schedule the given pod to one of node in the node list.// If it succeeds, it will return the name of the node.// If it fails, it will return a Fiterror error with reasons.func (g *genericScheduler) Schedule(pod *api.Pod, nodeLister algorithm.NodeLister) (string, error) &#123; var trace *util.Trace if pod != nil &#123; trace = util.NewTrace(fmt.Sprintf(\"Scheduling %s/%s\", pod.Namespace, pod.Name)) &#125; else &#123; trace = util.NewTrace(\"Scheduling &lt;nil&gt; pod\") &#125; defer trace.LogIfLong(100 * time.Millisecond) nodes, err := nodeLister.List() // 获取所有节点 if err != nil &#123; return \"\", err &#125; if len(nodes) == 0 &#123; return \"\", ErrNoNodesAvailable &#125; // Used for all fit and priority funcs. err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap) if err != nil &#123; return \"\", err &#125; // TODO(harryz) Check if equivalenceCache is enabled and call scheduleWithEquivalenceClass here trace.Step(\"Computing predicates\") filteredNodes, failedPredicateMap, err := findNodesThatFit(pod, g.cachedNodeInfoMap, nodes, g.predicates, g.extenders, g.predicateMetaProducer) if err != nil &#123; return \"\", err &#125; if len(filteredNodes) == 0 &#123; return \"\", &amp;FitError&#123; Pod: pod, FailedPredicates: failedPredicateMap, &#125; &#125; trace.Step(\"Prioritizing\") metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap) priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders) if err != nil &#123; return \"\", err &#125; trace.Step(\"Selecting host\") return g.selectHost(priorityList)&#125; 可以看到，GenericScheduler 进行调度为以下过程： 从 NodeList 获取所有的节点 通过所给的断言函数（predicates）对所有节点进行过滤，选出符合的节点（findNodesThatFit()） 根据所给的打分函数（prioritizers）对过滤后的节点进行排序（PrioritizeNodes()） 通过 round-robin 方式依次获取分数最高的节点来运行 pod。 调度失败在 Config 类的 Error 参数中传入了调度失败的处理方法 makeDefaultErrorFunc() 对调度失败的 pod 进行重调度处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// plugin/pkg/scheduler/factory/factory.gofunc (factory *ConfigFactory) makeDefaultErrorFunc(backoff *podBackoff, podQueue *cache.FIFO) func(pod *api.Pod, err error) &#123; return func(pod *api.Pod, err error) &#123; if err == scheduler.ErrNoNodesAvailable &#123; glog.V(4).Infof(\"Unable to schedule %v %v: no nodes are registered to the cluster; waiting\", pod.Namespace, pod.Name) &#125; else &#123; glog.Errorf(\"Error scheduling %v %v: %v; retrying\", pod.Namespace, pod.Name, err) &#125; backoff.gc() // 清空backoff列表 // Retry asynchronously. // Note that this is extremely rudimentary and we need a more real error handling path. go func() &#123; defer runtime.HandleCrash() podID := types.NamespacedName&#123; Namespace: pod.Namespace, Name: pod.Name, &#125; entry := backoff.getEntry(podID) if !entry.TryWait(backoff.maxDuration) &#123; glog.Warningf(\"Request for pod %v already in flight, abandoning\", podID) return &#125; // Get the pod again; it may have changed/been scheduled already. getBackoff := initialGetBackoff for &#123; pod, err := factory.Client.Core().Pods(podID.Namespace).Get(podID.Name) if err == nil &#123; if len(pod.Spec.NodeName) == 0 &#123; podQueue.AddIfNotPresent(pod) // 重新将pod加入调度队列 &#125; break &#125; if errors.IsNotFound(err) &#123; glog.Warningf(\"A pod %v no longer exists\", podID) return &#125; glog.Errorf(\"Error getting pod %v for retry: %v; retrying...\", podID, err) if getBackoff = getBackoff * 2; getBackoff &gt; maximalGetBackoff &#123; getBackoff = maximalGetBackoff &#125; time.Sleep(getBackoff) &#125; &#125;() &#125;&#125; 从该处理方法看出，一旦出现调度失败，k8s 并不会阻塞调度过程，而是将调度失败的 pod 扔到这个失败处理方法里，而这个方法是通过异步的方式进行重试。k8s 从 backoff 这个列表中拿出指定的 pod，然后将它再次放到 FIFO 队列里，期间如果继续失败，再扔进 backoff 里异步等待处理。 总结k8s 的代码量非常庞大，需要快速定位源码比较困难，而采用这种根据从入口不断深入的阅读方式会减少很多工作量，只关心一部分的代码。当然这也无法从一个宏观的角度去看整个代码的设计，但是对于当前的工作已经足够。"},{"title":"How to fix '/bin/rm: Argument list too long","permalink":"http://blog.jetmuffin.com/2016/11/13/How-to-fix-bin-rm-Argument-list-too-long/","text":"做运维时发现系统的磁盘满了，检查发现磁盘的 /tmp 目录下装满了东西，于是很简单的想用 rm -rf /tmp/* 来删除，结果发现报错：bash: /bin/rm: Argument list too long。找了找方法解决它。 当执行命令时： 1/bin/rm -rf ./* 得到了错误提示： 1bash: /bin/rm: Argument list too long 查看发现，rm 命令也有参数长度的限制，所以需要用管道将命令分批次输入到 rm 中去。 因此 xargs 就派上用场了 1find . -name &quot;_MEI*&quot; | xargs /bin/rm -rf 或者 1find . -name &quot;_MEI*&quot; -print0 | xargs /bin/rm -rf 或者更直接的用 find 的 -delete 参数 1find . -name &quot;_MEI*&quot; -delete 即可解决。"},{"title":"Difference between Mesos and Kubernetes","permalink":"http://blog.jetmuffin.com/2016/10/24/Difference-between-Mesos-and-Kubernetes/","text":"自 Docker 大火之后，Swarm，Mesos，Kubernetes 这类围绕 Docker 容器展开的集群开源管理项目也逐渐风起云涌。本文主要从多个方面整理当前主流的两个容器编排框架 Mesos 和 Kubernetes 的区别。 介绍Apache Mesos 始于加州大学伯克利分校的一个项目，用来驱动 Twitter 的底层基础架构，并且在之后成为许多大公司，如 eBay 和 Airbnb 的重要工具。之后 Mesos 的作者之一 Ben Hindman 创立了商业化公司 Mesosphere，并为 Mesos 社区贡献了许多持续性的开发和支持工具。 而 Kubernetes 则是出自 Google 公司，基于他们在 Borg 上的经验总结，推出的极具“谷歌风格”的开源集群容器管理平台。Kubernetes 和 Borg 的开发和维护是由 Google 的同一个团队进行的。 社区人气在资源和容器管理方面，大公司（诸如微软、BAT 等）会自己造内部的轮子进行使用，而规模较小的公司则采用开源项目或基于开源项目进行二次开发。而在社区上，大家对 Docker 容器编排技术的选择更趋向于哪些方面？ Caicloud 在 2016 年 2 月统计了包括 Kubernetes, Swarm, Compose, Mesos, Docker Machine, Hyper, Containerd 在内的7个项目在 Github 上的 fork 数和被 star 数等。 fork在 fork 上的数据，Kubernetes 以 3699 次遥遥领先于其他所有的编排框架，而 Mesos 仅有 738 次 fork。而在笔者写这篇文章时（2016 年 10 月 24 日），Kubernetes 的 fork 数已经超过了 5800 次，而 Mesos 大概在 1050 次 fork。 starstar 的数据上 Kubernetes 依然以 12888 颗星数雄踞榜首，而 Mesos 仅有 2056 次 star。而直到今天，Kubernetes 已经拿到了近 17800 颗 star，而 Mesos 的 star 数量仅在 2600 次。 从 fork 和 star 数量可以看出两个框架在社区中的受欢迎程度，Kubernetes 远大于 Mesos。当然，由于 Kubernetes 出自名门，其中自然也带有一些来自于对 Google 公司的影响，而 Mesos 则更显得稍微小众一些。当然，社区的支持度越大，对开源框架的贡献者则越多，那么这个框架的发展则越迅速。 设计理念虽然同样被视为容器编排框架，但是 Kubernetes 和 Mesos 的设计理念完全不同。 ##"},{"title":"Debian下编译shadowsocks-qt5","permalink":"http://blog.jetmuffin.com/2016/10/18/compile-shadowsocks-qt5-on-debian/","text":"平时开发用的是 debian 的 linux 发行版，而 shadowsocks-qt5 没有提供 debian 的 release 版本，于是得自己动手编译，编译的时候会遇到许多坑，这里记录一下。 libQtshadowsocks首先需要编译 shadowsocks 的 lib 库 libQtShadowsocks，从 github/libQtshadowsocks 上找到稳定版本，直接下载源码的 .tar.gz 文件到本地，解压，并进入文件夹。 wiki 上对编译的依赖描述如下： Qt &gt;= 5.2 (qt5-qtbase-devel and qt5-qttools in Fedora, qtbase5-dev and qt5-qmake in Debian/Ubuntu)Botan &gt;= 1.10 (botan-devel in Fedora, libbotan1.10-dev in Debian/Ubuntu)A C++ Compiler that supports C++11 features (i.e. GCC &gt;= 4.7) 但是只安装这些依赖，在 debian 下会出现 botan-1.10 development package not found 的错误，但是检查后发现 libbotan1.10-dev 包已经安装了。 后来发现是有其他的依赖没满足，所以干脆一次性把所有依赖全部装了，就不会出现问题了。 1sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libappindicator-dev libzbar-dev libbotan1.10-dev 然后进入进行编译，编译时可以选择 INSTALL_PREFIX，它默认是 /usr 目录，如果自行更改会有另外的问题，下面会提到。 12qmakemake &amp;&amp; make install shadowsocks-qt5编译安装完 libQtShadowsocks 后就可以编译 shadowsocks-qt5 了。从 https://github.com/shadowsocks/shadowsocks-qt5 上 clone ss-qt5 的源码，然后进入目录编译： 1234git clone https://github.com/shadowsocks/shadowsocks-qt5.gitcd shadowsocks-qt5qmakemake &amp;&amp; make install 同样这里的 qmake 可以指定 INSTALL_PREFIX, 默认为 /usr。安装后 ss-qt5 会在 /usr/bin 文件夹中，命令行直接运行 ss-qt5 或者在图形界面中直接搜索就可以运行了。 by the way如果在运行时仍然碰到 libQtShadowsocks.so.1 not found 这个问题，那么原因就可能是上面所提到的编译 libQtShadowsocks 的问题了。默认指定的 INSTALL_PREFIX 为 /usr，即安装到 /usr/lib 中，而这个路径是自动被加到系统的链接库里的。 而如果自行指定了 INSTALL_PREFIX，例如我选择了 /usr/local，那么这个 so 文件会被安装到 /usr/local/lib，而这个目录不是默认被加到系统链接库里的，那么需要手动加进去，解决方法如下： 12echo &quot;/usr/local/lib&quot; &gt;&gt; &quot;/etc/ld.so.conf&quot;/sbin/ldconfig 然后再运行 ss-qt5 就没有问题了。"},{"title":"使用 gh-md-doc 生成 markdown 文章结构","permalink":"http://blog.jetmuffin.com/2016/09/13/use-gh-md-doc-to-generate-toc-of-blog/","text":"本篇技巧来自于我在 iQiyi 的云平台部门实习时的内部分享，主要用于文档编写。在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 gh-md-toc。 生成 markdown table of contents 常常项目开发的文档都是用 markdown 格式编写，并且以代码的形式托管在 Git 上，同时，那么就可以使用 gh-md-toc来生成文档目录。 但是，gh-md-toc 会直接将结果打印到 stout，而我们想要的最好的效果是直接将其添加到文档头部，而不是从 stdout 再复制粘贴，然后还要格式化空行。 以本文档为例，gh-md-toc 生成的 table of contents 如下： 1234567Table of Contents================= * [生成 markdown table of contents](#生成-markdown-table-of-contents) * [使用 gh-md-toc 的奇技淫巧](#使用-gh-md-toc-的奇技淫巧)Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc) 显然，我们需要将这段文字添加到文件的头部，并且删除第一行空行，在最后一行添加一行空行。 使用 gh-md-toc 的奇技淫巧OK，Let’s Rock! 先看一条命令： 1$ gh-md-toc file.md | (tail -n +2 &amp;&amp; echo &quot;&quot; &amp;&amp; cat file.md) | sponge file.md 你会惊讶的发现，这条命令就完成了所有事，为 file.md 生成了 table ofcontents，并且自动添加在了 file.md 的头部，并且完美的处理了空行。 这里使用了一个好工具 sponge，想想为什么不能直接重定向到 file.md 呢？ 但是，追求极致的程序员不会止步，因为上面的命令中 file.md 这个待处理的文件出现了3 次，所以也挺烦人的，对吧，即使使用命令替换也来得不如一次直接。 OK，Let’s Rock Again! 添加一个函数，重定义 gh-md-toc，添加下面的函数定义到你的 shell rc，例如： bash，~/.bashrc zsh，~/.zshrc 1234567function gh-md-toc() &#123; if [ -z \"$1\" ]; then echo \"gh-md-toc &lt;markdown file&gt;\" return 1 fi /home/chengwei/Github/github-markdown-toc/gh-md-toc $1 | (tail -n +2 &amp;&amp; echo \"\" &amp;&amp; cat $1) | sponge $1&#125; 将上面的 /home/chengwei/Github/github-markdown-toc/gh-md-toc 替换成 gh-md-doc在你的系统上的路径。 注意：如果你把 gh-md-doc 放在了 $PATH 中，必须用绝对路径调用，否则就无限递归了 :-) 最后，source shell rc 配置文件，生效 123$ source ~/.bashrcOR$ source ~/.zshrc 现在，要为某个 markdown 文件添加 table of contents 只需要执行： 1$ gh-md-toc file.md"},{"title":"Moore vote algorithm 多数投票算法","permalink":"http://blog.jetmuffin.com/2016/09/04/moore-vote-algorithm/","text":"在刷 leetcode 时，发现一道题目 Majority Element，要求求出数组中出现元素超过 n/2 的元素。思考了许久也只能写出 O(nlogn) 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 O(n) 时间和 O(1) 空间解决这个问题。 算法思想算法的思想很简单，每次从数组中取一对数，如果相同就叠加，如果不同就一起删去，很明显最后留下的肯定是数量最多的一个数。再深入一步实现，只要用一个变量记录标记元素和标记元素的出现次数，然后找下一个元素，分以下情况： 如果下一个元素和标记元素相同，那么标记元素出现次数加1； 如果和标记元素不同，那么标记元素出现次数减1； 如果标记元素变为 0，那么取下一个元素作为标记元素，初始出现次数为1； 举个说明性的例子，数列 [2,3,2,2,4,1,2]，标记元素变量 now，出现次数 count 初始状态（取第一个数）：now:2，count:1 取第二个数 3，它和 now 不同，那么 count--，这时候 count = 0，那么拿下一个元素（第三个数）为标记元素 now:2，count:1 取第四个数 2，它和 now 相同，那么 count++，状态变为 now:2，count:2 取第五个数 4，它和 now 不同，那么 count--，状态变为 now:2，count:1 重复以上过程直到结尾，最后 now:2，所以数量超过 n/2 的元素为 2 算法实现为了更好实现上述过程，事实上程序的伪代码为： 123456789For i from 0 to len(arr): if count == 0: now = arr[i] count = 1 else: if now == arr[i]: count ++ else: count -- 即只要标记元素被删去了，那么访问的下一个元素就作为标记元素。 代码实现12345678910111213141516171819class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int count = 0, now = 0; for(int i = 0 ; i &lt; nums.size(); i++) &#123; if(count == 0) &#123; now = nums[i]; count = 1; &#125; else &#123; if(now == nums[i]) &#123; count ++; &#125; else &#123; count --; &#125; &#125; &#125; return now; &#125;&#125;; 参考资料 算法效果演示"},{"title":"Golang 基础学习（二）类型","permalink":"http://blog.jetmuffin.com/2016/09/04/go-learning-2/","text":"类型go 语言中有许多的类型，包括字符串、整形、浮点型、布尔型等等，这和一般的语言相同。这些类型之间可以进行基本的运算，这和 C, Java 等语言也是相同的。 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"math/cmplx\")var ( flag bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i))func main() &#123; fmt.Println(\"go\" + \"lang\") fmt.Println(\"1+1 = \", 1+1) fmt.Println(\"7.0/3.0 =\", 7.0/3.0) fmt.Println(true &amp;&amp; false) fmt.Println(true || false) fmt.Println(!true) const f = \"%T(%v)\\n\" fmt.Printf(f, flag, flag) fmt.Printf(f, MaxInt, MaxInt) fmt.Printf(f, z, z)&#125; 基础类型go 语言中的基础数据类型包括以下几种： int，Rune（Rune 是 int 的别名，代表一个 Unicode 码） int8，int16，int32，int64 byte，uint8，uint16，uint32，uint64（byte 是 uint8 的别名） float32，float64 bool string complex128，complex64（复数） 源码中 runtime.h 对几种简单的基本类型先做了定义，然后用它们对其他的类型进行定义。 1234567891011121314151617typedef signed char int8;typedef unsigned char uint8;typedef signed short int16;typedef unsigned short uint16;typedef signed int int32;typedef unsigned int uint32;typedef signed long long int int64;typedef float float32;typedef double float64;typedef uint32 uintptrtypedef int32 intptrtypedef int32 intgotypedef uint32 uintgotypedef uint8 bool;typedef uint8 byte; 从中可以看出 go 中的每个类型在 c 中对应的类型和占用字节大小。另外其中还定义了 intptr 和 intgo，其中 intptr 用于指针运算，intgo 相当于在源码中给 int 起的一个别名。 stringstring 类型事实上是一个结构体： 1234struct String &#123; byte* str; intgo len;&#125; 这里对于每个 string 类型，都确定了它的长度和字符数组，也就是说 golang 的字符串初始化话底层的结构就会被初始化。 变量go 中使用 var 作为关键字来进行变量声明。但和 javascript 里不同，go 中的变量是强类型。声明的方式有多种，包括： var a int（仅声明不初始化） var a = 10（声明同时初始化，但不指定类型，由编译器自动推导类型） var a int = 10（声明、指定类型以及初始化） a := 10（省略关键字，声明同时初始化，由编译器推导类型） Note: 这里需要注意的是，:=是用于声明及赋值，而不是赋值，因此仅在变量定义时使用，开始写 go 的时候常常将 := 用于赋值导致出错。 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; var a string = \"initial\" fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := \"short\" fmt.Println(f)&#125; 类型推导对变量声明语句，编译器会对其进行自动的类型推导，可以用 reflect 包来查看变量的类型。 12345678910111213141516171819package mainimport ( \"fmt\" \"reflect\")func main() &#123; var a int = 10 var b byte = 10 c := 10.0 d := \"10\" fmt.Printf(\"a type:%s\\n\", reflect.TypeOf(a)) fmt.Printf(\"b type:%s\\n\", reflect.TypeOf(b)) fmt.Printf(\"c type:%s\\n\", reflect.TypeOf(c)) fmt.Printf(\"d type:%s\\n\", reflect.TypeOf(d))&#125; 结果如下： 1234a type:intb type:uint8c type:float64d type:string 类型转换正常情况下，将类型 V 转化为 T 需要显式声明。 12a := 5 // typeof(a) is int32b := int64(10) // typeof(b) is int64 若没有显式声明还需要进行类型转换 V -&gt; T，则需要满足 assignability，根据文档assignability，可能的条件如下： T 和 V 的类型相同 T 和 V 的基础类型相同，并且其中至少一个并未显式指定类型 T 是一个 interface 类型，并且 V 实现了 T (这在后面会提到) V 是一个双向的 channel，而 T 是一个 channel，同时 V 和 T 的元素类型相同 V 是 nil 同时 T 是 slice, function, map, channel, interface, pointer 中的一种 V 是未声明类型的常量 在这些条件下，不需要显式声明，直接可以将 T 的值赋予 V。 常量go 中的常量和 c 相同，需要在编译时确定值，并在编译时被创建。常量需要满足以下几个要求： 类型必须是数值、字符串和布尔值之一 可以使用表达式，但表达式必须在编译时可以计算的 声明常量同时必须指定值（初始化），并且不能再修改值 常量的关键字和 cpp 相同，用 const 进行声明，声明时可以显式指定数据类型，也可以不指定。多个常量可以同时进行批量声明，常见的使用方法如下： 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"math\")const ( s string = \"constant\" one, two = 1, 2)func main() &#123; fmt.Println(s) fmt.Println(one) fmt.Println(two) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n))&#125; iotaiota 在 go 中用于常量计数。iota 在 const 关键字出现时置 0，并且 const 内每增加一行讲使 itoa 计数一次，举个例子应该就很清楚了。 ```goconst a = iota // a = 0const b = iota // b = 0const ( c = iota // c = 0 d = iota // d = 1 e = iota // e = 2)const ( f, g = iota, 1 &lt;&lt; iota // f = 0, g = 1 h, i = iota, 1 &lt;&lt; iota // h = 1, i = 2) 参考资料 Golang Document 老虞学GoLang笔记 golang的类型转换的坑和分析"},{"title":"Golang 基础学习（一）","permalink":"http://blog.jetmuffin.com/2016/09/03/go-learning-1/","text":"目的最初接触 go 是在 15 年，最开始对 go 的理解是写多线程的程序非常方便，于是学习了 go 的基本语法，并尝试写了一些 go 的简单应用，包括我的本科毕业设计也是使用 go 写的（apt-mesos）。但是对 go 也是停留在最基本的语法认识，有很多特性并未了解。所以想要从头再屡一遍 go 的所有内容。对每一块儿内容，以重学的角度深入学习。 教程与代码学习的过程将使用教程（https://gobyexample.com/），它对 go 的每块儿内容提供了 demo，可以更易于理解。教程中的例程，将对其进行理解和实现，然后将代码整理在仓库 [JetMuffin/golearning]中。 Hello World任何语言的入门，都需要编写一个 Hello World 程序。 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"hello world\")&#125; 这是一段使用 fmt 进行输出 hello world 字符的代码，从语言的风格上看，go 使用 package 作为关键字进行包管理，这和 java 很像；而导入包的部分则又像 python；而主函数部分也比较独特。庆幸的是，go 中也不需要添加分号。 go 和 python，ruby 等不同，它是解释型语言，因此在每次运行前需要进行编译，然后才可以进行执行，或者直接进行编译执行。 123456789$ go run helloworld.gohello world$ go build helloworld.go$ lshelloworld helloworld.go$ ./helloworldhello world 这里需要知道的一点是，编译好后生成了 binary 文件，可以在同平台下直接进行运行，但并无法做到 runing everywhere，因为可能需要涉及到交叉编译的问题。"},{"title":"Zabbix配合lm_sensors监控服务器CPU温度","permalink":"http://blog.jetmuffin.com/2016/09/01/monitor-temperature-of-server-by-zabbix-and-lm-sensors/","text":"手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。 首先是获取 CPU 温度的方法，常见的有两种： IPMI lm_sensors 其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。 安装lm_sensors 的安装很简单，repo 里已经有这个包了，所以直接通过 yum 安装就行了（集群是用的 CentOS，Debian系的也差不多）。 1$ yum install lm_sensors 考虑到大多数集群是无法直接通外网的，所以可以在一台可以通外网的机器上下好 rpm 包，再传到 NFS 上或者直接 scp进去。下载 rpm 包可以使用 yumdownloader，刚好 lm_sensors 没有要依赖的包。 1$ yumdownloader install lm_sensors 采集采集数据之前，先看一下 zabbix 的自定义监控项的定义方法。在 zabbix_agentd 中对自定义监控项的定义格式为： 1UserParameter=&lt;key&gt;,&lt;shell command&gt; 其中可以看出监控项通过一句 shell 命令获得，并且获得的需要是一个数值。这样我们大概明确了需要采集的目标。 然后先简单过掉下 lm_sensors 需要的配置，即监测 sensors 的信息。 12345678$ sensors-detectThis program will help you determine which kernel modules you needto load to use lm_sensors most effectively. It is generally safeand recommended to accept the default answers to all questions,unless you know what you're doing.Some south bridges, CPUs or memory controllers contain embedded sensors.Do you want to scan for them? This is totally safe. (YES/no): 一路敲 yes 即可，然后执行 sensors 命令可以看到 CPU 的温度： 123456789101112131415161718192021222324$ sensorspower_meter-acpi-0Adapter: ACPI interfacepower1: 18446.74 GW (interval = 2.00 s)coretemp-isa-0000Adapter: ISA adapterPhysical id 0: +41.0°C (high = +75.0°C, crit = +85.0°C)Core 0: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +28.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +34.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +30.0°C (high = +75.0°C, crit = +85.0°C)coretemp-isa-0001Adapter: ISA adapterPhysical id 1: +38.0°C (high = +75.0°C, crit = +85.0°C)Core 0: +33.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +34.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +31.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +31.0°C (high = +75.0°C, crit = +85.0°C) 命令显示的结果是每个核心的温度以及物理核的温度，最后要聚合到一个数值上。这里可以选择两个方向，一是对每个核心进行监控，这样较为复杂，但是细节明显；二是对每个核心取平均值，处理比较简单。这里我选择了后者，那么就需要从命令输出中获取到需要的信息了。这里就用 grep，cut，awk 乱处理一通了。 首先用 grep 拿到每个核心的温度行： 12345678910111213$ sensors | grep \"Core\"Core 0: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +34.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +31.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 0: +31.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +33.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +31.0°C (high = +75.0°C, crit = +85.0°C) 然后用 cut 或者 awk 获取每行的温度数值。 12345678910111213$ sensors | grep \"Core\" | awk '&#123;print $3&#125;' | awk -F '.' '&#123;print $1&#125;' | awk -F '+' '&#123;print $2&#125;'303329343030313432323230 最后对这些输出按行取平均，再四舍五入到整数就行了（也可以不四舍五入）。 123$ sensors | grep 'Core' | awk '&#123;print $3&#125;' | awk -F \".\" '&#123;print $1&#125;' | awk -F \"+\" '&#123;print $2&#125;' | \\awk '&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;' | awk -F. '&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;'31 集成做完数据的采集工作，那么就要集成进 Zabbix 里了。首先需要在 zabbix_agentd 里定义这个监控项，在 zabbix_agentd.conf 里加入 1UserParameter=system.cpu.temperature,/usr/bin/sensors | grep &apos;Core&apos; | awk &apos;&#123;print $3&#125;&apos; | awk -F &quot;.&quot; &apos;&#123;print $1&#125;&apos; | awk -F &quot;+&quot; &apos;&#123;print $2&#125;&apos; | awk &apos;&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;&apos; | awk -F. &apos;&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;&apos; 然后重启 agent 服务即可。 123$ service zabbix_agentd restartShutting down zabbix_agentd: [ OK ]Starting zabbix_agentd: [ OK ] 回到 Zabbix 的界面，选择一个合适的模板，进到它的监控项中，点击新建监控项，然后如下图填入信息即可。注意这里的键值即上面填的 UserParameters 里的 key。 然后对相应的主机应用这个模板，那么就可以获取到这台主机的 CPU 温度了。 报警设置和普通监控项相同，如下： 最后，如果对 Zabbix 增加了 grafana 的话，还可以在 grafana 里去显示 CPU 温度。"},{"title":"InfiniBand技术介绍","permalink":"http://blog.jetmuffin.com/2016/06/07/infiniband-technique/","text":"随着服务器处理速度的不断加快，用户对提升网络传输速度的需求也越来越紧迫，传统意义上的输入 / 输出技术， 如 PCI、以太等，已经无法满足这种需求。如何更为有效的提高数据传输速度，增加有效带宽成为摆在人们面前必须解决的一个重大问题。 InfiniBand 标准就是在这种情况下应运而生的，它在很大程度上解决了传统输入 / 输出架构的传输瓶颈问题 , 运行速度可达到每端口 2.5Gb/s 或 10Gb/s 。 目前，这项技术已经广泛应用到高性能计算等领域，Linux 操作系统内核也对其提供了全面的支持，本文将逐一介绍 InfiniBand 技术架构，以及如何在 Red Hat Enterprise Linux 5.3 和 SLES11 系统中配置 InfiniBand 网络设备，包括网卡驱动的安装以及 IPoIB（IP over InfiniBand）接口配置。 HPC集群高性能计算（HPC）服务器集群在各个行业中正逐步流行开来，主要用于计算密集型任务。包括模拟物体表面上大气或流体流动的计算流体力学，财务风险分析，生物信息学，量子力学等方面计算。 HPC集群中的网络网络是HPC集群的核心，用于实现执行并行计算的计算节点之间的通信。 根据使用目的的不同，可以把HPC中的网络大体分为三种类型，在真正搭建HPC集群时使用其中的一种，两种或三种。 管理网络：用于用户维护、控制和操作单个节点的网络 I/O网络：用于对中央共享文件系统执行读写操作的网络 IPC网络：用于为并行处理传递消息和数据的流程间通信网络 InfiniBand vs 以太网为了满足HPC集群中的网络需求，通常的解决方案有两种：以太网和InfiniBand。然而这两种网络的区别和使用范围还是很明显的。 传统数据中心常常使用以太网互联（这里的以太网多指千兆以太网），构成一张高速运转的数据网络。以太网采用树状结构，按三层交换机制排列，从核心开始扇形展开。而高性能计算集群则常常使用InfiniBand。InfiniBand的拓扑结构相对更加扁平，如图1所示，它主要依赖于两个核心组件：主机通道适配器HCA（Host Channel Adapter）和InfiniBand交换机。其中HCA为主机设备提供一个接口用于支持所有InfiniBand定义的操作，而交换机则将一个端口接受到的InfiniBand保温转发到另一个端口，支持单播和多播。 也是取决于InfiniBand的结构决定了它的带宽大、延迟低的优势，也正因为如此被广泛使用在高性能集群中。 近年来万兆以太网逐渐进入市场，它启用了CSMA/CD来处理数据包冲突，而采用全双工模式以降低延迟，同时它支持更大的带宽，然而万兆以太网在延迟上仍然比InfiniBand高，同时成本也相比InfiniBand高。但是在未来，万兆以太网可能会影响InfiniBand在高性能集群中的市场。 InfiniBand在Linux中的使用Red Hat产品中从Red Hat Enterprise Linux 5.3开始正式从内核中集成对InfiniBand网卡的支持，并开始讲InfiniBand所需的驱动以及库文件打包到发行版的CD里，所以推荐使用Red Hat 5.3之后的系统版本。而对于其他发行版的Linux，都在支持InfiniBand。 配置及错误总结详见下一篇文章。"},{"title":"使用slurm进行集群的资源管理（vagrant）","permalink":"http://blog.jetmuffin.com/2016/05/30/install-and-use-slurm-on-ubuntu/","text":"简介 SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。 slrum相当于一个集群管理器，可以伸缩至大型节点集群，容错好，而更重要的是他开源。而现在，slurm已经成为很多强大的超级计算机上使用的资源管理器。 架构slurm的架构和一般的集群管理架构相类似，顶部是一对冗余集群控制器，它充当计算集群的管理器并实现一个管理守护程序（slurmctld），slurmctld提供了对计算资源的监视，同时它将进入的作业映射到基本的计算资源。 此外，每个计算节点上有一个守护程序slurmd，slurmd负责管理在其上执行的节点包括运行的任务，来自控制器的工作，以及接受控制器的请求等。 安装安装上，为了模拟集群的环境，需要使用多个节点，所以我们用vagrant创建多个虚拟机。Vagrantfile如下： 123456789101112131415161718# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(2) do |config| config.vm.box = &quot;ubuntu/trusty64&quot; config.ssh.insert_key = false config.vm.define &quot;master&quot; do |node| node.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.10&quot; node.vm.hostname = &quot;master&quot; node.vm.provider &quot;virtualbox&quot; do |v| v.memory = 2048 v.cpus = 2 end end config.vm.define &quot;compute&quot; do |slave| slave.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot; slave.vm.hostname = &quot;compute&quot; endend 分别使用vagrant up master和vagrant up compute启动控制节点和计算节点。 Ubuntu源里提供了munge，所以可以直接通过源进行安装。在控制节点和计算节点分别安装slurm包，这个包里包含了slurmctld和slurmd 1$ sudo apt-get install slurm-llnl 由于计算节点和控制节点需要通信，而通信之间需要进行认证，所以这里需要生成key并启动认证服务。这里使用的是llnl的munge。 12$ sudo create-munge-keyGenerating a pseudo-random key using /dev/urandom complete. 然后启动munge的认证服务 1$ sudo service munge start 接下来配置slurm的配置文件，然而笔者在使用时，slrum的配置工具Slurm Configuration Tool失效了，所以可以去slurm的源码里复制一份example。我的配置文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940ClusterName=vagrantControlMachine=master#ControlAddr=#SlurmUser=slurmSlurmctldPort=6817SlurmdPort=6818AuthType=auth/mungeStateSaveLocation=/tmpSlurmdSpoolDir=/tmp/slurmdSwitchType=switch/noneMpiDefault=noneSlurmctldPidFile=/var/run/slurmctld.pidSlurmdPidFile=/var/run/slurmd.pidProctrackType=proctrack/pgidReturnToService=0## TIMERSSlurmctldTimeout=300SlurmdTimeout=300InactiveLimit=0MinJobAge=300KillWait=30Waittime=0## SCHEDULINGSchedulerType=sched/backfillSelectType=select/linearFastSchedule=1## LOGGINGSlurmctldDebug=3SlurmdDebug=3JobCompType=jobcomp/none## ACCOUNTING## COMPUTE NODESNodeName=compute Procs=1 State=UNKNOWNPartitionName=debug Nodes=compute Default=YES MaxTime=INFINITE State=UP 这份配置文件在计算节点上同样要使用，所以要复制到计算节点上。 1$ sudo scp /etc/slurm-llnl/slurm.conf vagrant@compute/~ 然后启动控制节点上的slurmctld服务： 12$ sudo service slurm-llnl start* Starting slurm central management daemon slurmctld 接着是计算节点的配置，同样需要使用munge，将控制节点生成的munge.key拷贝到计算节点上。 1$ sudo scp /etc/munge/munge.key vagrant@compute:/~ 然后进入计算节点，将munge.key拷贝到munge的目录并启动munge,注意要修改key的owner和group为munge。 12$ sudo mv ~/munge.key /etc/munge/$ sudo chown munge:munge /etc/munge/munge.key 然后就可以启动munge服务了 1$ sudo service munge start 再将之前复制的slurm.conf放到指定位置： 1$ mv ~/slurm.conf /etc/slurm-llnl/slurm.conf 接着启动计算节点上的slurmd 1$ sudo service slurm-llnl start 这样，slurm就配置完毕了。 使用这里就简单测试下slurm的功能（在控制节点上运行），首先运行sinfo查看集群状况。 123$ sinfoPARTITION AVAIL TIMELIMIT NODES STATE NODELISTdebug* up infinite 1 idle compute 然后启动一个任务（/bin/hostname）： 12$ srun -N1 /bin/hostnamecompute 错误与解决方案1. 启动munge报错误munged: Error: Logfile is insecure: group-writable permissions set on “/var/log” 在Ubuntu 14.04下启动munge会出现以下错误： 123$ sudo service munge start * Starting MUNGE munged [fail]munged: Error: Logfile is insecure: group-writable permissions set on &quot;/var/log&quot; 原因是因为Ubuntu 14.04将/var/log目录的权限从0755 root:root调整为0755 root:syslog，因此直接启动会报group-writable permissions的错误。 解决方案是启动munge时加上--force或--syslog的参数。 --force会将errors转为warnings，跳过错误 --syslog会跳过/var/log目录的权限检查 如果是使用/etc/init.d/munge start或者service munge start的话，可以将Option写到配置文件/etc/default/munge里： 1OPTIONS=&quot;--force&quot;"},{"title":"OSX系统列举USB设备方法","permalink":"http://blog.jetmuffin.com/2016/03/13/list-usb-devices-on-mac-os-x/","text":"Linux 用户在列举USB设备时，可以使用lsusb命令来查看所有已经连接的usb设备，或者进入/dev/bus/usb/001之类进行查看。 而在Mac OS下，系统自带的命令则是system_profiler SPUSBDataType，使用这条命令可以查看所有连接的USB设备，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 jeff@promote ⮀ ~ ⮀ system_profiler SPUSBDataTypeUSB: USB 3.0 Bus: BSD Name: en4 Host Controller Driver: AppleUSBXHCIWPT PCI Device ID: 0x9cb1 PCI Revision ID: 0x0003 PCI Vendor ID: 0x8086 USB3.0 Hub: Product ID: 0x0612 Vendor ID: 0x05e3 (Genesys Logic, Inc.) Version: 92.16 Speed: Up to 5 Gb/sec Manufacturer: GenesysLogic Location ID: 0x14400000 / 6 Current Available (mA): 1800 Current Required (mA): 0 Extra Operating Current (mA): 0 Bluetooth USB Host Controller: Product ID: 0x8290 Vendor ID: 0x05ac (Apple Inc.) Version: 1.11 Speed: Up to 12 Mb/sec Manufacturer: Broadcom Corp. Location ID: 0x14300000 / 2 Current Available (mA): 1000 Current Required (mA): 0 Extra Operating Current (mA): 0 Built-In: Yes Razer DeathAdder: Product ID: 0x0016 Vendor ID: 0x1532 Version: 1.00 Speed: Up to 12 Mb/sec Manufacturer: Razer Location ID: 0x14200000 / 4 Current Available (mA): 1000 Current Required (mA): 100 Extra Operating Current (mA): 0 USB2.0 Hub: Product ID: 0x0610 Vendor ID: 0x05e3 (Genesys Logic, Inc.) Version: 92.16 Speed: Up to 480 Mb/sec Manufacturer: GenesysLogic Location ID: 0x14100000 / 5 Current Available (mA): 1000 Current Required (mA): 100 Extra Operating Current (mA): 0 BSD Name: en4 Apple USB Ethernet Adapter: Product ID: 0x1402 Vendor ID: 0x05ac (Apple Inc.) Version: 0.01 Serial Number: 1460AB Speed: Up to 480 Mb/sec Manufacturer: Apple Inc. Location ID: 0x14140000 / 7 Current Available (mA): 1000 Current Required (mA): 250 Extra Operating Current (mA): 0 BSD Name: en4 iPhone: Product ID: 0x12a8 Vendor ID: 0x05ac (Apple Inc.) Version: 7.02 Serial Number: 1ba089f6c8745ae921e95dea83879c7e36b43b9c Speed: Up to 480 Mb/sec Manufacturer: Apple Inc. Location ID: 0x14130000 / 8 Current Available (mA): 1000 Current Required (mA): 500 Extra Operating Current (mA): 0 Sleep current (mA): 500 而在图形界面上EL Capitan的操作步骤为： 点击左上角苹果标志 点击关于本机-&gt; 系统报告 -&gt; USB 然后则可以查看系统总线上挂载的USB信息了 最后说下为啥写这个：最近在研究怎么在docker container中挂载USB，首先要获取总线上的USB设备，这是个开头吧。"},{"title":"运行Mesos Framework报no mesos in java.library.path解决方法","permalink":"http://blog.jetmuffin.com/2016/01/05/solution-to-no-mesos-in-java-library-path/","text":"在运行自己用scala编写的Framework时遇到了一个巨大的问题，即在执行 1java -cp xxxx.jar -Djava.library.path=libs xxxx.xxxx.xxx 之后报错： 12345Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: no mesos in java.library.path at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1758) at java.lang.Runtime.loadLibrary0(Runtime.java:823) at java.lang.System.loadLibrary(System.java:1045) at org.apache.mesos.MesosNativeLibrary.load(MesosNativeLibrary.java:46) 尝试了把build之后的mesos-0.25.0.jar和protobuf-2.5.0.jar加入，依然不生效，查询了stackoverflow后发现是MESOS_NATIVE_LIBRARY环境变量未加入。 因此只要执行 12345 # For Linux$ export MESOS_NATIVE_LIBRARY=&apos;/usr/local/lib/libmesos.so&apos; # For OSX$ export MESOS_NATIVE_LIBRARY=&apos;/usr/local/lib/libmesos.dylib&apos; 就行了。 为了方便，可以把这个语句加到.bashrc中"},{"title":"DCOS上的cron 分布式作业调度器 Chronos","permalink":"http://blog.jetmuffin.com/2015/12/28/chronos-distributed-cron-on-dcos/","text":"Chronos是Aribnb公司开发的替代cron的Mesos框架。它是一个运行在Apache Mesos上的分布式的，高容错的任务编排、定时任务的框架。 Chronos作为DCOS中的一部分，它默认所处的环境下存在任务的环境。例如Chronos会执行Hadoop任务脚本，即使执行的slave上并没有Hadoop环境（但是这样会导致任务的失败）。此外，Chronos支持任务脚本传输文件到远程机器上，并执行文件，同时接受异步的回调，通知Chronos任务成功或是失败。比较重要的一点是，Chronos同样支持在Docker容器中进行执行任务。 架构 Chronos通过Mesos Master下的Scheduler选择指定slave执行job，来完成相应的task。而在Chronos中并不会对环境进行选择，而只是对从Mesos Master接受的Resource offers进行筛选。 JobGraphChronos中比较重要的一点是利用JobGraph来确定各个job之间的依赖关系，以确定任务执行的先后顺序。 Chronos中根据JobGraph计算出job执行的优先级，然后再根据当前的job执行情况，然后确定每个任务是否进行执行。 如图，我创建了2个任务: 指定sleep2的父元素为sleep，则sleep2依赖于sleep，先后顺序也应该为先执行sleep然后是sleep2，如下图(绿色代表已经执行，白色代表未执行) 而实际生产中JobGraph的图是非常复杂的，因此Chronos利用JobGraph能够很有效的进行任务的调度。 部分源码解析这里主要分析framework部分的主要核心代码： resourceOffers() 123456789101112131415161718192021222324252627282930//该方法实现调用mesos的scala接口，进行offer的分配 def resourceOffers(schedulerDriver: SchedulerDriver, receivedOffers: java.util.List[Offer]) &#123; log.info(\"Received resource offers\") import scala.collection.JavaConverters._ val offers = receivedOffers.asScala.toList val offerResources = mutable.HashMap(offers.map(o =&gt; (o, Resources(o))).toSeq: _*) //生成可以执行的task(详细见下文) val tasksToLaunch = generateLaunchableTasks(offerResources) log.info(\"Declining unused offers.\") // 创建一个Set保存已经使用的offer val usedOffers = mutable.HashSet(tasksToLaunch.map(_._3.getId.getValue): _*) //如果当前的offer已经被使用了（在usedOffers里出现），则decline掉 offers.foreach(o =&gt; &#123; if (!usedOffers.contains(o.getId.getValue)) mesosDriver.get().declineOffer(o.getId, declineOfferFilters) &#125;) log.info(s\"Declined unused offers with filter refuseSeconds=$&#123;declineOfferFilters.getRefuseSeconds&#125; \" + s\"(use --$&#123;config.declineOfferDuration.name&#125; to reconfigure)\") //执行任务 launchTasks(tasksToLaunch) // Perform a reconciliation, if needed. reconcile(schedulerDriver) &#125; generateLaunchableTasks（） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 def generateLaunchableTasks(offerResources: mutable.HashMap[Offer, Resources]): mutable.Buffer[(String, BaseJob, Offer)] = &#123; val tasks = mutable.Buffer[(String, BaseJob, Offer)]() // 属性约束检查 def checkConstraints(attributes: Seq[Protos.Attribute], constraints: Seq[Constraint]): Boolean = &#123; //遍历所有的属性约束 constraints.foreach &#123; c =&gt; if (!c.matches(attributes)) &#123; return false &#125; &#125; true &#125;//尾递归注解 @tailrec def generate() &#123; taskManager.getTask match &#123; case None =&gt; log.info(\"No tasks scheduled or next task has been disabled.\\n\") case Some((taskId, job)) =&gt; if (runningTasks.contains(job.name)) &#123; // 若当前的task正在执行，则从taskManager里将其去除 val deleted = taskManager.removeTask(taskId) log.warning(\"The head of the task queue appears to already be running: \" + job.name + \"\\n\") // 递归调用 generate() &#125; else &#123; tasks.find(_._2.name == job.name) match &#123; case Some((subtaskId, subJob, offer)) =&gt; //若发现已经调度的任务出现在队列中，则将其删除 val deleted = taskManager.removeTask(subtaskId) log.warning(\"Found job in queue that is already scheduled for launch with this offer set: \" + subJob.name + \"\\n\") //递归调用 generate() case None =&gt; //生产当前任务所需的资源，并且判断每个offer的各个资源是否能够满足 val neededResources = new Resources(job) offerResources.toIterator.find &#123; ors =&gt; ors._2.canSatisfy(neededResources) &amp;&amp; checkConstraints(ors._1.getAttributesList.asScala, job.constraints) &#125; match &#123; case Some((offer, resources)) =&gt; //若存在资源能够满足 // Subtract this job's resource requirements from the remaining available resources in this offer. //计算新资源，执行任务 resources -= neededResources tasks.append((taskId, job, offer)) //继续递归 generate() case None =&gt; // 资源不足，则将task重新加回队列（taskManager） val foundResources = offerResources.toIterator.map(_._2.toString()).mkString(\",\") log.warning( \"Insufficient resources remaining for task '%s', will append to queue. (Needed: [%s], Found: [%s])\" .stripMargin.format(taskId, neededResources, foundResources) ) taskManager.enqueue(taskId, job.highPriority) &#125; &#125; &#125; &#125; &#125; generate() tasks &#125; 从这段源码中可以看出来taskManaer事实上是一个task的优先队列。同时从generateLaunchableTasks()这个函数看出Chronos利用Scala的尾递归巧妙地处理了所有情况，保证调度器工作的执行。 总结Chronos是一个非常好的Mesos框架，同时它的源码采用scala语言进行编写，函数式编程也让代码看起来非常的舒畅。由于笔者毕业设计打算写一个Mesos Framework，所以Chronos是一个很好的典范！"},{"title":"Mesos Authentication详解","permalink":"http://blog.jetmuffin.com/2015/12/28/authentication-of-mesos/","text":"Authentication模块是Mesos中较为重要的一部分，涉及了整个系统的安全性。Mesos 0.15.0引入了framework authentication，0.19.0引入了slave authentication。Mesos Authentication只允许信任的实体可以和Mesos集群进行交互。 Mesos中的Authentication模块常用使用方法有三种： 要求framework必须被授权才能向master注册 要求slaves必须被授权才能获得resources offer 限制/teardown端的访问 工作原理Mesos的Authentication模块使用了Cyrus SASL Library实现验证。SASL提供了多种验证机制，包括（ANOYMOUS,PLAIN,’CRAM-MD5,GSSAPI`等）。 现在Mesos默认支持CRAM-MD5进行验证，单用户可以拓展自己的authentication modules（详见之后的文章mesos modules）。CRAM-MD5使用principal和secret对进行验证，其中principal代表framework的身份。注意，这里的framework并不是执行framework的user而是framework自身 配置在启动mesos节点时可以通过配置项来选择是否启用authentication模块，对哪些部分启用authentication。 Masters -authenticate/-no-authenticate 前者只允许授权的framework接入集群，后者还允许未授权的framework接入 -authenticate_slaves/-no-authenticate_slaves 前者只允许授权的slave介入集群，后者还允许未授权的framework接入 -authenticators 指定选用的authenticator module默认是crammd5，用户可以通过-modules选项进行拓展 -credentials 指定证书路径（可能因authenticator module不同而不一定使用该选项） Slaves -authenticatee 指定slave使用哪个authenticator module和master的authenticators进行授权。默认是crammd5 -credential 指定证书路径 例子这里使用默认的CRAM-MD5进行验证。 1.创建credentials文件 首先为master创建credentials文件，其中的内容像如下所示： 12principal1 secret1principal2 secret2 2. 启动master 然后启动master,并使用我们刚刚生成的credentials文件1/bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --authenticate --authenticate_slaves --credentials=~/credentials 3.创建slave的credentials 像步骤1一样创建slave的credentials 1principal1 secret1 4.启动slave 启动slave并进行验证： 1./bin/mesos-slave.sh --master=127.0.0.1:5050 --credential=~/slave_credential 6.framework验证 不同的framework的验证方法可能不同，可以写入scheduler driver的构造方法中，也可以在启动框架时加入，如下： 1MESOS_AUTHENTICATE=true DEFAULT_PRINCIPAL=principal2 DEFAULT_SECRET=secret2 ./src/test-framework --master=127.0.0.1:5050 结果： 使用credentials验证成功的slave: 未使用credentials验证的slave: 可以看到未使用的slave无法进行注册"},{"title":"Mesos Monitoring机制总结","permalink":"http://blog.jetmuffin.com/2015/12/23/mesos-monitor-policy/","text":"Mesos的master和slave提供了一组统计数据和指标，使用户能够方便地监控资源使用情况并且尽早发现异常状态。Mesos的监控包括可用资源，已经使用的资源，已经注册的框架，活跃的slave和任务的状态等。开发者可以利用这些监控信息实现自动化的报警，也可以在监控界面里绘制动态的监控图表。 指标Mesos提供了两种不同的指标：counter和gauge。 counter（计数器）用来跟踪不连续的事件。它是单向递增的，并且它的类型是自然数。典型的例子就是失败的任务数量、注册的slave数量等。对于这类指标，变化率比数值本身更加重要。 gauge(我也不知道怎么翻译好）代表一瞬间的某个属性的测量值。例如当前集群中使用内存的总量，在线的slave连接数量。这类指标通常用来监控其是否在一段时间内高于或低于一个阈值（即是否异常）。 MasterapiMaster节点的指标对外提供了api，具体可通过浏览器访问1http://&lt;master-ip&gt;:5050/metrics/snapshot 来进行获取，访问该链接(GET请求）会返回一组JSON串，内容为指标名称和内容的键值对。 1. 指标内容：Slave总资源属于该类别的指标主要包括整个集群的可用资源总量和当前已经使用的资源部分。如果资源使用量持续高举不下，说明应该增加集群的资源总量，或者集群内的某个Framework已经运行失常。 指标 说明 类型 master/cpus_percent 已使用的CPU占总量百分比 Gauge master/cpus_used 已使用的CPU的个数 Gauge master/cpus_total CPU的总数 Gauge master/cpus_revocable_percent 可回收 Gauge master/cpus_revocable_total Number of revocable CPUs Gauge master/cpus_revocable_used Number of allocated revocable CPUs Gauge master/disk_percent 已使用的磁盘空间占总量百分比 Gauge master/disk_used 已使用的磁盘空间(MB为单位) Gauge master/disk_used 已使用的磁盘空间(MB为单位) Gauge master/disk_total 磁盘总空间(MB为单位) Gauge master/disk_revocable_percent Percentage of allocated revocable disk space Gauge master/disk_revocable_total Revocable disk space in MB Gauge master/disk_revocable_used Allocated revocable disk space in MB Gauge master/mem_percent 已使用的内存占总量百分比 Gauge master/mem_used 已使用的内存（MB为单位） Gauge master/mem_total 内存总量（MB为单位） Gauge master/mem_revocable_percent Percentage of allocated revocable memory Gauge master/mem_revocable_total Revocable memory in MB Gauge master/mem_revocable_used Allocated revocable memory in MB Gauge 2. 指标内容：Master状态这部分的指标主要说明Master是否是leading master，它已经启动运行了多长时间。当一个集群经过一段时间依然没有选出leading master，则认为这个集群已经处于故障状态。这说明要么竞选过程出现问题（检查 ZooKeeper 的连接），要么选出的 Master 有故障。此外较短的已经运行时间表明Master近期有过重启。 指标 说明 类型 master/elected 是否是 leading master Gaude master/uptime_secs 已经运行时间（秒） Gaude 3. 指标内容：Master资源这部分的指标主要说明指定Master的资源总量和使用情况。Master节点资源使用率长期高居不下，可能会影响集群的整体性能。区别于1中的资源，以下的system的资源特指Master的资源，而1中为Slave的总体资源情况 指标 说明 类型 system/cpus_total 在这个master的可用 CPU 的数量 Guage system/load_15min 过去15分钟的平均负载 Guage system/load_5min 过去5分钟的平均负载 Guage system/load_1min 过去1分钟的平均负载 Guage system/mem_free_bytes 空闲内存的字节数 Guage system/mem_total_bytes 全部内存的字节数 Guage 4. 指标内容：Slave状态改部分的指标主要包括Slave的事件、Slave数量和Slave状态的信息。活跃的Slave数量过少表明这个集群的Slave不健康，或者它们无法连接到当前的leading master。 指标 说明 类型 master/slave_registrations 能够顺利地完成与Master断开然后 重联的Slave的数量 Counter master/slave_removals 各种原因被删除的Slave数量，包括维护 Counter master/slave_reregistrations 重新注册的 slave 的数目 Counter master/slave_shutdowns_scheduled 因为健康检查失败而被计划删除 的 slave 的数量。由于对删除 slave 的速度有限制（Slave Removal Rate-Limit），所以它们不一定会立即被删除。 当他们真正被删掉，指标 master/slave_shutdowns_completed 会增加。 Counter master/slave_shutdowns_cancelled 被取消的删除 slave 操作的数量。 发生在因为删除 Slave 有限速，slave 在被删除之前有机会成功重连并且发送 PONG 给 master Counter master/slave_shutdowns_completed 成功地被删除了的 Slave 的数量 Counter master/slaves_active 活跃的 slave 的数量 Guage master/slaves_connected 连接在线的 slave 的数量 Guage master/slaves_disconnected 断开离线的 slave 的数量 Guage master/slaves_inactive 不活跃的 slave 的数量 Guage"},{"title":"FZUOJ 1759 Super A^B mod C 指数循环节","permalink":"http://blog.jetmuffin.com/2015/12/08/fzuoj-1759-super-a-b-mod-c/","text":"题目http://acm.fzu.edu.cn/problem.php?pid=1759 题意给定A，B和C的值，求$A^{B}modC的值，其中1&lt;=A,C&lt;=1e10,1&lt;=B&lt;=10e1000000 分析今天刚刚学到一个内容，指数降幂公式，即$A^{B}modC=A^{Bmodphi(c)+phi(c)}modC$ 用这个公式，可以很方便地对大指数问题进行降维处理。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000005;typedef long long ll;char str[maxn];int phi(int n)&#123; int res = n; for(int i = 2; i * i &lt;= n; i++)&#123; if(n % i == 0)&#123; res = res - res / i; while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) res = res - res / n; return res;&#125;ll multi(ll a, ll b, ll m)&#123; ll ans = 0; a %= m; while(b)&#123; if(b &amp; 1)&#123; ans = (ans + a) % m; b--; &#125; b &gt;&gt;= 1; a = (a + a) % m; &#125; return ans;&#125;ll quickmod(ll a, ll b, ll m)&#123; ll ans = 1; a %= m; while(b)&#123; if(b &amp; 1)&#123; ans = multi(ans, a, m); b--; &#125; b &gt;&gt;= 1; a = multi(a,a,m); &#125; return ans;&#125;int main()&#123; ll a,c; while(~scanf(\"%I64d%s%I64d\", &amp;a, str, &amp;c))&#123; ll len = strlen(str); ll ans = 0; ll p = phi(c); if(len &lt;= 15)&#123; for(int i = 0 ; i &lt; len; i++) ans = ans * 10 + str[i] - '0'; &#125;else&#123; // A^B%C = A^(B%phi(C)+phi(C))%C for(int i = 0 ; i &lt; len ; i++)&#123; ans = ans * 10 + str[i] - '0'; ans %= p; &#125; ans += p; &#125; printf(\"%I64d\\n\", quickmod(a,ans,c)); &#125;&#125;"},{"title":"杭电校赛部分赛题题解","permalink":"http://blog.jetmuffin.com/2015/11/29/solution-to-hdu-school-contest/","text":"下午大家在做题的时候我把后面几个题目写了写，写一个题解和大家分享。简单题大家自己讨论下，可能有什么坑的，自己细心点就行了。这里主要写一下1003，1005，1006，1007的题解。下午没怎么认真做，代码写的乱七八糟，大家见谅。 1003 玩骰子题意两个人扔骰子，根据规则（有三条、对子、散牌什么的，具体看题）比较大小，大的人赢。现在主角已经扔了一个结果了，然后对方也扔了一个结果，主角有一个机会选择一个数重新扔一次，问获胜的几率有多少。 这里有个需要理解一下的地方，因为主角很机智，所以肯定不会选择毫无胜算的数字来重新扔（就是选择了一个数字，重新扔骰子，扔出来的数字不管是多少都不会改变输的结果），所以算概率的时候分母注意一下不是全部的可能性，而是选择的可能性。 分析这题就是个大模拟。。写一个结构体把比较函数写清楚了（注意罗列所有情况），然后暴力枚举吧，注意如果win的数量为0，就不要加tot了，然后取所有数里面赢的概率最大的为结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int x, int y)&#123; return x &gt; y;&#125;int vis[6];struct node&#123; int n[3]; int t; int tn; int tnn; node(int a, int b, int c)&#123; n[0] = a; n[1] = b; n[2] = c; sort(n, n+3, cmp); if(n[0] == n[2])&#123; t = 3; tn = n[0]; &#125;else if(n[0] == n[1])&#123; t = 2; tn = n[1]; tnn = n[2]; &#125;else if(n[1] == n[2])&#123; t = 2; tn = n[1]; tnn = n[0]; &#125;else&#123; t = 1; tn = n[0]; &#125; &#125; int ncmp(node y)&#123; if(t == y.t)&#123; if(t == 1)&#123; if(n[0] == y.n[0])&#123; if(n[1] == y.n[1])&#123; if(n[2] == y.n[2])&#123; return 2; &#125;else&#123; return n[2] &gt; y.n[2]; &#125; &#125;else&#123; return n[1] &gt; y.n[1]; &#125; &#125;else&#123; return n[0] &gt; y.n[0]; &#125; &#125;else if(t==2)&#123; if(tn == y.tn)&#123; return tnn &gt; y.tnn; &#125;else&#123; return tn &gt; y.tn; &#125; &#125;else &#123; return n[0] &gt; y.n[0]; &#125; &#125;else&#123; return t &gt; y.t; &#125; &#125; void print()&#123; cout&lt;&lt;n[0]&lt;&lt;\" \"&lt;&lt;n[1]&lt;&lt;\" \"&lt;&lt;n[2]&lt;&lt;\" \"&lt;&lt;t&lt;&lt;endl; &#125;&#125;;int main()&#123; int a, b, c,d,e,f; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%d%d%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f); node x = node(a,b,c); node y = node(d,e,f); // x.print(); // y.print(); // cout&lt;&lt;x.ncmp(y)&lt;&lt;endl; if(x.ncmp(y)==1)&#123; printf(\"%.3lf\\n\", 1.0); continue; &#125; int tot = 6; int win = 0; double ans = 0; for(int i = 1; i &lt;=6; i++)&#123; node z = node(i,b,c); if(z.ncmp(y)==1)&#123; win++; &#125; &#125; ans = max(ans,(double)win/(double)tot); win = 0; for(int i = 1; i &lt;=6; i++)&#123; node z = node(a,i,c); if(z.ncmp(y)==1)&#123; win++; &#125; &#125; ans = max(ans,(double)win/(double)tot); win = 0; for(int i = 1; i &lt;=6; i++)&#123; node z = node(a,b,i); if(z.ncmp(y)==1)&#123; win++; &#125; &#125; ans = max(ans,(double)win/(double)tot); printf(\"%.3f\\n\", ans); &#125;&#125; ACM组队安排题意n个人组队，每队人数可以为1或2或3，问组队的方案数。 思路12345void dfs(int a, int b, int c)&#123; //a为组队人数3的队伍数，b为组队人数2的队伍数，类推。。。 dfs(a,b+1,c-2) //取两个孤立的人组成一队2个人的 dfs(a+1,b-1,c-1) //取1个孤立的人和1队2人的组成1队3人的&#125; 为了把所有状态都搜遍，我们从dfs(0,0,n)开始，按上述的搜索方法进行搜索，标记已经访问过的状态vis[a][b][c]。 然后对于某个状态(a,b,c)，求方案数用排列组合的思路搞搞就出来了。 例如(1,2,1)，方案数是C(3,8)/1! * (C(2,5) * C(2,3))/2! * C(1,1)/1!。具体就是，8个人挑3个人，5个人挑2个，3个人挑2个，剩下1个人, 各算出方案数，然后乘法原理乘一下就是的了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longusing namespace std;ll ans = 0;ll fact[11];int vis[25][25][25];void init()&#123; fact[1] = 1; for(int i = 2; i &lt;= 10; i++)&#123; fact[i] = fact[i-1]*i; &#125;&#125;ll c2(int n)&#123; if(n &lt; 2) return 1; return n*(n-1)/2;&#125;ll c3(int n)&#123; if(n &lt; 3) return 1; return n*(n-1)*(n-2)/6;&#125;ll sum(int a, int b, int c)&#123; ll t = 1; int k = a*3+b*2+c; for(int i = 1; i &lt;= a; i++)&#123; t *= c3(k); k -= 3; &#125; if(a) t/=fact[a]; for(int i = 1; i &lt;= b; i++)&#123; t *= c2(k); k -= 2; &#125; if(b) t/=fact[b]; return t;&#125;void dfs(int a, int b, int c)&#123; vis[a][b][c] = true; // cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;\" \"&lt;&lt;sum(a,b,c)&lt;&lt;endl; ans += sum(a,b,c); if(c-2&gt;=0 &amp;&amp; !vis[a][b+1][c-2])&#123; dfs(a, b+1, c-2); &#125; if(b-1 &gt;= 0 &amp;&amp; c-1 &gt;=0 &amp;&amp; !vis[a+1][b-1][c-1])&#123; dfs(a+1, b-1, c-1); &#125;&#125;int main()&#123; int n; init(); while(~scanf(\"%d\",&amp;n) &amp;&amp; n)&#123; ans = 0; memset(vis,0,sizeof(vis)); dfs(0,0,n); cout&lt;&lt;ans&lt;&lt;endl; // cout&lt;&lt;sum(1, 1, 0)&lt;&lt;endl; &#125;&#125; 以上思路为错误方法~~~(虽然可以过这道题)。 在写的时候忽然发现这是一道很简单的dp… 123f[i]=f[i-1];//第i个人自己组队f[i]+=f[i-2]*(i-1);//第i个人与前面i-1个人中的一个人组队，有i-1种方法，剩下的i-2个人进行组队，即f[i-2]种方法。f[i]+=f[i-3]*(i-1)*(i-2)/2;//前面的i-1个人中，挑2个人和第i个人组队(C(2,n-1)，剩余i-3个人组队(f(i-3)) 然后f[1]，f[2]，f[3]都告诉你了，然后你懂的了。。 所以大家还是按正确的方法写吧…ORZ~ 1006 逆袭指数题意给定一个数n，求n的最长的连续的因子，输出为i*(i+1)*(i+2)...。同时乘起来的因子还是n的因子。如630：5*6*7，5*6*7=210是630的因子。 分析直接上去暴力搞，枚举n的所有因子p，然后从p开始向后枚举，枚举到最长的时候就行。由于大多数因子连续都在前面的数里，所以复杂度不会很高。 注意：从p向后枚举时要枚举到n为止而不是sqrt(n)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;vector &lt;int&gt; fac;vector &lt;int&gt;::iterator it;bool vis[1000000];int ans = 0;vector&lt;int&gt; path;long long n;void dfs(int k)&#123; int len = 0; long long t = n; vector&lt;int&gt; v; for(int i = k; i &lt;= n; i++)&#123; if(t % i == 0)&#123; t /= i; vis[i] = true; len++; v.push_back(i); &#125;else&#123; break; &#125; &#125; if(len &gt; ans)&#123; ans = len; int size = v.size(); path.clear(); for(int i = 0; i &lt;= size; i++) path.push_back(v[i]); &#125;&#125;int main()&#123; while(~scanf(\"%lld\",&amp;n))&#123; ans = 0; int size = fac.size(); for(int i = 2; i*i &lt;= n; i++)&#123; dfs(i); &#125; size = path.size(); if(ans == 0)&#123; puts(\"1\"); cout&lt;&lt;n&lt;&lt;endl; continue; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 0; i &lt; ans; i++)&#123; if(i &lt; ans-1) cout&lt;&lt;path[i]&lt;&lt;\"*\"; else cout&lt;&lt;path[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 1007 油菜花王国题意现在有n个精力，输入他们的能力k[i]，如果k[i]是斐波那契数，那么他的威望值f[i]为1，反之为0.然后给了m个关系(u,v)表示u和v是同一个家族，家族的威望是他们的和。最后求威望最大的家族的威望。 分析额，非常裸的并查集。 首先，斐波那契判断很方便，预处理一下存数组就行了。注意：不用快速幂什么的。。因为大概第45项就超过1000000000了。。，然后判断也就从前往后扫如果相等就返回。。反之随便搞搞。。 然后是并查集，直接上模板，记得合并merge操作的时候，把子节点的威望加到父节点上去。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longll fibo[50];int f[1050];int fa[1050];void init()&#123; fibo[1] = 1; fibo[2] = 1; for(int i = 3; i &lt;= 45; i++)&#123; fibo[i] = fibo[i-2] + fibo[i-1]; &#125;&#125;int check(int n)&#123; for(int i = 1; i &lt;= 45; i++)&#123; if(n == fibo[i]) return 1; if(n &lt; fibo[i]) return 0; &#125;&#125;int find(int x)&#123; if(x != fa[x]) fa[x] = find(fa[x]); return fa[x];&#125;void merge(int x,int y)&#123; int a = find(x),b = find(y); if(a != b)&#123; fa[b] = a; f[a] += f[b]; &#125;&#125;int main()&#123; init(); int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m))&#123; int u,v,t; memset(f,0,sizeof(f)); memset(fa,0,sizeof(fa)); for(int i = 1; i &lt;=n; i++)&#123; fa[i] = i; scanf(\"%d\",&amp;t); f[i] = check(t); &#125; for(int i = 0; i &lt; m; i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); merge(u,v); &#125; int ans = 0; for(int i = 1; i &lt;= 1000; i++)&#123; if(f[i] &gt; ans)&#123; ans = f[i]; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 最后说两句题目都很简单，大家最好在之后都去把没做出来的题目再做做，继续刷题！"},{"title":"Mesos 调度机制及调度算法初探","permalink":"http://blog.jetmuffin.com/2015/11/23/schedule-policy-of-mesos/","text":"再次分析Mesos的工作原理，将Mesos中出现的各个名词串联到一起。 前言Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核,Mesos将集群的所有节点的数据统一进行管理，打造一个DCOS(Data Center Operation System)的概念。调度算法是Mesos最核心也是灵魂部分。 调度架构1. 两层架构第一层，由Mesos将资源分配给框架；第二层，框架自己的调度器将资源分配给自己内部的任务。两层框架可以使得Mesos不需要知道任务的资源需求量，不需要知道任务的类型和数据存储，只需要和框架进行交互就行了。 2. Resource OfferMesos中的调度机制被称为“Resource Offer”，采用了基于资源量的调度机制。在Mesos中，Slave直接将资源量（CPU和内存）汇报给Master，由master将资源量按照某种机制分配给Framework，其中，“某种机制”是“Dominant Resource Fairness（DRF）”，在后面会提到该内容。 Framework可以根据是否符合任务对资源的约束，选择接受或拒绝offer。一旦offer被接受，Framework将与Master协作调度任务，并在数据中心的相应Slave节点上运行任务。 两个使Resource Offer高效且具有鲁棒性的附加机制： filters机制： 每次调度，mesos-master和framework-scheduler需要进行通信，如果过多的拒绝offer会带来额外的通信开销，因此mesos提供了filters机制，允许Framework只接收资源量大于L的offer（换句话说被过滤的offer不会发送到Framework) rescinds机制： 如果某个Framework接受了某个offer，然而长时间没有为该offer分配任务，而占有该offer（占着xx不xx），Mesos会回收其offer，并将其分配给其他Framework 调度工作流程 如上图所示，整个资源调度的工作过程为： Slave定期向Master汇报其机器上的资源情况（包括cpu,mem,disk,port等）。 Master上的模块Allocator根据DRF算法决定要讲资源分配给哪个Framework，并将资源以offer形式发送给分配的Framework。（一层调度） Framework编写时约束了每个Task执行需要的资源（cpu,mem,disk等），Framework根据约束筛选分配到的offer，可以选择接受offer，或者拒绝offer。若拒绝，offer随即可以被给其他Framework。（二层调度） 每个Task对应一个offer，也对应一个Slave，则该Task会被该Slave上的守护进程Executor执行。同时，为了资源隔离，Mesos为任务的执行提供了Isolator隔离器，为了保证资源不会被其他Task访问，可用的Isolator有Linux Container，Docker等。 由于Master很有可能出现单点故障，因此需要设立多Master，利用Zookeeper容错，保证集群运行的一致性。 补充：Mesos提供了拓展模块，使得我们如果要修改Mesos的部分内容，可以不用修改源码重新编译，而在以上流程中的Allocator（重写调度方法）、Isolator（重写资源隔离方法）均可以进行拓展，此外我还发现了Slave上的Estimator也能进行重写拓展，具体内容之后补充。 DRF算法如何作出offer分配的决定是由资源分配模块Allocator实现的，该模块存在于Master之中。资源分配模块确定Framework接受offer的顺序，与此同时，确保在资源利用最大化的条件下公平地共享资源。 由于Mesos为跨数据中心调度资源并且是异构的资源需求时，资源分配相比普通调度将会更加困难。因此Mesos采用了DRF（主导资源公平算法 Dominant Resource Fairness）,该算法同样出自于UC Berkeley。DRF的目标是确保每一个用户，即Mesos中的Framework，在异质环境中能够接收到其最需资源的公平份额。 Framework拥有的全部资源类型份额中占最高百分比的就是Framework的主导份额。DRF算法会使用所有已注册的Framework来计算主导份额，以确保每个Framework能接收到其主导资源的公平份额。 Mesos源码中默认的Allocator，即HierarchicalDRFAllocator的位置在$MESOS_HOME/src/master/allocator/mesos/hierarchical.hpp，而DRF中对每个Framework排序的Sorter位于$MESOS_HOME/src/master/allocator/sorter/drf/sorter.cpp，可以查看其源码了解它的工作原理。 一个说明性的例子考虑一个9CPU，18GBRAM的系统，拥有两个用户，其中用户A运行的任务的需求向量为{1CPU, 4GB}，用户B运行的任务的需求向量为{3CPU，1GB}，用户可以执行尽量多的任务来使用系统的资源。 在上述方案中，A的每个任务消耗总cpu的1/9和总内存的2/9，所以A的dominant resource是内存；B的每个任务消耗总cpu的1/3和总内存的1/18，所以B的dominant resource为CPU。DRF会均衡用户的dominant shares，执行3个用户A的任务，执行2个用户B的任务。三个用户A的任务总共消耗了{3CPU，12GB}，两个用户B的任务总共消耗了{6CPU，2GB}；在这个分配中，每一个用户的dominant share是相等的，用户A获得了2/3的RAM，而用户B获得了2/3的CPU。 以上的这个分配可以用如下方式计算出来：x和y分别是用户A和用户B的分配任务的数目，那么用户A消耗了{xCPU，4xGB}，用户B消耗了{3yCPU，yGB}，在图三中用户A和用户B消耗了同等dominant resource；用户A的dominant share为4x/18，用户B的dominant share为3y/9。所以DRF分配可以通过求解以下的优化问题来得到： 12345max(x,y) #(Maximize allocations) subject to x + 3y &lt;= 9 #(CPU constraint) 4x + y &lt;= 18 #(Memory Constraint) 2x/9 = y/3 #(Equalize dominant shares) 最后解出x=3以及y=2，因而用户A获得{3CPU，12GB}，B得到{6CPU， 2GB}。 DRF在Mesos中的一个例子换个使用场景，假设有数据中心包含一个offer为9核CPU和18GB内存。Framework 1运行的任务需要（1核CPU、4GB内存），Framework 2运行的任务需要（3核CPU、2GB内存）。Framework 1的任务会消耗CPU总数的1/9、内存总数的2/9，Framework 1的主导资源是内存。同样，Framework 2的每个任务会CPU总数的1/3、内存总数的1/18，Framework 2的主导资源是CPU。 上面表中的每一行提供了以下信息： Framework chosen：收到最新offer的Framework。 Resource Shares：给定时间内Framework接受的资源总数，包括CPU和内存，以占资源总量的比例表示。 Dominant Share（主导份额：给定时间内Framework主导资源占总份额的比例，以占资源总量的比例表示。 Dominant Share %（主导份额百分比）：给定时间内Framework主导资源占总份额的百分比，以占资源总量的百分比表示。 CPU Total Allocation：给定时间内接受的所有Framework的总CPU资源。 RAM Total Allocation：给定时间内接受的所有Framework的总内存资源。 最初，两个Framework的主导份额是0％，我们假设DRF首先选择的是Framework 2，当然我们也可以假设Framework 1，但是最终的结果是一样的。 Framework 2接收offer并运行任务，使其主导资源成为CPU，主导份额增加至33％。 由于Framework 1的主导份额维持在0％，它接收offer并运行任务，主导份额的主导资源（内存）增加至22％。 由于Framework 1仍具有较低的主导份额，它接收offer并运行任务，增 加其主导份额至44％。 然后DRF将offer发送给Framework 2，因为它现在拥有更低的主导份额。 该过程继续进行，直到由于缺乏可用资源，不能运行新的任务。在这种情况下，CPU资源已经饱和。 然后该过程将使用一组新的offer重复进行。 需要注意的是：可以创建一个资源分配模块，使用加权的DRF使其偏向某个Framework或某组Framework。如前面所提到的，也可以创建一些自定义模块来提供组织特定的分配策略。 效率 细粒度分配资源（细到每个任务在哪个机器上跑）,这是最显而易见的好处，也是Mesos社区和Mesosphere经常津津乐道的。 支持各类应用资源共同管理，不用担心各个应用的资源冲突。 缺陷在众多文章中看到大家对Mesos缺陷评价的一些共同点: Mesos中的DRF调度算法过分的追求公平，没有考虑到实际的应用需求。 Mesos采用了Resource Offer机制，这种调度机制面临着资源碎片问题，即：每个节点上的资源不可能全部被分配完，剩下的一点可能不足以让任何任务运行，这样，便产生了类似于操作系统中的内存碎片问题。 由于Mesos采用了双层调度机制，在实际调度时，将面临设计决策问题：第一层和第二层调度器分别实现哪几个调度机制，即：将大部分调度机制放到第一层调度器，还是第一层调度器仅支持简单的资源分配"},{"title":"给Mesos换一个新的WebUI","permalink":"http://blog.jetmuffin.com/2015/11/23/change-mesos-ui/","text":"虽然Mesos已经给用户提供了一个webui(http://master:5050)，然而这个UI无法很直观地显示集群的资源状况，因此可以给Mesos换一个更帅气的UI！ 依赖由于项目需要nodejs和npm环境，所以最好先配置好nodejs环境，最好node版本高于4.0，不然可能会出现错误。 然后是构建项目需要的gulp，运行 1sudo npm install -g gulp 就可以了 安装这里使用的是Capgemini group写的开源UI，首先感谢一下作者们~ 项目地址为Capgemini/mesos-ui 首先把整个项目clone下来 1git clone https://github.com/Capgemini/mesos-ui mesos-ui 然后安装相关的依赖 12cd mesos-uisudo npm install 最后使用gulp对项目进行build就行了 1gulp build 使用Mesos配置web地址非常方便，只需要在启动Mesos时添加webui_dir=your_webui_dir就好了 1./bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --webui_dir=your_webui_dir 如果你的Mesos是以service的形式存在（换句话说就是不用自己手动启），也可以这么搞export MESOS_WEBUI_DIR=/your-path/mesos-ui/build/，然后重启服务 1sudo service mesos-master restart 也就OK了 然后可以登陆127.0.0.1:5050去看看新UI了~"},{"title":"Mac OS X 安装Less编译器","permalink":"http://blog.jetmuffin.com/2015/11/18/install-less-compiler-on-mac-os-x/","text":"Less是动态的CSS预处理语言，包含了很多动态语言的特性，之前在ubuntu下装过lessc来编译Less,换了Mac后发现找不到方法安装了，事实上用nodejs来安装，这里记录一下。 在原Ubuntu下安装lessc很简单，直接执行sudo apt-get install node-less就行了 然而在Mac OS X下，brew install node-less找不到相应的包，需要用nodejs来安装： 安装nodejs和npm 执行npm install -g less 编译something lessc style.less 同时我们可以在WebStorm中使用file watcher来监视文件的修改，直接生成css 找到lessc的位置，which lessc,一般lessc都在/usr/local/bin/lessc 在WebStorm中的”Preferences”里找到”File Wathcers”选项，在其中添加Less的watcher，其中的Program填入/usr/local/bin/lessc就行了 效果如图:"},{"title":"利用Docker和Marathon构建带数据分析的Web应用","permalink":"http://blog.jetmuffin.com/2015/11/16/use-docker-and-marathon-to-build-web-service-with-data-analysis/","text":"利用搭建的Mesos、Marathon和Docker的环境，搭建一个带数据分析模块的Web应用。 架构该应用是一个网上商店（mesosphere官网给的demo…)，是个虚构的在线商店，由(nginx+Redis)提供Web服务，同时通过ELK构建日志搜索部分。整个应用的架构如下： 整个应用的系统部分使用(Mesos+Marathon+Docker)构建，用的是之前我们用vagrant建好的集群。 方法下面记录下整个应用的构建步骤： (以下操作均在node1中进行) 首先从mesosphere官方的Github仓库clone下来所需要用到的配置和程序mhausenblas/m-shop。 1$ git clone https://github.com/mhausenblas/m-shop OK,然后我们要使用Marathon中的REST接口来处理之后的应用请求了 首先，查看所有的应用 12$ curl http://node1:8080/v2/apps&#123;&quot;apps&quot;:[&#123;&quot;id&quot;:&quot;/webapp&quot;,&quot;cmd&quot;:&quot;python -m SimpleHTTPServer&quot;,&quot;args&quot;:null,&quot;user&quot;:null,&quot;env&quot;:&#123;&#125;,&quot;instances&quot;:1,&quot;cpus&quot;:0.1,&quot;mem&quot;:16.0,&quot;disk&quot;:0.0,&quot;executor&quot;:&quot;&quot;,&quot;constraints&quot;:[],&quot;uris&quot;:[],&quot;storeUrls&quot;:[],&quot;ports&quot;:[10000],&quot;requirePorts&quot;:false,&quot;backoffSeconds&quot;:1,&quot;backoffFactor&quot;:1.15,&quot;maxLaunchDelaySeconds&quot;:3600,&quot;container&quot;:null,&quot;healthChecks&quot;:[],&quot;dependencies&quot;:[],&quot;upgradeStrategy&quot;:&#123;&quot;minimumHealthCapacity&quot;:1.0,&quot;maximumOverCapacity&quot;:1.0&#125;,&quot;labels&quot;:&#123;&#125;,&quot;acceptedResourceRoles&quot;:null,&quot;version&quot;:&quot;2015-11-15T11:55:42.437Z&quot;,&quot;versionInfo&quot;:&#123;&quot;lastScalingAt&quot;:&quot;2015-11-15T11:55:42.437Z&quot;,&quot;lastConfigChangeAt&quot;:&quot;2015-11-09T08:37:51.733Z&quot;&#125;,&quot;tasksStaged&quot;:0,&quot;tasksRunning&quot;:1,&quot;tasksHealthy&quot;:0,&quot;tasksUnhealthy&quot;:0,&quot;deployments&quot;:[]&#125;]&#125;[ 然后把这个没用的webapp给DELETE掉 12$ curl -X DELETE http://node1:8080/v2/apps/webapp&#123;&quot;version&quot;:&quot;2015-11-16T12:41:39.408Z&quot;,&quot;deploymentId&quot;:&quot;e8cc87f5-916b-4cab-9266-f72bb9756a56&quot;&#125; 然后把system group里的mesos-dns和sedi服务给PUT上去 12$ curl -X PUT &quot;http://node1:8080/v2/groups&quot; -d @m-shop/mesos-dns/system.json -H &quot;Content-type: application/json&quot;&#123;&quot;version&quot;:&quot;2015-11-16T13:09:13.545Z&quot;,&quot;deploymentId&quot;:&quot;98c3f565-f1fc-4162-b560-9f20ca5"},{"title":"hdu-5546-Acient-go-CCPC-G题-BFS","permalink":"http://blog.jetmuffin.com/2015/11/12/hdu-5546-Acient-go-CCPC-G-BFS/","text":"hdu 5546 Acient go CCPC G题 BFSCCPC(中国大学生程序设计竞赛）G题Acient go解题报告 题目链接http://acm.hdu.edu.cn/showproblem.php?pid=5546 题意两人下棋，给定了现在的棋盘状况，轮到当前玩家下棋，问是否能够下一步棋将对方棋子吃掉 分析当时在赛场上的思路还是正确的，求每个联通块周围的.的个数，计算的方法用bfs。然而我们在另一个地方出现了分歧，是否要取掉现在棋盘上已经被吃掉的棋子？题目上写着 When one of the player makes his move, check the opponent’s first. After removing the dead opponent;s components, check with the player’s components and remove the dead components. 然后我们就针对着这句话纠结了好久，要不要拿掉对方的死子，要不要拿掉自己的死子，孰先孰后？ 然而这也不是重点，敲完代码交了好几发WA，一直找不到错误出在哪里，卡了很久很久。 赛后良哥才发现一个最重要的问题，bfs计算每个联通块周围的.时，有可能会出现一个.被计算多次，顿时醒悟。 回来后把代码重新敲了，成功得到一个Accept，也是感慨地不行。 错误情况： 12345. . x x .. x o o x. . . o x. x o o x. . x x . 若简单相加，3行3列处的.会重复累加导致错误，正确的计算方法是类似floodfill的算法把每个联通块标号，相同联通块只能访问同一个.一次，而不同的联通块可以同时访问一个. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;char cb[20][20];char s[9];struct node&#123; int x, y; node()&#123;&#125; node(int a,int b):x(a),y(b)&#123;&#125; void print()&#123; cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;endl; &#125;&#125;;queue &lt;node&gt;q;int flag = 0;int vis[20][20];int colors[20][20];int dx[4] = &#123;0,1,0,-1&#125;;int dy[4] = &#123;1,0,-1,0&#125;;int tot,color;void bfs(int x, int y)&#123; node a = node(x, y); q.push(a); while(!q.empty())&#123; node b = q.front(); q.pop(); int curx = b.x; int cury = b.y; vis[curx][cury] = 1; for(int k = 0; k &lt; 4; k++)&#123; int nextx = curx + dx[k]; int nexty = cury + dy[k]; if(cb[nextx][nexty] == '.')&#123; if(colors[nextx][nexty] != color)&#123; tot++; colors[nextx][nexty] = color; &#125; &#125;else if(cb[nextx][nexty] == 'o')&#123; if(!vis[nextx][nexty])&#123; q.push(node(nextx,nexty)); &#125; &#125; &#125; &#125;&#125;int judge()&#123; flag = 0; memset(vis, 0, sizeof(vis)); memset(colors, 0, sizeof(colors)); color = 0; for(int i = 1; i &lt;= 9; i++)&#123; for(int j = 1; j &lt;= 9; j++)&#123; if(cb[i][j] == 'o' &amp;&amp; !vis[i][j])&#123; tot = 0; color++; bfs(i, j); if(tot == 1)&#123; return 1; &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; int cas = 0,T;#ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin); #endif // ONLINE_JUDGE scanf(\"%d\",&amp;T); while(T--)&#123; cas++; for(int i = 1; i &lt;= 9; i++)&#123; scanf(\"%s\", s); for(int j = 1; j &lt;= 9; j++)&#123; cb[i][j] = s[j-1]; &#125; &#125; for(int i = 0; i &lt; 11; i++)&#123; cb[i][0] = '-'; cb[0][i] = '-'; cb[i][10] = '-'; cb[10][i] = '-'; &#125; if(judge())&#123; printf(\"Case #%d: Can kill in one move!!!\\n\", cas); &#125;else&#123; printf(\"Case #%d: Can not kill in one move!!!\\n\",cas); &#125; &#125;&#125;"},{"title":"使用Mesos和Marathon搭建Docker集群","permalink":"http://blog.jetmuffin.com/2015/11/09/build-docker-cluster-with-mesos-and-marathon/","text":"利用Mesos，Marathon对Docker集群进行管理，保证高容错性，高拓展性。 部署1.创建Master节点虚拟机执行命令 1$: vagrant init 这时候会在当前文件夹下创建文件Vagrantfile，该文件是ruby语法的虚拟机配置文件，然后我们用vim修改该文件： 1$: vim Vagrantfile 将内容修改如下： 12345678910111213141516# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(2) do |config| config.vm.box = \"bento/centos-7.1\" config.ssh.insert_key = false config.vm.define \"node1\" do |node1| node1.vm.network \"private_network\", ip: \"192.168.33.10\" node1.vm.hostname = \"node1\" end config.vm.define \"node2\" do |node2| node2.vm.network \"private_network\", ip: \"192.168.33.11\" node2.vm.hostname = \"node2\" endend 该配置会生成两个使用系统centos-7.1的节点，分别分配IP为192.168.33.10和192.168.33.11，作为我们的Master和Slave。 然后我们启动第一个节点node1: 12345678910111213141516171819202122232425$: vagrant up node1Bringing machine &apos;node1&apos; up with &apos;virtualbox&apos; provider...==&gt; node1: Checking if box &apos;bento/centos-7.1&apos; is up to date...==&gt; node1: Clearing any previously set forwarded ports...==&gt; node1: Clearing any previously set network interfaces...==&gt; node1: Preparing network interfaces based on configuration... node1: Adapter 1: nat node1: Adapter 2: hostonly==&gt; node1: Forwarding ports... node1: 22 =&gt; 2222 (adapter 1)==&gt; node1: Booting VM...==&gt; node1: Waiting for machine to boot. This may take a few minutes... node1: SSH address: 127.0.0.1:2222 node1: SSH username: vagrant node1: SSH auth method: private key node1: Warning: Connection timeout. Retrying... node1: Warning: Remote connection disconnect. Retrying...==&gt; node1: Machine booted and ready!==&gt; node1: Checking for guest additions in VM...==&gt; node1: Setting hostname...==&gt; node1: Configuring and enabling network interfaces...==&gt; node1: Mounting shared folders... node1: /vagrant =&gt; /Users/jeff/workspace/mesos/cluster==&gt; node1: Machine already provisioned. Run `vagrant provision` or use the `--provision`==&gt; node1: flag to force provisioning. Provisioners marked to run always will still run. 这样第一个节点就成功启动了，然后我们通过ssh连接到node1进行操作 12$:vagrant ssh node1[vagrant@node1 ~]$ 这样就成功创建了第一个节点。 2.下载启动Mesos和Marathon在下载Mesos和Marathon之前，需要先把hosts文件修改一下，把127.0.0.1对应的解析中的node1删除，并在最后加上node1和node2的IP，修改后的hosts可见cat后的输出 1234567[vagrant@node1 ~]$ sudo vi /etc/hosts[vagrant@node1 ~]$ cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.33.10 node1192.168.33.11 node2 然后下载mesos的仓库，再安装mesos和marathon 12[vagrant@node1 ~]$ sudo rpm -Uvh http://repos.mesosphere.com/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm[vagrant@node1 ~]$ sudo yum install mesos marathon 3.下载配置Zookeeper下载zookeeper仓库并安装Zookeeper 12[vagrant@node1 ~]$ sudo rpm -Uvh http://archive.cloudera.com/cdh4/one-click-install/redhat/6/x86_64/cloudera-cdh-4-0.x86_64.rpm[vagrant@node1 ~]$ sudo yum -y install zookeeper zookeeper-server 初始化并启动Zookeeper 123456[vagrant@node1 ~]$ sudo -u zookeeper zookeeper-server-initialize --myid=1Using myid of 1[vagrant@node1 ~]$ sudo service zookeeper-server startJMX enabled by defaultUsing config: /etc/zookeeper/conf/zoo.cfgStarting zookeeper ... STARTED 4.下载安装Docker123[vagrant@node1 ~]$ sudo yum install -y docker[vagrant@node1 ~]$ sudo chkconfig docker on[vagrant@node1 ~]$ sudo service docker start 然后告诉mesos，允许使用Docker作为Container 12[vagrant@node1 ~]$ echo &apos;docker,mesos&apos; | sudo tee /etc/mesos-slave/containerizers[vagrant@node1 ~]$ sudo service mesos-slave restart 5.启动Mesos和Marathon启动Mesos 12[vagrant@node1 ~]$ sudo service mesos-master start[vagrant@node1 ~]$ sudo service mesos-slave start 这时可以从外部访问已经启动的Mesos的GUI界面了，访问地址为192.168.33.10:5050 启动Marathon 1[vagrant@node1 ~]$ sudo service marathon start 同样可以从GUI访问Marathon了，访问地址为192.168.33.10:8080 至此，Master节点的配置就已经结束了 6.创建配置Slave节点首先启动slave节点并用ssh登录 123$: vagrant up node2$: vagrant ssh node2[vagrant@node2 ~]$ 然后修改/etc/hosts并且下载Mesos，具体过程同步骤4。 123456789[vagrant@node2 ~]$ sudo vi /etc/hosts[vagrant@node2 ~]$ cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.33.10 node1192.168.33.11 node2[vagrant@node2 ~]$ sudo rpm -Uvh http://repos.mesosphere.com/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm[vagrant@node2 ~]$ sudo yum install mesos 编辑node2的/etc/mesos/zk文件，使得它指向node1。 123[vagrant@node2 ~]$ sudo vi /etc/mesos/zk[vagrant@node2 ~]$ cat /etc/mesos/zkzk://192.168.33.10:2181/mesos 启动Mesos（作为slave），并且关闭mesos-master服务的自动启动 123[vagrant@node2 ~]$ sudo service mesos-slave start[vagrant@node2 ~]$ sudo chkconfig mesos-slave on[vagrant@node2 ~]$ sudo chkconfig mesos-master off 安装Docker,并允许使用Docker作为容器 12345[vagrant@node2 ~]$ sudo yum install -y docker[vagrant@node2 ~]$ sudo chkconfig docker on[vagrant@node2 ~]$ sudo service docker start[vagrant@node2 ~]$ echo &apos;docker,mesos&apos; | sudo tee /etc/mesos-slave/containerizers[vagrant@node2 ~]$ sudo service mesos-slave restart 这样，slave节点的配置也结束了 6.测试我们打开Mesos的GUI界面，查看slave，可以看到现在已经有2个slave节点了，如下图。 然后我们创建一个简单的webapp，使用python -m SimpleHTTPServer 然后将webapp应用scale到2个实例 可以看到两个实例分别在两个不同的slave中运行了 1//Todo 后面会加上部署Docker的实例测试 打包虚拟机为了之后能够快速的部署，我们可以将node1和node2分别打包成mesos-master和mesos-slave，以便于增加节点。 退出ssh，首先将node1打包为mesos-master，在宿主机上执行： 123$: vagrant package node1$: vagrant box add mesos-master package.box$: vagrant destroy node1 同样对node2我们也将其打包为mesos-slave 123$: vagrant package node2$: vagrant box add mesos-slave package.box$: vagrant destroy node2 然后修改Vagrantfile，将其修改为： 1234567891011121314151617# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(2) do |config| config.vm.box = &quot;bento/centos-7.1&quot; config.ssh.insert_key = false config.vm.define &quot;node1&quot; do |node1| node1.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot; node1.vm.hostname = &quot;node1&quot; node1.vm.box = &quot;mesos-master&quot; end config.vm.define &quot;node2&quot; do |node2| node2.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.11&quot; node2.vm.hostname = &quot;node2&quot; endend 这样就完成了虚拟机的打包，然后分别运行： 12$: vagrant up node1$: vagrant up node2 就可以运行了，修改集群的slave数量，则可以直接修改Vagrantfile即可！"},{"title":"Mesos Framework解析","permalink":"http://blog.jetmuffin.com/2015/11/07/mesos-framework/","text":"Mesos Framework 解析介绍MesosMesos是Apache旗下的开源集群资源计算框架，它能将多台机器（包括物理机和虚拟机）的资源，包括CPU，内存，硬盘等计算资源抽象出来，进行资源隔离和共享，构建高容错性、高可用性的分布式资源管理系统。 Mesos FrameworkMesos采用两层架构，所有计算框架均在底层，即Mesos Master负责对任务的资源分配给各个框架；在计算框架之上为Mesos Framework，它可用是通用的框架，也可用为特定软件编写的框架，如Framework一个长时间运行的服务（比如JobTracker等），也可以是一个短生命周期的Job或者Application。这样设计的好处是，作为底层的Mesos不需要知道顶层的应用的细节，只负责根据slave资源状况提供offers，而调度由顶层的Framework进行实现，这样底层的Mesos对所有应用（分布式or集中式，长时间服务or短暂性任务等）均可适用。 Framework可以根据是否符合任务对资源的约束，选择接受或拒绝资源邀约。一旦资源邀约被接受，Framework将与Master协作调度任务，并在数据中心的相应Slave节点上运行任务。 Framework包含两大部分： Scheduler Scheduler负责管理框架所获得的资源，按照作业的输入量，将其分解成若干任务，并未这些任务申请资源，监控这些任务的运行状态，一旦发现某个任务运行失败则重新为其申请资源。 Executor Executor负责执行调度器所分配的任务。 Framework结构如图： 分析Framework任务分配过程Framework任务分配流程图如下： Mesos的资源分配行为发生在：新框架注册，框架注销，增加节点，出现空闲资源等情况，对Mesos Framework进行资源分配的流程如下： Mesos Master中的Allocator模块将要为某个Framework分配资源，则将资源封装到ResourceOffersMessage中，通过网络传输发送给SchedulerProcess SchedulerProcess调用用户在Scheduler中编写的resourceOffers函数，告知有新资源可用； Framework的Scheduler调用MesosSchedulerDriver中的launchTasks()函数，告知将要启动的任务； Mesos Master将待启动的任务分装成RunTaskMessage发送给各个Mesos Slave； Mesos Slave收到RunTaskMessage消息后，将其发送给对应的ExecutorProcess； ExecutorProcess收到消息后，进行资源本地化，并准备任务环境，最终调度用户编写的Exector中的launchTask任务启动任务。 Framework开放接口及作用Mesos向开发者开放了API，API隐藏了Mesos底层和分布式交互的具体的细节，使得开发者可方便地用根据相应使用环境编写对应的Framework，提供的接口支持C++，Go，Haskell，Java，Python，和Scala语言。 Scheduler API 方法 说明 registered() 当Scheduler成功向Master注册时被调用 reregistered() 当Scheduler再次注册成功时被调用 disconnected() 当Scheduler和Master失去连接时被调用 resourcesOffers() 当Framework收到Mesos提供的资源时被调用 offerRescinded() 当某个offer不再适用时调用(Slave丢失或者其他Framework正在适用这个offer),master撤销发送给Framework的资源 statusUpdate() 当Mesos向框架发送消息时被调用 frameworkMessage() 用来向Scheduler传递Executor发送的消息 slaveLost() 通知Mesos无法和指定ID的slave通信 executorLost() 通知Scheduler指定的Executor已经以某个状态结束了 error() 当Scheduler出现可恢复的错误时被调用 其中最重要的为resourceOffers(SchedulerDriver, List&lt;Offer&gt;)方法。Master向Framework提供资源offer，每一份资源offer包含从某个slave上获取的资源列表（包括CPU，内存，硬盘等）。开发者重写该方法，可用根据特定的情况接受资源offer，并利用offersId交给Executor启动任务，或者拒绝该offer。一个offer会提供给多个Framework，但是第一个使用offer启动任务的Framework会获胜，其他的Framework将受到offerRescinded()发出的消息。 Scheduler API 方法 说明 registered() 当Executor驱动成功和Mesos连接上时调用 reregistered() 当Executor再次向某个重启的slave注册时调用 disconnected() 当Executor和slave失去连接时调用 launchTask() 当Executor启动某个任务时调用 killTask() 当Executor杀死某个task时被调用 frameworkMessage() 当Framework的信息到达Executor时被调用 shutdown() 当Executor需要终止所有task时被调用 error() 当Scheduler出现不可恢复的错误时被调用 同样，Executor中最核心的方法是launchTask(ExecutorDriver, TaskInfo)。可重写该方法实现执行任务，任务将在offer来源的slave上执行。执行任务在方法调用时会被阻塞，在回调完成前，该Executor无法执行其他的任务。因此如果要执行一个长时间的任务（如Web应用)，可用把任务放在线程里，通过线程的方式启动。 Framework实例分析Mesos上已有许多Framework，包括支持MPI，Hadoop，Spark，Storm等应用的。这里主要利用简单的Framework分析如何实现一个Framework。 mesos-hydra，MPI Framework，该Framework是利用python进行的实现。 RENDLER,一个利用Mesos框架实现的分布式爬虫 1填坑，待看完全部代码后补上源码分析 Framework设计模式从现有的Mesos Framework分配调度使用资源的方式中，可用总结出以下几种模式。 用于协调资源：设计的Framework作为其他Framework的资源协调者，作为服务运行，如Mesos-DNS。 基于负载状况：设计的Framework根据负载来调节资源使用，如Marathon和Aurora，会根据约定自动进行扩容和缩容。 基于预留的框架：这里主要指，某些分布式应用，在设计时已经预留了资源调度的接口，如Hadoop，Spark，Storm，因此只要实现接口，就可以将应用从原有的调度框架（如Hadoop原有框架为YARN)移植到Mesos上来。"},{"title":"二分图的最大匹配 匈牙利算法","permalink":"http://blog.jetmuffin.com/2015/11/01/bipartite-graph-matching-hungry-algorithm/","text":"二分图的最大匹配 匈牙利算法概念匹配: 给定一个无向图G=(V, E),一个匹配是边的一个子集M⊇E，使得对于所有节点v∈V，子集M中最多有一条边与节点v相连。—— 《算法导论》 在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。 我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。 定理最大匹配数：最大匹配的匹配边的数目最小点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择最大独立数：选取最多的点，使任意所选两点均不相连 定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理） 定理2：最大匹配数 = 最大独立数 定理3：最小路径覆盖数 = 顶点数 - 最大匹配数 匈牙利算法 思路：匈牙利算法的主要思路是希望每一个左边的点都尽量在右边找到一个点和他匹配，若找不到匹配点，则想方设法给它腾出点来供他匹配。 流程：我们依次枚举左边的点x(如图2中的2)的所有出边指向点y（如图2中的5），若y之前没有被匹配，则(x,y)成为一对匹配，我们将匹配数加一；若y已经被匹配（假设图2中的5已经被1匹配）），那么我们需要将匹配y的x’重新找一个匹配（即给1再重新找一个匹配），若找到x’的新匹配（找到了7)，那么(x,y)还是能够成为一对匹配。 例子：原图为：顶点分为两类：首先对顶点1进行匹配，找到匹配点5然后对顶点2进行匹配，发现没有任何顶点可以匹配，于是对顶点5的原匹配点再重新找一个匹配，找到了匹配7接下来对顶点3配对，找到匹配6最后将4和8进行配对得到原图的最大匹配为4 伪代码：1234567function Find(u): 对于u的每一个相邻的，且没有被标记过的节点v: 标记v; 如果v未饱和（未得到匹配）或者Find(v的当前匹配点): 将v的匹配点修改为u 返回True 返回False 1234567function Main(): 将所有节点初始化为未饱和; 匹配数=0; 对于图中的每一个顶点u: 清空所有标记; 如果Find(u)，匹配数+=1; 返回匹配数 复杂度：即对于每个顶点，将 每条边遍历一遍，复杂度O(VE) 实现代码：123456789101112131415161718192021222324252627bool dfs(int u)//从左边开始找增广路径&#123; int v; for(v=0;v&lt;N;v++)//这个顶点编号从0开始，若要从1开始需要修改 if(g[u][v]&amp;&amp;!used[v]) &#123; used[v]=true; if(link[v]==-1||dfs(link[v])) &#123;//找增广路，反向 link[v]=u; return true; &#125; &#125; return false;//这个不要忘了，经常忘记这句&#125;int main()&#123; int res=0; int u; memset(link,-1,sizeof(link)); for(u=0;u&lt;N;u++) &#123; memset(used,0,sizeof(used)); if(dfs(u)) res++; &#125; return res;&#125; Hopcroft Karp算法Hopcroft Karp算法是对匈牙利算法的实现，每次不止增广一个非饱和顶点。复杂度`O(sqrt(V)E) 实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172bool searchP() &#123; dis=INF; int i,v,u; queue&lt;int&gt; Q; memset(dx,-1,sizeof(dx)); memset(dy,-1,sizeof(dy)); for(i=0;i&lt;Nx;i++) &#123; if(Mx[i]==-1) &#123; Q.push(i); dx[i]=0; &#125; &#125; while(!Q.empty()) &#123; u=Q.front(); Q.pop(); if(dx[u]&gt;dis) break; for(v=0;v&lt;Ny;v++) &#123; if(g[u][v]&amp;&amp;dy[v]==-1) &#123; dy[v]=dx[u]+1; if(My[v]==-1) dis=dy[v]; else &#123; dx[My[v]]=dy[v]+1; Q.push(My[v]); &#125; &#125; &#125; &#125; return dis!=INF; &#125; bool DFS(int u) &#123; int v; for(v=0;v&lt;Ny;v++) &#123; if(g[u][v]&amp;&amp;!used[v]&amp;&amp;dy[v]==dx[u]+1) &#123; used[v]=true; if(My[v]!=-1&amp;&amp;dy[v]==dis) continue; if(My[v]==-1||DFS(My[v])) &#123; My[v]=u; Mx[u]=v; return true; &#125; &#125; &#125; return false; &#125; int Hungary() &#123; int u; int ret=0; memset(Mx,-1,sizeof(Mx)); memset(My,-1,sizeof(My)); while(searchP()) &#123; memset(used,false,sizeof(used)); for(u=0;u&lt;Nx;u++) if(Mx[u]==-1&amp;&amp;DFS(u)) ret++; &#125; return ret; &#125;"},{"title":"源码编译安装Ambari","permalink":"http://blog.jetmuffin.com/2015/10/22/compile-and-install-ambari/","text":"源码编译安装Ambari 为什么笔者用源码编译的原因很简单，hortonworks的源太不稳定了，自己的几台Ubuntu的机子添加源后无法下载，且CentOS的机子添加源后无法下载ambari-agent，只能另辟蹊径使用源码编译 环境准备源码编译需要以下环境，需要提前安装： JDK Maven Python 2.6+ rpm-build g++,gcc,make等 NodeJS Brunch 因此需要先配置环境 安装JDK可以使用系统(CentOS)自带的openjdk，或者下载Oracle的JDK。安装后配置环境12345678[root@cloud01 ~]# vim /etc/profile# 在末尾添加 export JAVA_HOME=你的java地址# 在末尾添加 export path=$path:$JAVA_HOME/bin[root@cloud01 ~]# source /etc/profile[root@cloud01 ~]# java -versionjava version &quot;1.7.0_51&quot;Java(TM) SE Runtime Environment (build 1.7.0_51-b13)Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode) 如果java -version正常，则JDK安装成功 安装Maven 官网下载maven对应版本 解压 1[root@cloud01 ~]# tar -zxvf apache-maven-3.0.3-bin.tar.gz 设置环境变量 1234567891011[root@cloud01 ~]# vim /etc/profile#末尾添加 export MAVEN_HOME=你的maven地址#末尾添加 export path=$path:$MAVEN_HOME/bin[root@cloud01 ~]# source /etc/profile[root@cloud01 ~]# mvn -vApache Maven 3.0.3Maven home: /usr/local/apache-maven-3.0.3Java version: 1.7.0_51, vendor: Oracle CorporationJava home: /usr/local/jdk1.7.0_51/jreDefault locale: en_US, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;2.6.32-358.el6.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; 若 mvn -v正常，则maven安装成功 安装PythonCentOS自带Python，且CentOS6.5自带Python2.6，可以直接使用若版本过低或者未安装则执行1[root@cloud01 ~]# yum install python 安装rpm-build 检测rpm-build是否已经安装 1[root@cloud01 ~]# rpm -qa | grep rpm-build 若未安装，执行 1[root@cloud01 ~]# yum install rpm-build 安装g++等依赖执行1[root@cloud01 ~]# yum -y install gcc make gcc-c++ openssl-devel wget 安装NodeJS 下载源码及解压 12[root@cloud01 ~]# wget http://nodejs.org/dist/v0.10.26/node-v0.10.26.tar.gz[root@cloud01 ~]# tar -zvxf node-v0.10.26.tar.gz 编译及安装 123[root@cloud01 ~]# cd node-v0.10.26[root@cloud01 ~]# ./configuration[root@cloud01 ~]# make &amp;&amp; make install 验证安装配置是否成功 1node -v 编译 下载并解压源码 123[root@cloud01 ~]# wget http://www.apache.org/dist/ambari/ambari-2.1.2/apache-ambari-2.1.2-src.tar.gz[root@cloud01 ~]# tar xfvz apache-ambari-2.1.2-src.tar.gz[root@cloud01 ~]# cd apache-ambari-2.1.2-src 编译 12345[root@cloud01 ~]# mvn versions:set -DnewVersion=2.1.2[root@cloud01 ~]# pushd ambari-metrics[root@cloud01 ~]# mvn versions:set -DnewVersion=2.1.2[root@cloud01 ~]# popd[root@cloud01 ~]# mvn -B clean install package rpm:rpm -DnewVersion=2.1.2 -DskipTests -Dpython.ver=&quot;python &gt;= 2.6&quot; 安装rpm 1[root@cloud01 ~]# yum install ambari-server*.rpm 错误总结 出现异常：ClassNotFoundException: org.slf4j.helpers.MarkerIgnoringBase 使用低于Maven 3.3.3的版本，我用的是Maven 3.0.5 node-gyp rebuilt卡住原因是node-gyp rebuilt 会去下载源码rebuilt生成头文件，而国外的npm源非常慢，所以可以手动修改执行： 12npm install node-gyp node-gyp install --dist-url http://npm.taobao.org/mirrors/node 或者直接修改： 123456789101112# 获得 nodejs 版本号NODE_VERSION=`node -v | cut -d&apos;v&apos; -f 2`# 下载源码包wget http://npm.taobao.org/mirrors/node/v$NODE_VERSION/node-v$NODE_VERSION.tar.gz# 删除现有内容不完整的目录rm -rf ~/.node-gypmkdir ~/.node-gyp# 解压缩并重命名到正确格式tar zxf node-v$NODE_VERSION.tar.gz -C ~/.node-gypmv ~/.node-gyp/node-v$NODE_VERSION ~/.node-gyp/$NODE_VERSION# 创建一个标记文件printf &quot;9\\n&quot;&gt;~/.node-gyp/$NODE_VERSION/installVersion"},{"title":"Ambari搭建Hadoop管理平台","permalink":"http://blog.jetmuffin.com/2015/10/19/building-hadoop-manage-platform-on-ambari/","text":"介绍Apache Ambari项目的目标是通过配置、管理、监控Hadoop集群，使得Hadoop集群的管理更加简单。Ambari提供了直观易用、基于Restful APIs的Web UI。Ambari使得系统管理员可以： 配置Hadoop集群 Ambari提供了逐步安装Hadoop服务的向导 Ambari处理了Hadoop集群中复杂的配置 管理Hadoop集群 Ambari对整个Hadoop集群提供了中心管理服务，可以进行Hadoop的启动、终止和重新配置。 监控Hadoop集群 Ambari提供了监控Hadoop集群健康和状态的控制台 Ambari使用Ambari Metrics System进行各项指标的收集 Ambari使用Ambari Alert Framework进行系统报警（当节点宕机或者剩余空间不足等） 安装Ambari(Ubuntu 14.04)step1: 从服务器下载Ambari12cd /etc/apt/sources.list.dwget http://public-repo-1.hortonworks.com/ambari/ubuntu14/2.x/updates/2.1.2/ambari.list step2: 安装、启动Ambari Server从Ambari仓库下载Ambari Server：123apt-key adv --recv-keys --keyserver keyserver.ubuntu.com B9733A7A07513CADapt-get updateapt-get install ambari-server 执行命令配置Ambari Server, Database, JDK, LDAP，和其他配置项：1ambari-server setup 启动 Ambari Server：1ambari-server start step3: 使用Ambari Web UI浏览器打开地址http://&lt;ambari-server-host&gt;:8080使用账号admin和密码admin进行登录 配置环境配置mysql数据库12345mysql -u root -pmysql&gt; create database ambari;mysql&gt; use ambari;Database changedmysql&gt;source /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql 设置ambari-server1ambari-server setup 过程中会要求配置运行用户、JDK、数据库等内容 启动ambari-server1ambari-server start 若启动失败，可以查看/var/log/ambari-server/ambari-ser.out对于以下错误： com.mysql.jdbc.exceptions.jdbc4.Communicationsxception: Communications link failure 可以采取以下方法：1234vim /etc/mysql/my.cnf# 将bind-address: 127.0.0.1 改为 bind-address: 0.0.0.0/etc/init.d/mysql restartambari-server restart"},{"title":"[转] 广义Fibonacci数列找循环节","permalink":"http://blog.jetmuffin.com/2015/09/20/generalized-fibonacci-sequence-to-find-the-circular-section/","text":"出处转自ACDreamer的博客 问题给定，满足，求的循环节长度。 分析我们知道矩阵的递推关系如下: 然后继续有: 那么，现在的问题就转化为求最小的，使得 所以我们可以先找出符合条件的一个，然后枚举它的因子，找最小的。设 为了好解决问题，我们需要对矩阵进行相似对角化，即的特征值 解得的特征值为 也就是说的相似对角矩阵为 因为我们知道，所以当时，，由于 继续得到 设，那么分情况讨论： 是模的二次剩余，由费马小定理得时， 是模的二次非剩余，则有 ,根据欧拉准则有 那么继续得到 然后由费马小定理有，同理有所以，当时， 时，由于不存在，所以无法完成相似对角化，好在情况不存在。 所以综上所述： 是模的二次剩余时，枚举的因子 是模的二次非剩余时，枚举的因子 找最小的因子使得 成立 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;typedef long long LL;const int N = 2;const LL MOD = 1000000007;LL fac[2][505];int cnt,ct;LL pri[6] = &#123;2, 3, 7, 109, 167, 500000003&#125;;LL num[6] = &#123;4, 2, 1, 2, 1, 1&#125;;struct Matrix&#123; LL m[N][N];&#125; ;Matrix A;Matrix I = &#123;1, 0, 0, 1&#125;;Matrix multi(Matrix a,Matrix b)&#123; Matrix c; for(int i=0; i&lt;N; i++) &#123; for(int j=0; j&lt;N; j++) &#123; c.m[i][j] =0; for(int k=0; k&lt;N; k++) &#123; c.m[i][j] += a.m[i][k] * b.m[k][j]; c.m[i][j] %= MOD; &#125; &#125; &#125; return c;&#125;Matrix power(Matrix A,LL n)&#123; Matrix ans = I, p = A; while(n) &#123; if(n &amp; 1) &#123; ans = multi(ans,p); n--; &#125; n &gt;&gt;= 1; p = multi(p,p); &#125; return ans;&#125;LL quick_mod(LL a,LL b)&#123; LL ans = 1; a %= MOD; while(b) &#123; if(b &amp; 1) &#123; ans = ans * a % MOD; b--; &#125; b &gt;&gt;= 1; a = a * a % MOD; &#125; return ans;&#125;LL Legendre(LL a,LL p)&#123; LL t = quick_mod(a,(p-1)&gt;&gt;1); if(t == 1) return 1; return -1;&#125;void dfs(int dept,LL product = 1)&#123; if(dept == cnt) &#123; fac[1][ct++] = product; return; &#125; for(int i=0; i&lt;=num[dept]; i++) &#123; dfs(dept+1,product); product *= pri[dept]; &#125;&#125;bool OK(Matrix A,LL n)&#123; Matrix ans = power(A,n); return ans.m[0][0] == 1 &amp;&amp; ans.m[0][1] == 0 &amp;&amp; ans.m[1][0] == 0 &amp;&amp; ans.m[1][1] == 1;&#125;int main()&#123; fac[0][0] = 1; fac[0][1] = 2; fac[0][2] = 500000003; fac[0][3] = 1000000006; LL a,b,c,d; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d) &#123; LL t = a * a + 4 * b; A.m[0][0] = a; A.m[0][1] = b; A.m[1][0] = 1; A.m[1][1] = 0; if(Legendre(t,MOD) == 1) &#123; for(int i=0; i&lt;4; i++) &#123; if(OK(A,fac[0][i])) &#123; cout&lt;&lt;fac[0][i]&lt;&lt;endl; break; &#125; &#125; &#125; else &#123; ct = 0; cnt = 6; dfs(0,1); sort(fac[1],fac[1]+ct); for(int i=0;i&lt;ct;i++) &#123; if(OK(A,fac[1][i])) &#123; cout&lt;&lt;fac[1][i]&lt;&lt;endl; break; &#125; &#125; &#125; &#125; return 0;&#125;"},{"title":"2015 ACM 长春赛区网赛题解 （部分）","permalink":"http://blog.jetmuffin.com/2015/09/14/2015-ACM-changchun-online-solution/","text":"1001 Alisha’s Party (优先队列）题目链接 HDOJ-5437题意Alisha开party, 到了的好友在门外等候，Alisha会开m次门，每次开门按给定的条件(t,p)-&gt;在第t个好友到达时候开门，并且放进p个人，若门外等候的人少于p个，则会全部放进来；最后会开一次门把所有人放进来；每次放进的p个人，按礼品价值高低顺序进入；得到一个好友进入的序列，最后求序列中的某几个序号对应的人名。 思路首先将所有的开门条件按时间排好序，然后用优先队列处理门外排队的人，循环模拟每个人到达的时间(i从1到k，第i时间时i-1号好友到达），将开门的计数器cnt置为0，然后当i等于某个开门条件时（即i == open[k].t)，将open[k].p个人出队并将他们的名字加入结果(vector)中。处理完所有的开门条件后，将队列中所有元素弹出，并加到结果中。 然后是这题的trick吧： 优先队列中，如果礼物价值相同，按时间顺序先进先出 m个开门条件(t,p)不一定是按顺序给的，要自行排序 所有m个开门条件结束以后，Alisha会开一次门把所有人放进去，也就是说当m=0(不开门)的时候，所有人按礼物价值降序进入 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define maxn 150005 struct node&#123; char name[205]; int w, t; friend bool operator &lt;(node a,node b) &#123; if(a.w == b.w) return a.t &gt; b.t; return a.w &lt; b.w; &#125; &#125;;node fri[maxn];struct node1&#123; int t,p;&#125;open[maxn];bool cmp(node1 a, node1 b)&#123; return a.t &lt; b.t; &#125; int main()&#123; int t, k, m, query; //freopen(\"in.txt\",\"r\",stdin); scanf(\"%d\", &amp;t); while(t--) &#123; scanf(\"%d%d%d\", &amp;k, &amp;m, &amp;query); for(int i = 0 ; i &lt; k; i++)&#123; scanf(\"%s %d\",fri[i].name,&amp;fri[i].w); fri[i].t = i; &#125; open[0].t = -1; for(int i = 0;i &lt; m;i++) scanf(\"%d%d\", &amp;open[i].t, &amp;open[i].p); priority_queue&lt;node&gt;q; vector&lt;int&gt; ans; sort(open, open + m, cmp); int cnt = 0; for(int i = 1 ; i &lt;= k; i++)&#123; q.push(fri[i-1]); if(i == open[cnt].t)&#123; //cout&lt;&lt;i&lt;&lt;endl; for(int j = 1; j &lt;= open[cnt].p &amp;&amp; (!q.empty()); j++)&#123; node tmp = q.top(); //cout&lt;&lt;tmp.name&lt;&lt;endl; q.pop(); ans.push_back(tmp.t); &#125; cnt++; &#125; &#125; while(!q.empty())&#123; node tmp = q.top(); q.pop(); ans.push_back(tmp.t); &#125; int len = ans.size(); for(int i = 0; i &lt; query; i++)&#123; int x; scanf(\"%d\",&amp;x); printf(\"%s\", fri[ans[x-1]].name); if(i == query-1) printf(\"\\n\"); else printf(\" \"); &#125; &#125;&#125; 1002 Ponds (DFS）题目链接 HDOJ-5438题意给定一个无向图，首先去掉度数小于2的顶点（是不断删去，删去一个顶点可能会再次出现需要删除的顶点，要删到直到不再出现为止)，然后对剩下的图计算其每个连通分量的顶点数，若顶点数为奇数，则将其权值加到最后的结果，输出到最后的结果。 trick:需要不断删去不符合节点直到不存在不符合节点为止，如下图情况：图1中所有顶点都会被去掉，图2中只剩下1,2,3 思路首先用队列处理删点操作，先将所有符合删除条件的点入队，然后从队列中每弹出一个顶点，将其所有相邻顶点度数-1，若再次出现符合删除条件，则将新点也入队，直到队列为空。（注意用访问标记减少重复访问）；然后用DFS去遍历整个图，每访问完一个连通子图计算权值和并判断节点数。 复杂度O(|V|) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define LL long longconst int maxn = 10010;vector &lt;int&gt; g[maxn];LL w[maxn];int vis[maxn];int deg[maxn];LL ans = 0;LL sum = 0;int cnt = 0;void dfs(int x)&#123; if(vis[x]) return; vis[x] = 1; int len = g[x].size(); // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;cnt&lt;&lt;endl; sum += w[x]; cnt++; for(int i = 0; i &lt; len; i++)&#123; int v = g[x][i]; if(!vis[v])&#123; dfs(v); &#125; &#125;&#125;void work(int n)&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123; if(deg[i] &lt; 2)&#123; vis[i] = 1; q.push(i); &#125; &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); int len = g[u].size(); for(int i = 0 ; i &lt; len; i++)&#123; int v = g[u][i]; if(!vis[v])&#123; deg[v] --; if(deg[v] &lt; 2)&#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; int n,m; memset(vis, 0 , sizeof(vis)); memset(deg,0, sizeof(deg)); memset(g,0, sizeof(g)); ans = 0; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%lld\",w+i); for(int i = 1; i &lt;= m; i++)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); g[u].push_back(v); g[v].push_back(u); deg[u]++; deg[v]++; &#125; work(n); // for(int i = 1; i &lt;= n; i++) // cout&lt;&lt;vis[i]&lt;&lt;\" \"; // cout&lt;&lt;endl; for(int i = 1; i &lt;= n; i++)&#123; if(!vis[i])&#123; cnt = 0; sum = 0; dfs(i); if(cnt%2 == 1) ans += sum; &#125; &#125; printf(\"%lld\\n\",ans); &#125;&#125; 1005 Travel(并查集） 题目链接 HDOJ-5441之前没有做过并查集处理图的题目，该题之后上题解 1006 Favorite Donut（后缀数组）题目链接 HDOJ-5442这题据说比较裸的后缀自动机，之后上题解 1007 The Water Problem (水题）题目链接 HDOJ-5443签到题，没什么好说的，区间最大值，不需要RMQ，线段树什么的，直接O(nq）就能过，很好的手速题，5min看完题8min交题ORZ~ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1005;int a[maxn];int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; int n; scanf(\"%d\",&amp;n); for(int i = 1 ; i &lt;= n; i++) scanf(\"%d\",a+i); int q; scanf(\"%d\",&amp;q); for(int i = 1 ; i &lt;= q; i++)&#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); int max = -1; for(int j = l; j&lt;=r; j++)&#123; if(a[j] &gt; max ) max = a[j]; &#125; printf(\"%d\\n\",max); &#125; &#125;&#125; 1008 Elven Postman (二叉排序树）题目链接 HDOJ-5444题意题目描述了一种房间的排序方式，又讲了给定的序列怎么来的，讲了一大堆，结果发现这树就是一颗倒着的二叉排序树（二叉搜索树），大的数放左节点，小的树放右节点。 思路给定一个序列可以构造出一颗BST，然后根据查询条件去查找就行了，向左递归输出W，向右递归输出E。 复杂度：查询O(log(q)) trick:按题意，给定的序列长度是1000，也就是说树的深度是1000，若用数组模拟，需要2^1000大小的数组，必然RE，因此要用指针做。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt; using namespace std; bool first; struct BST&#123; int data; BST *leftchild; BST *rightchild; &#125;; void Build(BST *&amp;root,int x)&#123; if(root==NULL)&#123; root=(BST *)malloc(sizeof(BST)); root-&gt;data=x; root-&gt;leftchild=root-&gt;rightchild=NULL; &#125;else &#123; if(x&lt;root-&gt;data)&#123; Build(root-&gt;leftchild,x); &#125;else Build(root-&gt;rightchild,x); &#125; &#125; void Search(int v,BST *root)&#123; if(root == NULL)&#123; return; &#125;else if(root-&gt;data &gt; v)&#123; printf(\"E\"); Search(v, root-&gt;leftchild); &#125;else if(root-&gt;data &lt;v)&#123; printf(\"W\"); Search(v, root-&gt;rightchild); &#125;else&#123; return; &#125; &#125; int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; BST *root=NULL; int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int x; scanf(\"%d\",&amp;x); Build(root,x); &#125; int q; scanf(\"%d\",&amp;q); for(int i = 0; i &lt; q; i++)&#123; int t; scanf(\"%d\",&amp;t); Search(t,root); printf(\"\\n\"); &#125; &#125;&#125; 1010 Unknown Treasure(Lucas定理+中国剩余定理+按位乘法)题目链接 HDOJ-5446题意组合数取模，求C(n,m)mod(p1p2…pk) 思路先使用Lucas定理求出对于每个pi，C(n, m) % pi的值。再使用中国剩余定理对模数和余数求解即可。 trick:在用中国剩余定理的过程中，会出现long long * long long 结果爆掉了的情况，这个是导致WA的问题。。所以要手写一个按位乘法 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;using namespace std;long long n,m,k;long long lcm;long long remainer[20];long long divider[20];long long extend_gcd(long long a,long long b,long long &amp;x,long long &amp;y)&#123; if (a==0 &amp;&amp; b==0) return -1; if (b==0) &#123; x=1; y=0; return a; &#125; long long ans=extend_gcd(b,a%b,x,y); long long temp=x; x=y; y=temp-a/b*y; return ans;&#125;long long mod_reverse(long long a,long long d_p)&#123; long long x,y; long long ans=extend_gcd(a,d_p,x,y); if (ans!=1) return -1; else return (x%d_p+d_p)%d_p;&#125;long long mul(long long a, long long b, long long mod) &#123; a = (a % mod + mod) % mod; b = (b % mod + mod) % mod; long long ret = 0; while(b)&#123; if(b&amp;1)&#123; ret += a; if(ret &gt;= mod) ret -= mod; &#125; b &gt;&gt;= 1; a &lt;&lt;= 1; if(a &gt;= mod) a -= mod; &#125; return ret; &#125; long long crt(long long lcm)&#123; long long ans=0; for (long long i=0;i&lt;k;i++) &#123; long long others; others=lcm/divider[i]; long long mr=mod_reverse(others,divider[i]); //ans = (ans+remainer[i]*others*mr)%lcm; ans = (ans + mul(mul(remainer[i],others,lcm),mr,lcm)); &#125; return (ans+lcm)%lcm;&#125;long long mod_pow(long long a,long long n_,long long p)&#123; long long ret=1; long long A=a; while(n_) &#123; if (n_ &amp; 1) ret=(ret*A)%p; A=(A*A)%p; n_&gt;&gt;=1; &#125; return ret;&#125;long long factorial[100010];void init(long long p)&#123; factorial[0] = 1; for(long long i = 1;i &lt;= p;i++) factorial[i] = factorial[i-1]*i%p;&#125;long long Lucas(long long a,long long k_,long long p)&#123; long long re = 1; while(a &amp;&amp; k_) &#123; long long aa = a%p; long long bb = k_%p; if(aa &lt; bb) return 0; re = re*factorial[aa]*mod_pow(factorial[bb]*factorial[aa-bb]%p,p-2,p)%p; a /= p; k_ /= p; &#125; return re;&#125;int main()&#123; int T; //freopen(\"in.txt\",\"r\",stdin); long long p; cin&gt;&gt;T; while(T--) &#123; lcm = 1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for (long long i=0;i&lt;k;i++) &#123; cin&gt;&gt;p; init(p); divider[i] = p; lcm = lcm*divider[i]; remainer[i] = Lucas(n,m,p); &#125; cout&lt;&lt;crt(lcm)&lt;&lt;endl; &#125; return 0;&#125;"},{"title":"HHU ACM第五周 数论专题（二）题解","permalink":"http://blog.jetmuffin.com/2015/09/08/HHU-ACM-training-week-five-number-theory-solutions/","text":"1000 Zball in Tina Town HDOJ-5391题意Z-ball在第n天会变为前一天的n倍，求最后的大小mod n，即求(n-1)!%n 思路根据威尔逊定理(自行百度）， $f(x)=\\begin{cases}n-1, &amp;x\\in prime\\cr 0, &amp;x\\not \\in prime \\end{cases}$ 此外有一个trick，即f(4)=2.没看过威尔逊定理也没事，暴力求前几项打个表就能发现规律了 代码123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;bool is_prime(int x) &#123; for(int i=2;i*i&lt;=x;i++) if(x%i==0)return false; return x!=1; &#125; int main() &#123; int t; scanf(\"%d\",&amp;t); while(t--) &#123; int n; scanf(\"%d\",&amp;n); if(n==4) printf(\"2\\n\"); else if(is_prime(n)) printf(\"%d\\n\",n-1); else printf(\"0\\n\"); &#125; return 0; &#125; 1001 C Looooops POJ-2115题意循环开始数为variable = A，循环结束条件为variable = B,每次variable + 2，最大数范围为2^k，求循环执行几次 思路根据题意列出同余方程: 12345678910111213141516171819202122232425262728293031323334353637383940414243`C * n \\equiv B (mod 2^&#123;k&#125;) 其中`C`,`B`,`2^k`均已知，符合拓展欧几里得算法（自行百度）的条件因此我们直接可以套用拓展欧几里得算法解同余方程。也有其他做法，不需要拓展欧几里得也能做出。### 代码```cpp#include &lt;iostream&gt;using namespace std;#define LL long longLL extgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(b == 0)&#123; x=1; y=0; return a; &#125; LL d = extgcd(b, a%b, y, x); y -= x*(a/b); return d;&#125;int main()&#123; LL A,B,C,K; while(~scanf(&quot;%lld%lld%lld%lld&quot;,&amp;A,&amp;B,&amp;C,&amp;K))&#123; if(A==0 &amp;&amp; B ==0 &amp;&amp; C ==0 &amp; K==0) break; LL x, y; LL m = (1LL &lt;&lt; K); LL gcd = extgcd(C, m, x, y); LL b = (B - A + m) % m; LL t = m / gcd; if(b % gcd == 0)&#123; LL ans = (b / gcd * x) % m; ans = (m + ans) % m; ans = (ans % t + t) % t; cout&lt;&lt;ans&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;FOREVER&quot;&lt;&lt;endl; &#125; &#125;&#125; 1002 Biorhythms POJ-1006题意给出三个日期，分别对应于体力，情感，智力出现峰值的日期。然后再给出一个起始日期，要求从这一天开始，算出最少再过多少天后三个峰值同时出现。 思路根据题意可以列出模线性方程 12\\begin&#123;cases&#125; x \\equiv p (mod \\28) \\cr x \\equiv e (mod \\33) \\cr x \\equiv i (mod \\35)\\end&#123;cases&#125; 然后根据中国剩余定理（自行百度），可以直接套用模板做出，下面给出通用的中国剩余定理模板，实际解这题中很多值已经可以直接算出来了,代码会更简单一些 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#define LL long longint m[3] = &#123;23, 28, 33&#125;;int a[3];int extgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b == 0)&#123; x=1; y=0; return a; &#125; int d = extgcd(b, a%b, y, x); y -= x*(a/b); return d;&#125;int crt(int n)&#123; int M = 1; for(int i = 0; i &lt; n; ++i) M *= m[i]; int ret = 0; for(int i = 0; i &lt; n; ++i)&#123; int x, y; int t = M/m[i]; extgcd(t, m[i], x, y); ret = (ret + t *x * a[i]) % M; &#125; return ret;&#125;int main()&#123; int p, e, i, d; int x,y; int cnt = 0; while(~scanf(\"%d%d%d%d\",&amp;p,&amp;e,&amp;i,&amp;d))&#123; cnt++; if(p==-1 &amp;&amp; e ==-1 &amp;&amp; i ==-1 &amp; d==-1) break; a[0] = p; a[1] = e; a[2] = i; int ans = crt(3); ans = (ans - d) % 21252; if(ans &lt;= 0) ans += 21252; printf(\"Case %d: the next triple peak occurs in %d days.\\n\",cnt,ans); &#125;&#125; 1003 Infoplane in Tina Town HDOJ-5392题意给定置换A的序列，每次对初始序列[1,2,3,…,n]做A置换，求最少做几次A置换能够变回到原序列 分析根据题意，要求的是A置换的循环长度，根据定理，循环长度即为置换中所有循环节长度的最小公倍数。因此只要求出各个循环节的长度，并求总的最小公倍数即可。然而因为需要取模，而常规欧几里得算法求gcd再求lcm求最小公倍数不可取模，因此需要用分解质因数方法去求最小公倍数。 将每个数分解成质因数p的幂次的乘积的形式，则每个质因数在lcm中出现的次数为在每个a[i]中出现次数的最大值，统计每个质因数p出现的次数，最后做一次乘积即可。 1lcm = p_&#123;1&#125;^&#123;b_&#123;1&#125;&#125;\\times p_&#123;2&#125;^&#123;b_&#123;2&#125;&#125;\\times p_&#123;3&#125;^&#123;b_&#123;3&#125;&#125;\\times ... p_&#123;k&#125;^&#123;b_&#123;k&#125;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int maxn = 3000010;const LL mod = 3221225473;int a[maxn];int b[maxn];int vis[maxn];int n;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%d\",&amp;n); memset(vis,0,sizeof(vis)); memset(b,0,sizeof(b)); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\",a+i); &#125; for(int i = 1 ; i &lt;= n; i++)&#123; if(vis[i]) continue; int k = i; int len = 0; while(!vis[k])&#123; vis[k] = 1; len++; k = a[k]; &#125; //求出len为循环节长度 for(int j = 2; j*j &lt;= len; j++)&#123; int cnt = 0; while(len % j == 0)&#123; cnt++; len /= j; &#125; b[j] = max(b[j], cnt); &#125; if(len &gt; 1) b[len] = max(b[len], 1); //求最小公倍数 &#125; LL ans = 1; for(int i = 2; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= b[i]; j++) ans = ans * i % mod; &#125; printf(\"%lld\\n\",ans); &#125;&#125; 1004 233 Matrix HDOJ-5015题意给定一个矩阵，矩阵的第一行为0，233,2333,23333.。。第一列为输入的序列，同时ai,j = ai-1,j +ai,j-1( i,j ≠ 0)，求a[n,m]。 分析这题是一个很好的矩阵递推公式求解的题目，求解过程如下： 首先我们将矩阵的第一列进行一次转换： 1234567891011121314151617\\begin&#123;pmatrix&#125; 0\\\\ a[1]\\\\ a[2]\\\\ a[3]\\\\ a[4] \\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 23\\\\ a[1]\\\\ a[2]\\\\ a[3]\\\\ a[4]\\\\ 3 \\end&#123;pmatrix&#125; 那么由第一列转换为第二列即可表示为： 1234567\\begin&#123;pmatrix&#125;23*10+3\\\\ a[1]+23*10+3\\\\ a[2]+a[1]+23*10+3\\\\ a[3]+a[2]+a[1]+23*10+3\\\\ a[4]+a[3]+a[2]+a[1]+23*10+3\\end&#123;pmatrix&#125; 这样我们就能发现，`f[2,2] = f[1,2]+f[2,1]; f[3,2] = f[2,2]+f[3,1]` .... 顺手一推即可得到转移矩阵A为： 12345678\\begin&#123;bmatrix&#125;10 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1\\\\10 &amp;1 &amp;0 &amp;0 &amp;0 &amp;1\\\\10 &amp;1 &amp;1 &amp;0 &amp;0 &amp;1\\\\10 &amp;1 &amp;1 &amp;1 &amp;0 &amp;1\\\\10 &amp;1 &amp;1 &amp;1 &amp;1 &amp;1\\\\ 0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1\\\\\\end&#123;bmatrix&#125; 然后呢可以得到f[2]（第二列）= A*f[1],f[n]=A*f[n-1], f[n] = A^m*f[0] 然后套用矩阵快速幂就可以了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int mod = 10000007;struct matrix&#123; long long m[15][15]; matrix() &#123; memset(m,0,sizeof(m)); &#125; &#125;;int n,m;matrix mul(matrix a, matrix b)&#123; matrix c; for(int i = 1 ; i &lt;= n+2; i++) for(int j = 1; j &lt;= n+2; j++) &#123; for(int k = 1; k &lt;= n+2; k++) &#123; c.m[i][j] = (c.m[i][j] + a.m[i][k]*b.m[k][j] ) %mod; &#125; &#125; return c;&#125; matrix pow(matrix a, int k)&#123; matrix b; for(int i = 1; i &lt;= n+2; i++) b.m[i][i] = 1; while(k &gt;= 1)&#123; // cout&lt;&lt;k&lt;&lt;endl; if(k&amp;1) b = mul(b,a); a = mul(a,a); k = k/2; &#125; return b;&#125;int main()&#123; while(~scanf(\"%d%d\",&amp;n,&amp;m))&#123; matrix ans,base; ans.m[1][1]=23; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;ans.m[i+1][1]); &#125; ans.m[n+2][1]=3; for(int i=1;i&lt;=n+1;i++)base.m[i][1]=10; for(int i=1;i&lt;=n+2;i++)base.m[i][n+2]=1; for(int i=2;i&lt;=n+1;i++) &#123; for(int j=2;j&lt;=i;j++)base.m[i][j]=1; &#125; base = pow(base,m); ans = mul(base,ans); cout&lt;&lt;ans.m[n+1][1]&lt;&lt;endl; &#125;&#125;"},{"title":"Floyd-Warshall算法 多源最短路径","permalink":"http://blog.jetmuffin.com/2015/09/05/floyd-warshall-multi-source-shortest-path/","text":"算法思路Floyd算法的原理即动态规划，令D(i,j)表示从i点到达j点的最短路径长度。那么从i点到达j点有两种可能： 直接从i到达j不经过中间点k i经过中间点k到达j，那么需要比较D(i,k)+D(k,j)和D(i,j)的大小并且更新最小值 我们遍历所有的点k,就可以得到从点i到j的最短路径了，而D数组不需要重新开辟，直接在邻接矩阵g上操作就行了 算法流程伪代码：1234k: 1 -&gt;; n i: 1 -&gt; n j: 1 -&gt; n g[i][j] = min(g[i][j],g[i][k]+g[k][j]) 应用hdu 254412345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define INF 100000000 const int maxn = 105;int g[maxn][maxn];int min(int a,int b)&#123; return a&lt;b?a:b;&#125;void floyd(int n )&#123; for(int k = 1; k &lt;= n; k ++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);&#125;int main()&#123; int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m),n+m)&#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(i == j) g[i][j] = 0; else g[i][j] = INF; for(int i = 1; i &lt;= m; i++)&#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); g[u][v] = g[v][u] = w; &#125; floyd(n); int ans = -1; printf(\"%d\\n\",g[1][n]); &#125;&#125; poj1502123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define INF 100000000 const int maxn = 105;int g[maxn][maxn];int min(int a,int b)&#123; return a&lt;b?a:b;&#125;void floyd(int n )&#123; for(int k = 1; k &lt;= n; k ++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);&#125;int main()&#123; int n; while(~scanf(\"%d\",&amp;n))&#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) g[i][j] = INF; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt; i; j++)&#123; int x; if(scanf(\"%d\",&amp;x)) g[i][j] = g[j][i] = x; else scanf(\"x\"); //input handle &#125; floyd(n); int ans = -1; for(int i = 1; i &lt;= n; i++)&#123; if(g[1][i] &gt; ans) ans = g[1][i]; &#125; printf(\"%d\\n\",ans); &#125;&#125;"},{"title":"Dijkstra算法 单源最短路径 堆优化","permalink":"http://blog.jetmuffin.com/2015/09/05/dijkstra-single-source-shortest-path-optimize-by-heap/","text":"概念Dijkstra是用来解决只含有非负边权的单源最短路径问题。给定一个起始点s，算法可以求出s到其他所有点的最短路径距离。算法结束后会生成一棵最短路径树。 算法 输入：图G（邻接矩阵或者邻接表） 输出：s到每一个点的最短路径 具体流程： 初始化距离数组为INF 设置所有点都未访问过 找到所有未访问过的点中最小的一个，标记为访问过 对3中找到的点的所有相邻点进行松弛操作 重复3和4直到所有点都被访问过 复杂度：朴素方法O(|V|^2+|E|)，最大堆维护距离O(|E|+|V|log|V|) 算法动图 优化朴素的dijkstra相对于spfa没有任何优势，复杂度达到了O(n^2)的级别，但是只要加入了堆优化，复杂度可以降到O(nlog(n)),则体现出它的优势了。最小堆查询最小值的复杂度为`O(logn) 最小堆模板12 struct HeapElement { // key存储顶点序号，value存储到该顶点的最短距离 int key, value;};struct MinHeap { HeapElement heap[MAXN]; int position[MAXN]; int size; // 顶点数 void init() { heap[size=0].value = -INF; memset(position, 0, sizeof(position)); } void insert(int key, int value) { heap[++size].key = key; heap[size].value = value; position[key] = size; siftUp(size); } void decrease(int index) { int x = heap[index].value; int y = heap[size].value; – size; if (index == size+1) return; swap(heap[index], heap[size+1]); if (y &gt;= x) { siftDown(index); } else { siftUp(index); } } int delmin() { int x = heap[1].key; decrease(1); return x; } void siftUp(int index) { while (index &gt; 1) { if (heap[index].value &lt; heap[index/2].value) { swap(heap[index],heap[index/2]); } else { break; } index /= 2; } } void siftDown(int index) { while (index*2 &lt;= size) { index *= 2; if (index &lt; size &amp;&amp; heap[index].value &gt; heap[index+1].value) { ++ index; } if (heap[index].value &lt; heap[index/2].value) { swap(heap[index],heap[index/2]); } else { break; } } } void makeHeap() { for (int i = size/2; i &gt; 0; -- i) siftDown(i); } void swap(HeapElement &amp;a, HeapElement &amp;b) { HeapElement temp = a; a = b; b = temp; int tmp = position[a.key]; position[a.key] = position[b.key]; position[b.key] = tmp; } }H; 应用hdu 254412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;#define INF 0x3f3f3f3f const int maxn = 1010;typedef struct edge&#123; int i,w;&#125;;vector&lt;edge&gt; g[maxn];int dis[maxn];int vis[maxn];int min(int a,int b)&#123; return a&lt;b?a:b; &#125; void dijkstra(int n)&#123; for(int i = 1; i &lt;= n ; i++) dis[i] = INF; dis[1] = 0; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++)&#123; int mark = -1; int mindis = INF; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j] &amp;&amp; dis[j] &lt; mindis)&#123; mindis = dis[j]; mark = j; &#125; &#125;//find vertex of minimal distance vis[mark] = 1; for(int j = 0; j &lt; g[mark].size(); j++)&#123; int v = g[mark][j].i; int w = g[mark][j].w; if(!vis[v])&#123; dis[v] = min(dis[v],dis[mark]+w); &#125; &#125;//relax the adjacent edges of minimal vertex &#125;&#125;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m),m+n)&#123; memset(g, 0, sizeof(g)); for(int i = 1; i &lt;= m; i++)&#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); edge e; e.i = v; e.w = w; g[u].push_back(e); e.i = u; g[v].push_back(e); &#125; dijkstra(n); printf(\"%d\\n\",dis[n]); &#125; &#125; hdu 2544 堆优化版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt; #define INF 0x7FFFFFFF using namespace std; const int SIZE = 105; int dist[SIZE]; int G[SIZE][SIZE]; bool vis[SIZE]; struct HeapElement &#123; int key, value; &#125;; void swap(HeapElement &amp;ha, HeapElement &amp;hb) &#123; int key = ha.key; int value = ha.value; ha.key = hb.key; ha.value = hb.value; hb.key = key; hb.value = value; &#125;; // 使用邻接表储存图，线性表储存堆 struct MinHeap &#123; HeapElement heap[SIZE]; int n; // 顶点数 void makeheap() &#123; for (int i = n/2; i &gt; 0; -- i) siftDown(i); &#125;; void siftUp(int index) &#123; int k = index; while (k &gt; 1) &#123; if (heap[k].value &lt; heap[k/2].value) &#123; swap(heap[k],heap[k/2]); &#125; else &#123; break; &#125; k /= 2; &#125; &#125;; void siftDown(int index) &#123; int k = index; while (k*2 &lt;= n) &#123; k *= 2; if (k &lt; n &amp;&amp; heap[k].value &gt; heap[k+1].value) &#123; ++ k; &#125; if (heap[k].value &lt; heap[k/2].value) &#123; swap(heap[k],heap[k/2]); &#125; else &#123; break; &#125; &#125; &#125;; void insert(HeapElement element) &#123; heap[++n] = element; siftUp(n); &#125;; void decrease(int index) &#123; int x = heap[index].value; int y = heap[n].value; n -= 1; // 若删除节点位于最末位置，则删除成功，无需其他操作。 if (index == n+1) return; heap[index] = heap[n+1]; if (y &gt;= x) &#123; siftDown(index); &#125; else &#123; siftUp(index); &#125; &#125;; int decreaseMin() &#123; int x = heap[1].key; decrease(1); return x; &#125;; &#125;H; void dijkstra(int src, int n) &#123; int i, j, w; bool flag; for (i = 1; i &lt;= n; ++ i) &#123; if (G[i][src] != INF) &#123; dist[i] = G[src][i]; HeapElement h = &#123;i, dist[i]&#125;; H.insert(h); &#125; else &#123; dist[i] = INF; &#125; &#125; memset(vis, false, sizeof(vis)); vis[src] = true; dist[src] = 0; for (i = 1; i &lt; n; ++ i) &#123; int node = H.decreaseMin(); //get the vertex of minimal distance vis[node] = true; for (w = 1; w &lt;= n; ++ w) &#123; flag = false; if (!vis[w] &amp;&amp; G[node][w] != INF) &#123; if (dist[node] &lt; dist[w] - G[node][w]) &#123; dist[w] = dist[node] + G[node][w]; //relax all adjacent of this vertex &#125; for (j = 1; j &lt;= H.n; ++ j) &#123; //update minimal heap if (H.heap[j].key == w) &#123; H.heap[j].value = dist[w]; flag = true; break; &#125; &#125; if (!flag) &#123; HeapElement h = &#123;w, dist[w]&#125;; H.insert(h); &#125; else &#123; H.siftUp(j); &#125; &#125; &#125; &#125; &#125;; void init(int n) &#123; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) G[i][j] = INF; H.n = 0; &#125;; int main() &#123; int N, M, a, b, c; while (scanf(\"%d%d\",&amp;N,&amp;M)!=EOF, N&amp;&amp;M) &#123; init(N); for (int i = 0; i &lt; M; ++ i) &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if (G[a][b] &gt; c) &#123; G[a][b] = c; G[b][a] = c; &#125; &#125; dijkstra(1, N); printf(\"%d\\n\",dist[N]); &#125; &#125; poj 15021234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;#define INF 0x3f3f3f3f const int maxn = 1010;int dis[maxn],g[maxn][maxn];int vis[maxn];int min(int a,int b)&#123; return a&lt;b?a:b;&#125;void dijkstra(int n)&#123; for(int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; memset(vis, 0 , sizeof(vis)); for(int i = 1; i &lt;= n; i++)&#123; int mark = -1; int mindis = INF; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j] &amp;&amp; dis[j] &lt; mindis)&#123; mindis = dis[j]; mark = j; &#125; &#125; vis[mark] = 1; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j])&#123; dis[j] = min(dis[j], g[mark][j] + dis[mark]); &#125; &#125; &#125;&#125;int main()&#123; int n; while(~scanf(\"%d\",&amp;n))&#123; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) g[i][j] = INF; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt; i; j++)&#123; int x; if(scanf(\"%d\",&amp;x)) g[i][j] = g[j][i] = x; else scanf(\"x\"); //input handle &#125; dijkstra(n); int ans = -1; for(int i = 1; i &lt;= n; i++)&#123; if(dis[i] &gt; ans) ans = dis[i]; &#125; printf(\"%d\\n\",ans); &#125;&#125;"},{"title":"SPFA 单源最短路径 队列优化版Bellman-ford","permalink":"http://blog.jetmuffin.com/2015/09/04/spfa-single-source-shortest-path-optimize-by-queue/","text":"思路SPFA是队列优化版的Bellman-ford，核心思想和Bellman-ford相同，不停松弛节点。但是在Bellman-ford中需要对所有边的相应点都进行松弛，进行了过多的不必要操作。而SPFA则是将松弛过的点加入队列维护，使得被松弛的点尽量少。这样使得最坏情况下SPFA复杂度等于Bellman-ford，一般情况下远大于Bellman-ford 实现 复杂度：最坏情况O(|V|+|E|) 输入：n 图的顶点数（|V|）src 源点g 邻接表 输出：dis dis[i]表示src到点i的最短距离 应用hdu2544123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;#define INF 0x7FFFFFFF const int maxn = 150;vector &lt;pair&lt;int, int&gt; &gt; g[maxn];int dis[maxn];int vis[maxn];void spfa(int n)&#123; for(int i = 1 ; i &lt;= n; i++)&#123; dis[i] = INF; &#125; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; dis[1] = 0; vis[1] = 1; q.push(1); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = 0; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i].first; int w = g[u][i].second; if(dis[u] + w &lt; dis[v])&#123; dis[v] = dis[u] + w; if(vis[v] == 0)&#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m),m+n)&#123; for(int i = 0; i &lt; n; i++) g[i].clear(); for(int i = 1; i &lt;= m; i++)&#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); g[u].push_back(make_pair(v,w)); g[v].push_back(make_pair(u,w)); &#125; spfa(n); printf(\"%d\\n\",dis[n]); &#125;&#125;"},{"title":"Bellman-ford算法 图论 单源最短路径 求负权环","permalink":"http://blog.jetmuffin.com/2015/09/04/bellman-ford-compute-negative-weight-circle/","text":"概念Bellman-ford算法可以用来计算图中的单源最短路径。同时该算法可以处理边权为负的情况（Dijkstra算法无法处理负权），同时可以判断图中是否含有负权环。 设dis[v]为从源点s到v的最短路径长度。对于任意与v相连的顶点u，dis[v]可以满足三角不等式，即dis[v]&lt;=dis[u]+w(u,v)，根据该性质可以设置松弛操作。松弛一条边（u,v)： 判断通过u对v的最短路径是否能够进行改进 若可以，更新d[v] 伪代码：123松弛（u,v,w): if(d[v]&gt;d[u]+w(u,v)) d[v]=d[u]+w(u,v) 性质 如果完成|V|-1轮操作后还能进行松弛操作（即仍然存在d[v]&gt;d[u]+w(u,v)），那么图中有负权环 若不存在负权环，经过|V|-1操作，min_dis[v] = dis[v] 算法 输入：图G（edge数组）和起点s 输出：s到每个点的最短路径，以及图G是否包含负权环 算法流程： 初始化dis数组, dis[s] = 0, dis[i](1&lt;=i&lt;=n, i!=s) = INF 枚举每一条边，进行松弛操作 重复2操作|V|-1次 枚举每一条边，看是否还能进行松弛操作 算法复杂度： O(|V||E|) 应用hdu 2544求单源最短路径，直接使用即可，代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define INF 0x3f3f3f3f typedef struct Edge&#123; int u,v; int w;&#125;Edge;Edge edge[10010];int dis[110];bool Bellman_Ford(int n, int m)&#123; for(int i = 1; i &lt;= n; i++)&#123; dis[i] = INF; &#125; dis[1] = 0; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++)&#123; if( dis[edge[j].u] &gt; dis[edge[j].v] + edge[j].w) dis[edge[j].u] = dis[edge[j].v] + edge[j].w; if( dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].w) dis[edge[j].v] = dis[edge[j].u] + edge[j].w; &#125;&#125;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m),m+n)&#123; for(int i = 1; i &lt;= m; i++) scanf(\"%d%d%d\",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); Bellman_Ford(n,m); printf(\"%d\\n\",dis[n]); &#125;&#125; 判断负权环只要在|V|-1次循环结束以后再枚举边即可 1234567891011121314151617181920bool Bellman_Ford(int n, int m)&#123; for(int i = 1; i &lt;= n; i++)&#123; dis[i] = INF; &#125; dis[1] = 0; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++)&#123; if( dis[edge[j].u] &gt; dis[edge[j].v] + edge[j].w) dis[edge[j].u] = dis[edge[j].v] + edge[j].w; if( dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].w) dis[edge[j].v] = dis[edge[j].u] + edge[j].w; &#125; for(int j = 1; j &lt;= m; j++)&#123; if( dis[edge[j].u] &gt; dis[edge[j].v] + edge[j].w || dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].w) return 1; return 0;&#125;"},{"title":"hdu 5392 Infoplane in Tina Town","permalink":"http://blog.jetmuffin.com/2015/09/04/hdu-5392-Infoplane-in-Tina-Town/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5392 题意给定一个置换a，求序列1-n经过多少次a置换能够再次变回序列1-n 分析题意很明显，是求置换群的循环长度。 根据数论中的内容，循环长度等于所有循环节长度的最小公倍数，因此只要计算所有循环节的长度即可。 但是题目中提到需要对最后的答案进行求模处理，然而欧几里得算法求最小公倍数无法去模，因此要用质因数分解法进行求最小公倍数复杂度：O(nlog(n)) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int maxn = 3000010;const LL mod = 3221225473;int a[maxn];int b[maxn];int vis[maxn];int n;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%d\",&amp;n); memset(vis,0,sizeof(vis)); memset(b,0,sizeof(b)); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\",a+i); &#125; for(int i = 1 ; i &lt;= n; i++)&#123; if(vis[i]) continue; int k = i; int len = 0; while(!vis[k])&#123; vis[k] = 1; len++; k = a[k]; &#125; for(int j = 2; j*j &lt;= len; j++)&#123; int cnt = 0; while(len % j == 0)&#123; cnt++; len /= j; &#125; b[j] = max(b[j], cnt); &#125; if(len &gt; 1) b[len] = max(b[len], 1); &#125; LL ans = 1; for(int i = 2; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= b[i]; j++) ans = ans * i % mod; &#125; printf(\"%lld\\n\",ans); &#125;&#125;"},{"title":"求多个数的最小公倍数lcm","permalink":"http://blog.jetmuffin.com/2015/09/04/multi-number-lcm/","text":"欧几里得法由公式lcm(a,b) = a*b/gcd(a,b)可以得到两个数的lcm，同时多个数的最小公倍数可以先求前两个数的最小公倍数，再和第三个数求最小公倍数，以此类推。 复杂度O(nlog(n)) 代码12345678910111213int gcd(int a, int b)&#123; return b == 0? a : gcd(b, a%b); &#125;int lcm(int x, int y)&#123; return x*y/gcd(x,y);&#125; int lcm2(int n)&#123; int ret = 1; for(int i = 0; i &lt; n; i++)&#123; ret = lcm(ret, a[i]); &#125; return ret;&#125; 分解质因数法将每个数分解成质因数p的幂次的乘积的形式，则每个质因数在lcm中出现的次数为在每个a[i]中出现次数的最大值，统计每个质因数p出现的次数，最后做一次乘积即可。 1lcm = p_&#123;1&#125;^&#123;b_&#123;1&#125;&#125;\\times p_&#123;2&#125;^&#123;b_&#123;2&#125;&#125;\\times p_&#123;3&#125;^&#123;b_&#123;3&#125;&#125;\\times ... p_&#123;k&#125;^&#123;b_&#123;k&#125;&#125; 复杂度O(nlog(n)) 代码123456789101112131415161718192021int lcm1(int n)&#123; for(int i = 0 ; i &lt; n; i++)&#123; for(int j = 2; j * j &lt;= a[i]; j++)&#123; int cnt = 0; while(a[i] % j == 0)&#123; cnt ++; a[i] /= j; &#125; b[j] = max(b[j], cnt); &#125; if(a[i] &gt; 1)&#123; b[a[i]] = max(b[a[i]], 1); &#125; &#125; int ret = 1; for(int i = 2; i &lt; 10000; i++)&#123; for(int j = 1; j &lt;= b[i]; j++) ret = ret * i % mod; &#125; return ret;&#125;"},{"title":"大数乘法逆元求法总结","permalink":"http://blog.jetmuffin.com/2015/09/01/multiplicative-inverse-of-large-number/","text":"大数的乘法逆元 暴力法 12int i; for (i=1;;i++) &#123; if (((long long int)(n)*i-an)%M==0) break; &#125; 欧拉函数 1234long long inv( long long n ) &#123; return pow( n, M - 2 )%M; &#125; 拓展欧几里得算法 1234567891011121314151617181920//扩展欧几里德 void exp_gcd( LL a ,LL b,LL &amp;x,LL &amp;y) &#123; if( b == 0 ) &#123; x = 1; y = 0; &#125; else &#123; exp_gcd( b,a%b,x,y ); LL t; t = x; x = y; y = t - a/b*y; &#125; &#125; //逆元 inline LL getNN(LL x) &#123; LL now , t; exp_gcd( x, M,now,t ); return (now%M+M)%M; &#125; 拓展欧几里得（简洁版） int64 inv(int64 x) { //简洁版求逆元 if(x == 1) return 1; return inv(MOD%x) * (MOD - MOD/x) % MOD; }"},{"title":"hdu 5328 Problem Killer 2015多校联训第四场 等差数列等比数列","permalink":"http://blog.jetmuffin.com/2015/08/01/hdu-5328-Problem-Killer-2015-summer-multi-school-trainning/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5328 题意给定一个序列，求其中等差数列或者等比数列的最大长度 分析思路很明确，对于从第二个起的输入数字，计算与前一个数的差和比，然后向后比较计数。值得一提的是，这题的数据非常严格，有很多的坑。下面列举以下： 坑一：输入输出一定要scanf+printf，不然铁定超时 坑二：等比数列比值要用浮点数，浮点数相等比较要用精度，即fabs(a-b)&lt;eps 坑三：用double不知为何TLE了好多发 坑四：精度太低会WA，1e-6才能过 坑五：精度过高同样会TLE 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const float eps = 0.000001;using namespace std;int main()&#123; int t;// cin&gt;&gt;t; scanf(\"%d\",&amp;t); double ap,gp; int nap,ngp; int max_nap,max_ngp; double fi,se,ne; int n; while(t--)&#123; scanf(\"%d\",&amp;n); n--; scanf(\"%lf\",&amp;fi); nap = 1; ap = -1; max_nap = 0; ngp = 1; gp = -1; max_ngp = 0; bool iaSecond = true,ibSecond = true; while(n--)&#123; scanf(\"%lf\",&amp;ne); //ap if(iaSecond)&#123; iaSecond = false; ap = ne - fi; nap = 2; &#125;else&#123; if(fabs(ap - (ne - se)) &lt; eps)&#123; nap++; &#125;else&#123; ap = ne-se; max_nap = max_nap&gt;nap?max_nap:nap; nap = 2; &#125; &#125; //gp if(ibSecond)&#123; ibSecond = false; gp = ne / fi; ngp = 2; // cout &lt;&lt; ne/fi &lt;&lt;endl; &#125;else&#123; // cout &lt;&lt; ne/se &lt;&lt;endl; // cout&lt;&lt;fabs(gp - (ne / se))&lt;&lt;endl; if(fabs(gp - (ne / se)) &lt; eps)&#123; ngp++; &#125;else&#123; gp = ne/se; max_ngp = max_ngp&gt;ngp?max_ngp:ngp; ngp = 2; &#125; &#125; se = ne; &#125; max_nap = max_nap&gt;nap?max_nap:nap; max_ngp = max_ngp&gt;ngp?max_ngp:ngp; if(max_nap &gt; max_ngp) printf(\"%d\\n\", max_nap); else printf(\"%d\\n\", max_ngp); &#125;&#125;"},{"title":"hdu 5327 Olympiad 2015多校联训第四场 水题","permalink":"http://blog.jetmuffin.com/2015/08/01/hdu-5327-Olympiad-2015-summer-multi-school-trainning/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5327 题意求[a,b]范围内，各位都不重复的数字的个数 分析求各位不重复，逐位分解打标记即可；然后对于个数，可以直接打表f[i]表示1-i中符合条件的数的个数，然后对于每次查询，输出f[b]-f[a-1]即可 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100005;int f[maxn];int a[10];int check(int n)&#123; memset(a,0,sizeof(a)); while(n)&#123; int t = n%10; n /= 10; a[t] ++; if(a[t] &gt;= 2)&#123; return 0; &#125; &#125; return 1;&#125;int main()&#123; f[0] = 0; for(int i = 1; i &lt;= maxn; i++) if(check(i)) f[i] = f[i-1] + 1; else f[i] = f[i-1]; int t; cin&gt;&gt;t; while(t--)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;f[b]-f[a-1]&lt;&lt;endl; &#125;&#125;"},{"title":"hdu 5317 RGCDQ 2015多校联训第三场 树状数组","permalink":"http://blog.jetmuffin.com/2015/08/01/hdu-5317-RGCDQ-2015-multi-school-training/","text":"代码#include &lt;stdio.h&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;string&gt; #include &lt;math.h&gt; using namespace std; const int MAXN = 1000010; int c[MAXN]; int n; bool test[MAXN]; int tot,factor_num; int prim[500000]; int lowbit(int x) { return x&amp;(-x); } void add(int i,int val) { while(i &lt;= n) { c[i] = max(c[i],val); i += lowbit(i); } } int Max(int i) { int s = 0; while(i &gt; 0) { s = max(s,c[i]); i -= lowbit(i); } return s; } int a[MAXN]; int b[MAXN]; int ans[MAXN]; struct Node { int l,r; int index; }node[MAXN]; bool cmp(Node a,Node b) { return a.l &gt; b.l; } void getPrim() { memset(test,true,sizeof(test)); memset(prim,0,sizeof(prim)); tot = 0; for (int i=2;i&lt;=n;i++) { if (test[i]) { prim[tot] = i; tot++; } for (int j=0;(j&lt;tot &amp;&amp; i*prim[j]&lt;=n);j++) { test[i*prim[j]] = false; if (i%prim[j]==0) break; } } } void resolve(int now) { factor_num = 0; for (int i=0;i&lt;tot;i++) { if (test[now]) { factor_num++; return; } if (now%prim[i]==0) { factor_num++; } while (now%prim[i]==0) { now=now/prim[i]; } if (prim[i]&gt;now) break; } } int main() { int T; n = 0; scanf(\"%d\",&amp;T); for(int i=0;i&lt;T;i++) { scanf(\"%d%d\",&amp;node[i].l,&amp;node[i].r); node[i].index = i; if (node[i].r&gt;n) n = node[i].r; } getPrim(); for (int i=2;i&lt;=n;i++) { resolve(i); a[i] = factor_num; } sort(node,node+T,cmp); int i = n; int j = 0; memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); while(j &lt; T) { while(i &gt; 1 &amp;&amp; i&gt;= node[j].l) { for (int k=1;k*k&lt;=a[i];k++) { if(a[i]%k==0) { if(b[k]!=0) { add(b[k],k); } b[k] = i; if(k!=a[i]/k) { if(b[a[i]/k]!=0) { add(b[a[i]/k],a[i]/k); } b[a[i]/k]=i; } } } i--; } while(j&lt;T &amp;&amp; node[j].l&gt;i) { ans[node[j].index]=Max(node[j].r); j++; } } for (int i=0;i&lt;T;i++) printf(\"%d\\n\",ans[i]); return 0; }"},{"title":"hdu 5319 Painter 2015多校联训第三场 暴力","permalink":"http://blog.jetmuffin.com/2015/08/01/hdu-5319-Painter-2015-summer-multi-school-training/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5319 题意每次R操作只能从\\斜线方向画，B操作只能从/斜线方向画，给定最后状态，问最少得画几次才能达到。 分析思路比较明确，只要进行逆运算，消除R，B，G就行了，消除的方法就从左下角往右上角依次进行R的消除（&#39;R&#39;-&gt;&#39;.&#39;,&#39;G&#39;-&gt;&#39;B&#39;)，再从左上角到右下角依次进行B的消除(&#39;B&#39;-&gt;&#39;.&#39;,&#39;G&#39;-&gt;&#39;R&#39;)，然后每次斜线消除若碰到相反的字母或’.’，就增加一次计数就行了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;char map[55][55];int main()&#123; int T; cin&gt;&gt;T; int n,m; while(T--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; scanf(\"%s\",map[i]); &#125; m = strlen(map[0]); int cnt = 0; for(int l=0;l&lt;m;l++)&#123; int i=0,j=l; while(i&lt;n &amp;&amp; j&lt;m)&#123; if(map[i][j] != 'R' &amp;&amp; map[i][j] != 'G')&#123; i++; j++; &#125;else&#123; break; &#125; &#125; int isR = 0; while(i&lt;n &amp;&amp; j&lt;m)&#123; if(map[i][j] == 'R' || map[i][j] == 'G')&#123; isR = 1; if(map[i][j] == 'G') map[i][j] = 'B'; i++; j++; &#125;else&#123; if(isR)&#123; cnt++; &#125; isR = 0; i++; j++; continue; &#125; &#125; if(isR)&#123; cnt++; &#125; &#125; for(int l=1;l&lt;n;l++)&#123; int i=l,j=0; while(i&lt;n &amp;&amp; j&lt;m)&#123; if(map[i][j] != 'R' &amp;&amp; map[i][j] != 'G')&#123; i++; j++; &#125;else&#123; break; &#125; &#125; int isR = 0; while(i&lt;n &amp;&amp; j&lt;m)&#123; if(map[i][j] == 'R' || map[i][j] == 'G')&#123; isR = 1; if(map[i][j] == 'G') map[i][j] = 'B'; i++; j++; &#125;else&#123; if(isR)&#123; cnt++; &#125; isR = 0; i++; j++; continue; &#125; &#125; if(isR)&#123; cnt++; &#125; &#125; for(int l=0;l&lt;m;l++)&#123; int i=n-1,j=l; while(i&gt;=0 &amp;&amp; j&lt;m)&#123; if(map[i][j] != 'B')&#123; i--; j++; &#125;else&#123; break; &#125; &#125; int isR = 0; while(i&gt;=0 &amp;&amp; j&lt;m)&#123; if(map[i][j] == 'B')&#123; isR = 1; i--; j++; &#125;else&#123; if(isR)&#123; cnt++; &#125; isR = 0; i--; j++; continue; &#125; &#125; if(isR)&#123; cnt++; &#125; &#125; for(int l=n-2;l&gt;=0;l--)&#123; int i=l,j=0; while(i&gt;=0 &amp;&amp; j&lt;m)&#123; if(map[i][j] != 'B')&#123; i--; j++; &#125;else&#123; break; &#125; &#125; int isR = 0; while(i&gt;=0 &amp;&amp; j&lt;m)&#123; if(map[i][j] == 'B')&#123; isR = 1; i--; j++; &#125;else&#123; if(isR)&#123; cnt++; &#125; isR = 0; i--; j++; continue; &#125; &#125; if(isR)&#123; cnt++; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125;&#125;"},{"title":"hdu 5326 Work 2015多校联训第三场 并查集","permalink":"http://blog.jetmuffin.com/2015/08/01/hdu-5326-Work-2015-summer-multi-school-training/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5326 题意题意非常像裸并查集，每个员工都有一个直系上司，给定员工的管理状态，求管理k个下级员工的员工有多数个 分析本题比并查集简单，不需要用到查询部分，只要进行合并，添加一个子节点时将节点合并至父节点，更新权值即可，因为数据量小，所以直接遍历一遍求a[i] = k的个数就行了 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;#define MAXN 400int pre[MAXN];int a[MAXN];void merge(int i,int j)&#123; pre[j] = i; a[i]++; while(pre[i] != -1)&#123; a[pre[i]]++; i = pre[i]; &#125;&#125;int main()&#123; int n,k; while(scanf(\"%d%d\",&amp;n,&amp;k) != EOF)&#123; memset(pre,-1,sizeof(pre)); memset(a,0,sizeof(a)); int x,y; for(int i=0; i&lt;n-1; i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); merge(x,y); &#125; int cnt = 0; for(int i=1; i&lt;=n; i++)&#123; if(a[i] == k) cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125;"},{"title":"hdu 1054 Strategic Game 贪心","permalink":"http://blog.jetmuffin.com/2015/07/27/hdu-1054-Strategic-Game-greedy/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1054 题意给定一个二分图（给图的方式太蛋疼，输入输出好麻烦），在任意节点放置哨兵使得可以覆盖整个图。图的节点数n &lt;= 1500 分析这题看似一道很裸的二分图最小点覆盖（或者最大匹配），然而我并不会这些内容，所以一直在想其他策略。 一开始有一种贪心思路是，将点以度数进行排序，因为取度数较大的点上放一个哨兵的收益最大，因此需要动态维护一个堆，使得这个堆堆顶始终是度数最大的点，然后从堆顶取点，并将点对应的相邻点度数一次减1，然后将度数为0的点直接踢出堆外以减小复杂度。而这个堆可以是二叉堆，修改、删除、插入、取堆顶元素的操作复杂度均为O(logn)，然而我这块儿也学得不好，直接敲模板又比较麻烦。 所以从思路二继续尝试其他思路，发现从相反反向考虑，度数较大的点放哨兵收益最大，而度数最小的点（二分图无孤立点）即度数为1的点放哨兵度数收益最小，因此从反方向考虑这个问题的话，就是尽量不要再度数为1的点上放哨兵，而是用它的邻点取代它。因此我们维护一个队列，放置所有度数为1的点，每次取出队首u，并取出第一个邻点v，将邻点v的所有邻点度数更新，若出现度数为1的点则再加入队列。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; const int maxn = 1600; int deg[maxn]; int vis[maxn]; vector&lt;int&gt; edge[maxn]; int main(){ int n; // freopen(\"in.txt\",\"r\",stdin); while(~scanf(\"%d\",&amp;n)){ memset(deg,0,sizeof(deg)); memset(vis,0,sizeof(vis)); memset(edge,0,sizeof(edge)); for(int i = 0 ; i &lt; n ; i++){ int m,u; scanf(\"%d:(%d)\",&amp;u,&amp;m); if(m &gt; 0){ for(int j = 0 ; j &lt; m; j++){ int v; scanf(\"%d\",&amp;v); edge[u].push_back(v); edge[v].push_back(u); deg[u]++; deg[v]++; } } } // for(int i = 0 ; i &lt; n; i++){ // cout&lt;&lt;deg[i]&lt;&lt;\" \"; // } // cout&lt;&lt;endl; if(n == 1){ puts(\"1\"); continue; } queue &lt;int&gt; q; for(int i = 0 ; i &lt; n; i++){ if(deg[i] == 1) q.push(i); } int ans = 0; while(!q.empty()){ int u = q.front(); q.pop(); if(vis[u]) continue; for(int i = 0; i &lt; edge[u].size(); i++){ int v = edge[u][i]; if(!vis[v]){ vis[v] = 1; ans++; //选1个放烧饼 for(int j = 0; j &lt; edge[v].size(); j++){ int w = edge[v][j]; deg[w] --; if(deg[w] == 1 &amp;&amp; !vis[w]){ q.push(w); } } break; } } } cout&lt;&lt;ans&lt;&lt;endl; } }"},{"title":"数据结构总结 - 线段树专题","permalink":"http://blog.jetmuffin.com/2015/07/26/segment-tree/","text":"概念线段数是一种特殊的数据结构，它是一颗完全二叉树，它的每个节点保存一条线段，主要用来做高效的动态查询。线段树的区间查询复杂度为o(logn),更新复杂度也为o(logn) 操作 构造 void build(int l,int r, int rt) 构造线段树的过程是一个递归的过程，不停二分给定的区间[l,r]，若l=r时，则直接赋值。rt表示当前要构建的节点，而l和r为递归区间，每次以m=(l+r)/2为二分点，构建左子树和右子树，然后将左子树和右子树的信息向上更新(pushup)。这里及以下代码以求区间和的线段树为例。 void build(int l,int r, int rt){ add[rt] = 0; if(l == r){ return; } int m = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt); }` 查询query(int L,int R,int l, int r, int rt)线段树查询也运用了分治的思想，不断二分起始区间，直到和查询出现交集，再回溯并合并到结果中，若有延迟更新标记，则进行更新再进行回溯。查询区间[L,R]和二分区间[l,r]满足关系有以下几种（m为二分区间中点）： L &lt;= l &lt;= r &lt;= R，即二分区间在查询区间以内，则直接回溯[l,r]合并到查询结果中 L &lt;= m,则继续二分左儿子，直至m &lt; L，并把属于区间内的结果回溯到最后的结果 m &lt;= R，则继续二分右儿子，直至m &gt; R，并把结果回溯刀最后结果`LL query(int L,int R,int l, int r, int rt){ if(L 1; LL ret = 0; if(L 1; if(p"},{"title":"hdu 5311 Hidden String BestCoder 1st Anniversary B 暴搜","permalink":"http://blog.jetmuffin.com/2015/07/26/hdu-5311-Hidden-String-BestCoder-1st-Anniversary-B-search/","text":"题目题目地址：http://acm.hdu.edu.cn/showproblem.php?pid=5311 题意指定串为”anniversary”，在输入串中找到不相交的三段，拼起来数指定串，len(s)范围为100 分析这题卡了挺久主要是题意理解问题，一直以为这三段不需要顺序拼接，例如sary1ver1anni这种应该页输出YES，然而并不是。事实上是简单的顺序拼接，这样的话可以进行最最暴力的for循环搜索了，搜索过程可以用KMP加速以下，而KMP的起始位置是动态变化的就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;void getNext(const std::string &amp;p, std::vector&lt;int&gt; &amp;next)&#123; next.resize(p.size()); next[0] = -1; int i = 0, j = -1; while (i != p.size() - 1) &#123; //这里注意，i==0的时候实际上求的是next[1]的值，以此类推 if (j == -1 || p[i] == p[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125;&#125;int kmp(const std::string&amp; s, const std::string&amp; p, const int sIndex = 0)&#123; std::vector&lt;int&gt;next(p.size()); getNext(p, next);//获取next数组，保存到vector中 int i = sIndex, j = 0; while(i != s.length() &amp;&amp; j != p.length()) &#123; if (j == -1 || s[i] == p[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; return j == p.length() ? i - j: -1;&#125;string s;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; cin &gt;&gt; s; string s0 = \"anniversary\"; int len0 = s0.size(); string s1, s2, s3; bool flag = false; for (int i = 1; i &lt; len0; ++i) &#123; for (int j = i + 1; j &lt; len0; ++j) &#123; s1.clear(); s2.clear(); s3.clear(); for (int t = 0; t &lt; i; ++t) &#123; s1 += s0[t]; &#125; for (int t = i; t &lt; j; ++t) &#123; s2 += s0[t]; &#125; for (int t = j; t &lt; len0; ++t) &#123; s3 += s0[t]; &#125; // cout &lt;&lt; s1 &lt;&lt; \" \" &lt;&lt; s2 &lt;&lt; \" \" &lt;&lt; s3 &lt;&lt; endl; int idx = kmp(s, s1); if (idx == -1) &#123; continue; &#125; //printf(\"%d %d 111\\n\", i, j); idx = kmp(s, s2, idx + s1.size()); if (idx == -1) &#123; continue; &#125; //printf(\"222\\n\"); idx = kmp(s, s3, idx + s2.size()); if (idx == -1) &#123; continue; &#125; flag= true; &#125; &#125; if (flag) &#123; printf(\"YES\\n\"); &#125; else &#123; printf(\"NO\\n\"); &#125; &#125; return 0;&#125;"},{"title":"hdu 5305 Friends 2015多校联训第二场 搜索","permalink":"http://blog.jetmuffin.com/2015/07/26/hdu-5305-Friends-2015-summer-multi-school-trainning-search/","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5305 题意对题意的理解可以抽象成，当前已知一个图，图最多的点数为8,然后将图中的部分边进行染色，然后使得每个点对应的边有一半是黑边，一半是白边。 分析一开始接触题的想法是，既然数据范围小，可以直接进行搜索，然而一开始的策略是对点进行搜索，每个点枚举一半的边，进行染色，然后再搜下一个点进行染色，方法非常复杂，后来就没用继续下去了。 然而及时看了下staus发现大家过得时间非常短，一般都是15ms或30ms就通过了，然后一度以为是结论题，只要统计边和点的信息就可以解出题了，结果不是。 看了题解后发现做法应该是按边取搜索。可以先进行一次粗略的剪枝，统计每个点的度数，若出现奇数直接输出0； 然后将每个点的白边数和黑边数分别置为度数的一半，然后枚举保存的边，分别按染白和染黑进行搜索，知道搜索出结果。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;ctime&gt; using namespace std; #define LL long long #define ULL unsigned long long #define MP make_pair #define mod 1000000007 #define eps 1e-8 #define pi acos(-1.0) #define inf 0x3fffffff int n,m; struct edge{ int u,v; }e[100]; int deg[10]; int c1[10]; int c2[10]; int ans = 0; void dfs(int cur){ // cout&lt;&lt;\"cur: \"&lt;&lt;cur&lt;&lt;endl; // for(int i = 1; i &lt;= n; i ++){ // cout&lt;&lt;c1[i]&lt;&lt;\" \"; // } // cout&lt;&lt;endl; // for(int i = 1; i &lt;= n; i ++){ // cout&lt;&lt;c2[i]&lt;&lt;\" \"; // } // cout&lt;&lt;endl; if(cur == m+1){ ans++; return; } int v = e[cur].v; int u = e[cur].u; if(c1[u] &amp;&amp; c1[v]){ c1[u] --; c1[v] --; dfs(cur+1); c1[u] ++; c1[v] ++; } if(c2[u] &amp;&amp; c2[v]){ c2[u] --; c2[v] --; dfs(cur+1); c2[u] ++; c2[v] ++; } return; } int main() { #ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout); #endif int t; scanf(\"%d\",&amp;t); while(t--){ scanf(\"%d%d\",&amp;n,&amp;m); ans = 0; memset(deg,0,sizeof(deg)); memset(c1,0,sizeof(c1)); memset(c2,0,sizeof(c2)); for(int i = 1; i &lt;=m; i++){ scanf(\"%d%d\",&amp;e[i].u,&amp;e[i].v); deg[e[i].v]++; deg[e[i].u]++; } int flag = 1; for(int i = 1; i &lt;= n; i++){ if(deg[i] &amp; 1){ flag = 0; break; } c1[i] = deg[i]/2; c2[i] = deg[i]/2; } if(!flag){ puts(\"0\"); continue; } dfs(1); printf(\"%d\\n\",ans); } }"},{"title":"hdu 5088 2015多校联训第一场 1001 因数分解","permalink":"http://blog.jetmuffin.com/2015/07/21/hdu-5088-2015-multi-school-training-1001-solution/","text":"题目题目链接：OO’s Sequence 题意题意比较明确，f(l,r)表示[l,r]区间内，满足条件（对于任意区间内的某个数i自身外的其他数j，均不存在i%j==0）的i的个数，最后则是要求所有区间（枚举所有区间）的f函数和。 n范围为10^5，ai范围10^4 思路一开始上手总觉得这复杂度怎么做很难达到n^2以内，之后经良哥指点得出一好方法。与其求区间内满足条件的i的个数，不如求i有贡献的区间。 对于每个i，获取其左端能整除它的最近的数的下标l,其右端能整除它的最近的数的下标r，对于区间[l+1,r-1]之内的所有包括i在内的子区间均有贡献作用，而在[1,l]和[r,n]之间因为存在数能够整除i，因此i不满足题意条件，无贡献。因此只要枚举所有的数i,累加(i - l[i] + 1) * (r[i] - i + 1)即为答案。 所以问题就变为如何获取l和r，最开始的想法是暴力向两端枚举，果断超时；然后考虑用素数的特点取剪枝枚举，结果超时+1,而且对于1的情况还不好判断；最后考虑分解因数，用数组维护每个数出现位置，对于当前数i，枚举其因数，并取其最接近于i的一个。 再交一发后发现还是会T，最后提前用vector对10^4范围的数打了一个因数表，然后进行枚举，就能过了。。ORZ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;map&gt; #include &lt;cmath&gt; #include &lt;vector&gt; using namespace std; #define LL long long const int maxn = 100005; const int mod = 1000000007; const int N = 10001; int f[maxn]; int l[maxn]; int r[maxn]; int vis[maxn]; vector&lt;int&gt; fa[10010]; int main(){ int n; for(int i=1;i&lt;=10000;i++) { for(int j=1;j&lt;=i;j++) { if(i%j==0) { fa[i].push_back(j); } } } while(~scanf(\"%d\",&amp;n)){ int cnt = 0; memset(vis,0,sizeof(vis)); // m.clear(); for(int i = 1 ; i &lt;= n; i++){ scanf(\"%d\",f+i); } LL ans = 0; for(int i = 1 ; i &lt;= n; i++){ l[i] = 1; for(int k = 0; k &lt; fa[f[i]].size();k++ ){ int j = fa[f[i]][k]; if(vis[j]){ // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;f[i]&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;vis[j]&lt;&lt;\" @\"&lt;&lt;endl; int t = i - vis[j] - 1; if(t &lt; i - l[i]) l[i] = vis[j] + 1; } } vis[f[i]] = i; } memset(vis,0,sizeof(vis)); for(int i = n ; i &gt; 0; i--){ r[i] = n; for(int k = 0; k &lt; fa[f[i]].size();k++ ){ int j = fa[f[i]][k]; if(vis[j]){ // cout&lt;&lt;f[i]&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;\"#\"&lt;&lt;endl; int t = vis[j] - i - 1; if(t &lt; r[i] - i ) r[i] = vis[j] - 1; } } vis[f[i]] = i; } // for(int i = 1 ; i &lt;= n; i++){ // cout&lt;&lt;l[i]&lt;&lt;\" \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;r[i]&lt;&lt;endl; // } for(int i = 1 ; i &lt;= n; i++){ ans = (ans + (i - l[i] + 1) * (r[i] - i + 1) )% mod; } printf(\"%lld\\n\",ans); } }"},{"title":"基础算法训练 - 排序专题","permalink":"http://blog.jetmuffin.com/2015/07/12/basic-algorithm-training-sort/","text":"前言以前的算法和数据结构基础不是很扎实，从现在开始，弄懂每个算法的原理，打好基础。 1.快速排序快排的核心思想是分治，核心算法则是对数组的划分： `quicksort(A,p,r): if p &lt; r q = partition(A,p,r) quicksort(A,p,q-1) quicksort(A,q+1,r)` 其中划分函数partition的核心操作是： 将数组最后一个元素A[r]作为比较对象 i = p-1 , j = p, j不停自加，判断A[r]和A[j]大小，若A[j]小于A[r]则将后游标i前进1位，并交换a[i]和a[j] 最后交换a[i+1]和a[r] 交换所得目的数将所有比a[r]小的数放在数组前面，所有比a[r]大的数放在数组后面，a[r]则在数组中间，返回数字为比a[r]小的数的个数 代码： `#include using namespace std; int a[100] = {13,19,9,5,12,8,7,4,21,2,6,11}; void swap(int &amp;x,int &amp;y){ int t = x; x = y; y = t; } int partition(int p,int r){ int i = p - 1; int j = p; for(;j &lt; r; j++){ if(a[j] &lt; a[r]){ i++; swap(a[i],a[j]); } } swap(a[r],a[i+1]); return i+1; } void quicksort(int p,int r){ if(p &lt; r){ int q = partition(p,r); quicksort(p,q-1); quicksort(q+1,r); } } int main(){ quicksort(0,11); // int n = partition(0,11); for(int i = 0 ; i &lt; 12;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; }`"},{"title":"hdu 1176 免费馅饼 变型数塔 dp","permalink":"http://blog.jetmuffin.com/2015/06/27/hdu-1176-free-pie-dp/","text":"分析题目：题目链接 按题意，t时间会落下一个馅饼在x位置，而处于x’位置的gameboy只能拿到x’+1、x’、x’-1三个位置的馅饼，若将馅饼下落信息用一个数组f[t][x]，发现对于每个i，j，gameboy只能取得f[i+1][j+1]，f[i+1][j-1]，f[i+1][j]三个值，要使得最后取得的值最大，一看这是典型的数塔问题，然后就可以用dp轻松解决了 注意：由于数组每层在计算后不再使用，所以直接用原数组进行滚动，从下往上将结果累加即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long#define MP make_pair#define mod 1000000007#define eps 1e-8#define pi acos(-1.0)#define inf 0x3fffffff#define maxn 200055 int f[maxn][20]; int maxx(int a,int b,int c)&#123; return max(max(a,b),c);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout); #endif int n; while(~scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; int t,x; memset(f,0,sizeof(f)); int mx = 0; for(int i = 0 ; i &lt; n; i++)&#123; scanf(\"%d %d\",&amp;x,&amp;t); f[t][x+1] ++; if(t &gt; mx) mx = t; &#125; for(int i = mx -1 ; i &gt; 0; i--)&#123; for(int j = 1; j &lt;= 11;j++)&#123; f[i][j] += maxx(f[i+1][j],f[i+1][j-1],f[i+1][j+1]); &#125; &#125; printf(\"%d\\n\",maxx(f[1][5],f[1][6],f[1][7])); &#125;&#125;"},{"title":"文本挖掘初步 - 文本特征值提取","permalink":"http://blog.jetmuffin.com/2015/06/26/text-mining-feature-extraction/","text":"背景继续上文文本中文分词的内容，本文的目的是从文本中提取出其特征向量，以便之后的分类器进行分类。 语料库本文采用Sougou实验室的语料库，下载地址为：搜狗实验室文本分类资料。其中预料文件大小不一，有mini版(136K)，精简版(30M)，以及完整版(108M)，这里笔者就直接上最大的语料了～:lol: 文档结构： C000007 汽车 C000008 财经 C000010 IT C000013 健康 C000014 体育 C000016 旅游 C000020 教育 C000022 招聘 C000023 文学 C000024 军事 注意：搜狗的语料库均为GBK编码，若在Linux环境下会出现乱码影响处理，建议修改文件编码为utf-8 词袋模型利用中文分词工具，我们对每篇文章进行分词，去停用词后，用一个Map存储每个词的相关信息，保存形式为单词 &lt;词的文本字符串, 词的相关属性&gt;，其中单词(Term)的相关属性有(词性、tf、df、tfidf、chi等)。这样，遍历数据集目录和文件，就能去将全部的文档分词，最终就能构建词袋模型。 其中词(Term)的类如下： 12345678910111213141516package com.jetmuffin.TextClassifier.common;public class Term &#123; private int id; private String word; private String lexicalCategory = \"unknown\"; private int freq = 0; private double tf; private double idf; private double tfidf = 0; private double chi = 0; public void setId(int id)&#123; .... &#125; ...... 而词袋的存储Map格式如下: 12345678private int totalDocCount;private final List labels = new ArrayList();// Map&lt;类别, 文档数量&gt;private final Map&lt;String, Integer&gt; labelledTotalDocCountMap = new HashMap&lt;String, Integer&gt;();// Map&lt;类别, Map&lt;文档 ,Map&lt;词, 词信息&gt;&gt;&gt;private final Map&lt;String, Map&lt;String, Map&lt;String, Term&gt;&gt;&gt; termTable = new HashMap&lt;String, Map&lt;String, Map&lt;String, Term&gt;&gt;&gt;();// Map&lt;词 ,Map&lt;类别, Set&lt;文档&gt;&gt;&gt;private final Map&lt;String, Map&lt;String, Set&gt;&gt; invertedTable = new HashMap&lt;String, Map&lt;String, Set&gt;&gt;(); 特征值(TFIDF)计算tfidf是文本分类中最常使用的特征权值，其中tf(Term Frequency)为词频，idf为(Inverse Document Frequency)，tf反映了该词在该类文本中的热门程度，而idf则反映了该词对于其他文本更好的区别能力。 tfidf的计算方式如下： 卡方拟合检验经上一步计算出的tfidf值作为文章的特征值，但因为文章所包含的词往往非常多，特征向量的维数巨大，可能会达到上千维之多。因此需要对文章的特征向量进行降维。 进行降维，可以达到以下效果： 避免过拟合（over fitting），提高分类准确度 通过降维，大大节省计算时间和空间我们选择基于卡方统计量（chi-square statistic， CHI）技术来实现选择，这里根据计算公式： 其中，公式中各个参数的含义，说明如下： N：训练数据集文档总数 A：在一个类别中，包含某个词的文档的数量 B：在一个类别中，排除该类别，其他类别包含某个词的文档的数量 C：在一个类别中，不包含某个词的文档的数量 D：在一个类别中，不包含某个词也不在该类别中的文档的数量使用卡方统计量，为每个类别下的每个词都进行计算得到一个CHI值，然后对这个类别下的所有的词基于CHI值进行排序，选择出最大的topN个词；最后将多个类别下选择的多组topN个词进行合并，得到最终的特征向量。 向量空间模型提取文档的特征向量，目的是建立向量空间模型，每个文档 dj 可以用标引项向量来表示 (a1j,a2j,…,aMj) 利用向量空间模型，可以很容易计算出两个文档的相似度： 余弦公式（计算向量夹角） 欧式距离（计算两点距离）计算出了文本相似度（文本距离），则可以进行我们的下，即进行分类器的建立了。我们将在后续的文章继续研究不同的分类方法对文本的分类，包括： KNN SVM Naive Bayes BP Neural Network (furthermore, RBF Neural Network)"},{"title":"hdu 5245 Joyful ACM上海大都会邀请赛 J题 概率","permalink":"http://blog.jetmuffin.com/2015/06/06/hdu-5245-Joyful-ACM-shanghai-invitation-J-probability/","text":"题目：http://acm.hdu.edu.cn/showproblem.php?pid=5245 题意：给定一个n行m列的方阵，每次选2个点(x1,y1),(x2,y2)，由这两个点为左上角和右下角可以确定一个矩形区域，将这个区域的格子涂黑；进行以上操作k次，问被涂黑的格子的数量的期望。 分析：针对每个格子(i,j)计算其被涂黑的概率，再将其相加则为涂黑格子数量期望，再进行k次操作即为答案。 每个格子，可以分为以下几个区域： 对于整个方阵，取一个点的种类共有mn种，取两个点则有m2n2种。 按后考虑将该格子(i,j),即图中的5号格子涂黑的种类数量。根据点1(x1,y1)的位置，可以确定点2(x2,y2)的位置分布，即可确定种类数。 若(x1,y1)在区域1,则(x2,y2)必然在区域5,6,7,8，种数(i-1)(j-1)(n-i+1)*(m-j+1); 若(x1,y1)在区域2,则(x2,y2)必然在区域4,5,6,7,8,9，种数(i-1)1m*(n-i+1); 若(x1,y1)在区域3,则(x2,y2)必然在区域4,5,7,8，种数(i-1)(m-j)(n-i+1)*j; 若(x1,y1)在区域4,则(x2,y2)必然在区域2,3,5,6,8,9，种数1(j-1)n*(m-j+1); 若(x1,y1)在区域5,则(x2,y2)必然在区域1,2,3,4,5,6,7,8,9，种数mn1*1; 若(x1,y1)在区域6,则(x2,y2)必然在区域1,2,4,5,7,8，种数(m-j)1n*j; 若(x1,y1)在区域7,则(x2,y2)必然在区域2,3,5,6，种数i(m-j+1)(n-i)*(j-1); 若(x1,y1)在区域8,则(x2,y2)必然在区域1,2,3,4,5,6，种数(n-i)1m*i; 若(x1,y1)在区域9,则(x2,y2)必然在区域1,2,4,5，种数(n-i)(m-j)i*j; 最后将种数相加再除以总数即为概率，对每个点的概率相加则为总该率，然后做k次就是答案了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long longint main()&#123; int t; cin&gt;&gt;t; int cnt = 0; while(t--)&#123; cnt++; int k; double n,m; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; double ans = 0; for(int i = 1; i &lt;= n; i++ ) for(int j = 1; j &lt;= m; j++)&#123; double tot = 0.0; tot += (i-1)*(j-1)*(n-i+1)*(m-j+1); tot += (i-1)*1*m*(n-i+1); tot += (i-1)*(m-j)*(n-i+1)*j; tot += 1*(j-1)*n*(m-j+1); tot += m*n*1*1; tot += (m-j)*1*n*j; tot += i*(m-j+1)*(n-i)*(j-1); tot += (n-i)*1*m*i; tot += (n-i)*(m-j)*i*j; tot = tot /n/n/m/m; ans += 1 - pow(1-tot,k); &#125; printf(\"Case #%d: %d\\n\",cnt,int(ans+0.5)); &#125;&#125;"},{"title":"hdu 5241 Friends ACM上海大都会邀请赛 F题","permalink":"http://blog.jetmuffin.com/2015/06/06/hdu-5241-Friends-ACM-shanghai-invitation-F/","text":"题目：http://acm.hdu.edu.cn/showproblem.php?pid=5241 题意：Mike会n种语言，而从Alice到Irene会的语言满足一系列的子集关系，问题为给定第一个n，所有的情况总数数量。 分析：由于各种语言互相独立，所以最后的答案肯定是一个数的n次方，即kn，而对于这个k可以用暴力的方法解出来，即当n=1的时候的数量，以下为解法： 各个小伙伴的语言关系如下图，其中有向箭头表示语言”≥”。 可以从图中得出的答案是，以a,b,c,d,e,f,g,h,i表示Alice, Bob, Carol, Dave, Eve, Frank, Gloria, Henry and Irene所会语言种数（0或者1）的可能性数量，则满足以下条件： a = n d = n e = min(a,d) g = d b = min(a,g) c = min(b,e) f = min(g,e) h = g i = h 再根据以上条件暴力解的k的大小为32： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n = 1; int ans = 0; for(int a = 0; a &lt;= n;a++) for(int d = 0; d &lt;=n ; d++) for(int e = 0;e &lt;= min(a,d);e++) for(int g = 0; g&lt;= d;g++) for(int b = 0; b&lt;= min(a,g);b++) for(int c = 0; c&lt;= min(b,e);c++) for(int f = 0; f&lt;= min(g,e);f++) for(int h = 0 ; h&lt;=g;h++) for(int i = 0; i &lt;= h ;i++) ans++; cout&lt;&lt;ans&lt;&lt;endl;&#125;`然后直接上java的大数就行了！`import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); int cnt = 0; while(t &gt; 0)&#123; t--; cnt++; int n = sc.nextInt(); BigInteger base = BigInteger.valueOf(32); BigInteger ans = BigInteger.valueOf(1); for(int i = 0 ; i &lt; n; i++)&#123; ans = ans.multiply(base); &#125; System.out.println(\"Case #\" + cnt +\": \"+ans); &#125; &#125;&#125;"},{"title":"文本挖掘初步 - 文本中文分词","permalink":"http://blog.jetmuffin.com/2015/06/05/text-mining-chinese-segments/","text":"介绍中文分词(Chinese Word Segmentation)指的是将一个汉字序列切分成一个一个单独的词。 如同编译原理中的词法分析的重要性,中文分词是文本挖掘的基础,需要通过机器自动将输入的句子切分成一个个的词语,才能进行更多的处理. 中文分词和英文分词最大的区别在于,英文单词之间是以空格作为自然分界符的，而汉语是以字为基本的书写单位，词语之间没有明显的区分标记,因此中文分词的难度比英文分词大了很多. 方法分词算法可分为三大类：基于字典、词库匹配的分词方法,基于词频度统计的分词方法和基于知识理解的分词方法。 1. 基于字典,词库(字符串匹配)的分词方法 这种方法按照一定策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行匹配，若在词典中找到某个字符串，则匹配成功。识别出一个词，根据扫描方向的不同分为正向匹配和逆向匹配。采用该方法的分词算法主要有: 正向最大匹配法（由左到右的方向） 逆向最大匹配法（由右到左的方向） 最少切分（使每一句中切出的词数最小） 2.基于词频度统计的分词方法 这是一种全切分方法。它不依靠词典,而是将文章中任意两个字同时出现的频率进行统计,次数越高的就可能是一个词。它首先切分出与词表匹配的所有可能的词,运用统计语言模型和决策算法决定最优的切分结果。它的优点在于可以发现所有的切分歧义并且容易将新词提取出来。 3.基于知识理解的分词 该方法主要基于句法、语法分析，并结合语义分析，通过对上下文内容所提供信息的分析对词进行定界，它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断。这类方法试图让机器具有人类的理解能力，需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式。因此目前基于知识的分词系统还处在试验阶段。 工具在中文分词领域,有很多已经非常成熟的分词工具可以被使用,以下对各工具的算法和效率(根据网上情报)进行总结. 1.ICTCLAS(NLPIR) http://ictclas.nlpir.org/ ICTCLAS是中国科学院计算技术研究所在多年研究基础上，耗时一年研制出了基于多层隐马模型(HMM)的汉语词法分析系统 ，功能有：中文分词；词性标注；自定义词典等。分词正确率高,分词速度快.源代码数以C++编写的,并提供JAVA接口. 速度: 单机 (996KB/s) 2.Stanford Word Segmenter || CRF++ http://nlp.stanford.edu/software/segmenter.shtml 这两个中文分词工具都是基于条件随机场CRF(Conditional Random Field)模型实现的,其基本思路是对汉字进行标注即由字构词(组词)，不仅考虑了文字词语出现的频率信息，同时考虑上下文语境，具备较好的学习能力，因此其对歧义词和未登录词的识别都具有良好的效果；其不足之处是训练周期较长，运营时计算量较大. 速度: (暂未获得) 3.Mmseg http://technology.chtsai.org/mmseg/ Mmseg是典型的基于字典的中文分词工具,其主要实现原理是基于最大匹配算法.它提供Simple和Complex两种最大匹配算法,即简单的和复杂的.简单的最大匹配算法从字符串开头开始,获取最长的匹配串;而复杂的最大匹配算法则针对存在歧义的单词,向前再看两个单词再进行判断. Mmseg支持在lucene和solr中使用,在该二者中配置Mmseg,即可对中文文本进行分词索引.这也是Mmseg被使用广泛的一个原因.同时因为其实现原理简单,效果也很不错,且提供Java支持(Mmseg4j),也是很受欢迎的一款分词工具. 速度: complex 60W字/s (1200 KB/s) ；simple 100W字/s (1900 KB/s) 4.IKAnalyzer http://code.google.com/p/ik-analyzer/downloads/list IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。采用了特有的”正向迭代最细粒度切分算法”(我还没取研究这个算法),支持细粒度和智能分词两种切分模式.同样,IKAnalyzer也提供了对Solr和Lucene的支持. 速度: IK2012 160W字/s (3000KB/s) 代码根据分词的成功率,速率以及使用接口简单,在之后的所有后续挖掘过程中将采用ICTCLAS2015作为分词器,所以需要对其进行简单的封装. JNA实现接口CLibrary: 123456789101112131415package com.jetmuffin.analyzer;import com.sun.jna.Library;public interface CLibrary extends Library&#123; public int NLPIR_Init(String sDataPath, int encoding, String sLicenceCode); public String NLPIR_ParagraphProcess(String sSrc, int bPOSTagged); public String NLPIR_GetKeyWords(String sLine, int nMaxKeyLimit, boolean bWeightOut); public String NLPIR_GetFileKeyWords(String sLine, int nMaxKeyLimit, boolean bWeightOut); public int NLPIR_AddUserWord(String sWord);//add by qp 2008.11.10 public int NLPIR_DelUsrWord(String sWord);//add by qp 2008.11.10 public int NLPIR_ImportUserDict(String sWord,boolean bOverWrite); public String NLPIR_WordFreqStat(String sWord); public String NLPIR_GetLastErrorMsg(); public void NLPIR_Exit();&#125; 接口实现类Nlpir: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jetmuffin.analyzer;import com.sun.jna.Native;public class NLPIR &#123; public static CLibrary Instance; private String systemCharset; private String systemFolder; int charsetType; public NLPIR()&#123; systemFolder = \"/home/jeff/src/ICTCLAS2015\"; //ICTCLAS的目录,包括字典文件等 systemCharset = \"UTF-8\"; //默认字符集 charsetType = 1; Instance = (CLibrary) Native.loadLibrary( \"/home/jeff/src/ICTCLAS2015/lib/linux32/libNLPIR.so\", CLibrary.class); //ICTCLAS的so文件地址 &#125; public static CLibrary getInstance() &#123; return Instance; &#125; public static void setInstance(CLibrary instance) &#123; Instance = instance; &#125; public String getSystemCharset() &#123; return systemCharset; &#125; public void setSystemCharset(String systemCharset) &#123; this.systemCharset = systemCharset; &#125; public String getSystemFolder() &#123; return systemFolder; &#125; public void setSystemFolder(String systemFolder) &#123; this.systemFolder = systemFolder; &#125; public int getCharsetType() &#123; return charsetType; &#125; public void setCharsetType(int charsetType) &#123; this.charsetType = charsetType; &#125; &#125;&#125; 测试类: 123456789101112131415161718192021package com.jetmuffin.test;import org.junit.Test;import com.jetmuffin.NLPIR;public class TestNlpir &#123; @Test public void test()&#123; NLPIR nlpir = new NLPIR(); nlpir.Instance.NLPIR_Init(nlpir.getSystemFolder(),nlpir.getCharsetType() ,nlpir.getSystemCharset()); String nativeBytes = null; String sInput = \"什么是机器学习\"; nlpir.Instance.NLPIR_ImportUserDict(\"/home/jeff/workspace/data/dict\", false); //加载用户自定义词典 nativeBytes = nlpir.Instance.NLPIR_ParagraphProcess(sInput, 0); //分词 String[] words = nativeBytes.split(\" \"); //分词结果以空格进行分割 System.out.println(words.length); //输出分词词数 System.out.println(nativeBytes); //输出分词结果 &#125; &#125;&#125; 结果: 123 什么 是 机器学习 结语进行分类器的封装以后,可以继续进行之后的文本挖掘内容.以上均为本人拙见,且本人为NLP菜鸟,望大牛予以指正! :)"},{"title":"文本挖掘初步 - 对自由文本进行信息抽取","permalink":"http://blog.jetmuffin.com/2015/05/10/text-mining-extract-information-from-text/","text":"文本挖掘最近的一个比赛，做的主体部分是文本挖掘，核心内容是从一堆自由文本（大多是爬虫爬取内容）中提取出可用的数据。因为刚刚接触这个领域，所以很多内容是边学边做，顺便做做记录。 文本挖掘需要用到的内容有机器学习（Machine Learning)，数据挖掘(Data Mining)，自然语言处理(Natural Language Process)等多个领域的内容，因此在之后的文章依次记录相应学习过程。 步骤准备采取的过程为以下步骤： 文本中文分词 文本特征值提取 利用机器学习方法进行文本分类 分类信息挖掘 感激整个学习和开发过程中查阅了很多资料，以下几个博主的文章对我有很大帮助，对此表示感谢： 使用libsvm实现文本分类 - Yanjun K-means文本聚类系列 - finallyliuyu"},{"title":"编程之美初赛第三题 质数相关 小数据解法","permalink":"http://blog.jetmuffin.com/2015/04/25/beautiful-of-coding-3/","text":"时间限制:2000ms单点时限:1000ms内存限制:256MB 描述两个数a和 b (a&lt;b)被称为质数相关，是指a × p = b，这里p是一个质数。一个集合S被称为质数相关，是指S中存在两个质数相关的数，否则称S为质数无关。如{2, 8, 17}质数无关，但{2, 8, 16}, {3, 6}质数相关。现在给定一个集合S，问S的所有质数无关子集中，最大的子集的大小。 输入 第一行为一个数T，为数据组数。之后每组数据包含两行。 第一行为N，为集合S的大小。第二行为N个整数，表示集合内的数。 输出对于每组数据输出一行，形如”Case #X: Y”。X为数据编号，从1开始，Y为最大的子集的大小。 数据范围1 ≤ T ≤ 20 集合S内的数两两不同且范围在1到500000之间。 小数据 1 ≤ N ≤ 15 大数据 1 ≤ N ≤ 1000 样例输入352 4 8 16 3252 3 4 6 931 2 3 小数据解法： 模拟选择每个组合，判断其中每两个子元素做商是否为素数，小数据不会超时，大数据要通过图来做，之后提供。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;#define maxn 500001int f[15];vector&lt;int&gt; v;vector&lt;int&gt;::iterator it;vector&lt;int&gt;::iterator itj;int ans = 0;bool prime[maxn];void IsPrime()&#123; prime[0]=prime[1]=0;prime[2]=1; for(int i=3;i&lt;maxn;i++) prime[i]=i%2==0?0:1; int t=(int)sqrt(maxn*1.0); for(int i=3;i&lt;=t;i++) if(prime[i]) for(int j=i*i;j&lt;maxn;j+=2*i)//优化 prime[j]=0;&#125;void output()&#123; for(it = v.begin();it!=v.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int check()&#123; if(v.size() == 1) return 1; for(it = v.begin();it!=v.end()-1;it++)&#123; for(itj = v.begin()+1;itj!=v.end();itj++)&#123; int x = *it; int y = *itj; //cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl; if(y%x==0)&#123; // cout&lt;&lt;\"sub:\"&lt;&lt;y/x&lt;&lt;endl; if(prime[y/x]) return 0; &#125; &#125; &#125; return 1;&#125;int solve(int count)&#123; for(int i = 1; i &lt; (int)1&lt;&lt;count; i++)&#123; v.clear(); for(int j = 0; j &lt; count; j++)&#123; if(i &amp; (1&lt;&lt;j))&#123; //cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; v.push_back(f[j]); &#125; &#125; //output(); if(check())&#123; if(v.size() &gt; ans) ans = v.size(); &#125; &#125;&#125;int main() &#123; int T; cin&gt;&gt;T; for(int cnt = 0 ; cnt &lt; T; cnt ++)&#123; ans = 0; int n; cin&gt;&gt;n; for(int i = 0 ; i &lt; n ; i++) cin&gt;&gt;f[i]; sort(f,f+n); IsPrime(); solve(n); cout&lt;&lt;\"Case #\"&lt;&lt;cnt+1&lt;&lt;\": \"&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;"},{"title":"蓝桥杯算法训练-逆序对 解题报告","permalink":"http://blog.jetmuffin.com/2015/03/28/blue-bridge-cup-training-reverse-couples/","text":"问题描述大体意思是，根据输入构建一棵二叉树，其中以其叶子节点从左到右为一数列，为了使得该数列的逆序对最少，可以对每个非叶子节点进行调换左右字数操作，求最少的逆序对。 算法思路题目标明用平衡二叉树进行处理，可以选择用Splay树或者AVL树进行处理，考虑到之前求逆序对的题目原型一般用归并排序进行，所以这里我打算用归并排序加动态规划处理。 由于题目中特殊的树结构，所以将传统的归并排序的二分改为递归到叶子节点，再合并到根节点。根据其最优子结构，要使得整体逆序对最少，也就是每个子树的逆序对最少，以此类推。可以很容易得到递推公式： f(root) = f(left) + ｆ(right) + min(merge(left , right) , merge(right , left)); 合并时的思路为，a[i]和b[j]分别表示两个序列的相应元素，若a[i] &gt; b[j]，则a[i]之后的数均大于b[j]，因为该序列为从小到大排序的，这样就可以统计逆序对了。 同理可以统计顺序对，顺序对则对应了调换子树后的逆序对，比较顺序对和逆序对的大小，然后求f(root)，同时合并序列至根节点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long#define MP make_pair#define mod 1000000007#define eps 1e-8#define pi acos(-1.0)#define inf 0x3fffffff#define maxn 400005struct node&#123; vector&lt;int&gt; v; LL min;&#125;; LL ans;LL maxx=0;LL maxxx = 0;int flag = 0;node merge(node l,node r);node build_tree(LL i)&#123;// printf(\"node %d:\\n\",i); int x; scanf(\"%d\",&amp;x); node t; t.min = 0; if(x != 0) t.v.push_back(x); else&#123; node l = build_tree(i+1); node r = build_tree(i+1); t = merge(l,r); &#125; if(i == 1) ans = t.min; return t;&#125;node merge(node l,node r)&#123; if(l.v.size() &gt; maxx) maxx = l.v.size(); if(r.v.size() &gt; maxx) maxx = r.v.size(); int i = 0 ,j = 0; LL l_cnt = 0,r_cnt = 0; vector&lt;int&gt;tmp; while(i &lt; l.v.size() &amp;&amp; j &lt; r.v.size())&#123; if(l.v[i] == r.v[j])&#123; tmp.push_back(l.v[i]); tmp.push_back(r.v[j]); &#125; else if(l.v[i] &lt; r.v[j])&#123; r_cnt += r.v.size() - j; tmp.push_back(l.v[i++]); &#125; else&#123; l_cnt += l.v.size() - i; tmp.push_back(r.v[j++]); &#125; &#125; while(i &lt; l.v.size()) tmp.push_back(l.v[i++]); while(j &lt; r.v.size()) tmp.push_back(r.v[j++]); node root; root.min = l.min + r.min + min(l_cnt,r_cnt); for(int k = 0; k &lt; tmp.size();k++)&#123;// printf(\"%d \",tmp[k]); root.v.push_back(tmp[k]); &#125;// printf(\"\\n\"); return root;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin);//freopen(\"output.txt\",\"w\",stdout); #endif LL n; scanf(\"%d\",&amp;n); build_tree(1); cout&lt;&lt;ans&lt;&lt;endl;&#125; 结果最后提交OJ的时候发现25组只通过了12组，48分，也就是说该方法还是有问题，理论上复杂度为o(nlogn)，但是数据过强，所以待我习得Splay大法后写一份Splay的解法。"},{"title":"hdu 5179 BestCoder #31 1002 beautiful number 解题报告","permalink":"http://blog.jetmuffin.com/2015/03/07/hdu-5179-BestCoder-31-1002-beautiful-number-solution/","text":"题目要求找出1e9范围内的满足条件的数，且对于每次查询要给出范围内的数的个数，复杂度条件非常苛刻。 但是该类数本身数量就不多，于是想到离线算出所有数，然后二分答案。 离线求这些数的方法可以DFS或者直接暴力，为了方便我就直接暴力了，半分钟左右出答案。 离线代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int x[9];int len;void work(int n)&#123; int i = 0; while(n&gt;0) &#123; x[i++] = n % 10; n /= 10; &#125; len = i;&#125;int check()&#123; for(int i = 0 ; i &lt; len - 1; i++) if(x[i] &gt; x[i+1]) return 0; for(int i = 0 ; i &lt; len ; i++) if(x[i] == 0) return 0; for(int i = 0 ; i &lt; len - 1; i++) for(int j = i + 1; j &lt; len; j++) if(x[j] % x[i] != 0) return 0; return 1;&#125;int main()&#123; freopen(\"out\",\"w\",stdout); int cnt = 0; for(int i = 1; i &lt;= 999999999; i++) &#123; work(i); if(check()) &#123; cnt++; cout&lt;&lt;i&lt;&lt;\",\"; &#125; &#125; cout&lt;&lt;endl; cout&lt;&lt;cnt&lt;&lt;endl;&#125;`求出这些数大概有1299个，然后对于每次查询，可以直接遍历范围在L～R之间的个数，也可以二分L，二分R，然后序号相减，代码很长，前方高能预警。`#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int f[]=&#123;1,2,3,4,5,6,7,8,9,11,21,22,31,33,41,42,44,51,55,61,62,63,66,71,77,81,82,84,88,91,93,99,111,211,221,222,311,331,333,411,421,422,441,442,444,511,551,555,611,621,622,631,633,661,662,663,666,711,771,777,811,821,822,841,842,844,881,882,884,888,911,931,933,991,993,999,1111,2111,2211,2221,2222,3111,3311,3331,3333,4111,4211,4221,4222,4411,4421,4422,4441,4442,4444,5111,5511,5551,5555,6111,6211,6221,6222,6311,6331,6333,6611,6621,6622,6631,6633,6661,6662,6663,6666,7111,7711,7771,7777,8111,8211,8221,8222,8411,8421,8422,8441,8442,8444,8811,8821,8822,8841,8842,8844,8881,8882,8884,8888,9111,9311,9331,9333,9911,9931,9933,9991,9993,9999,11111,21111,22111,22211,22221,22222,31111,33111,33311,33331,33333,41111,42111,42211,42221,42222,44111,44211,44221,44222,44411,44421,44422,44441,44442,44444,51111,55111,55511,55551,55555,61111,62111,62211,62221,62222,63111,63311,63331,63333,66111,66211,66221,66222,66311,66331,66333,66611,66621,66622,66631,66633,66661,66662,66663,66666,71111,77111,77711,77771,77777,81111,82111,82211,82221,82222,84111,84211,84221,84222,84411,84421,84422,84441,84442,84444,88111,88211,88221,88222,88411,88421,88422,88441,88442,88444,88811,88821,88822,88841,88842,88844,88881,88882,88884,88888,91111,93111,93311,93331,93333,99111,99311,99331,99333,99911,99931,99933,99991,99993,99999,111111,211111,221111,222111,222211,222221,222222,311111,331111,333111,333311,333331,333333,411111,421111,422111,422211,422221,422222,441111,442111,442211,442221,442222,444111,444211,444221,444222,444411,444421,444422,444441,444442,444444,511111,551111,555111,555511,555551,555555,611111,621111,622111,622211,622221,622222,631111,633111,633311,633331,633333,661111,662111,662211,662221,662222,663111,663311,663331,663333,666111,666211,666221,666222,666311,666331,666333,666611,666621,666622,666631,666633,666661,666662,666663,666666,711111,771111,777111,777711,777771,777777,811111,821111,822111,822211,822221,822222,841111,842111,842211,842221,842222,844111,844211,844221,844222,844411,844421,844422,844441,844442,844444,881111,882111,882211,882221,882222,884111,884211,884221,884222,884411,884421,884422,884441,884442,884444,888111,888211,888221,888222,888411,888421,888422,888441,888442,888444,888811,888821,888822,888841,888842,888844,888881,888882,888884,888888,911111,931111,933111,933311,933331,933333,991111,993111,993311,993331,993333,999111,999311,999331,999333,999911,999931,999933,999991,999993,999999,1111111,2111111,2211111,2221111,2222111,2222211,2222221,2222222,3111111,3311111,3331111,3333111,3333311,3333331,3333333,4111111,4211111,4221111,4222111,4222211,4222221,4222222,4411111,4421111,4422111,4422211,4422221,4422222,4441111,4442111,4442211,4442221,4442222,4444111,4444211,4444221,4444222,4444411,4444421,4444422,4444441,4444442,4444444,5111111,5511111,5551111,5555111,5555511,5555551,5555555,6111111,6211111,6221111,6222111,6222211,6222221,6222222,6311111,6331111,6333111,6333311,6333331,6333333,6611111,6621111,6622111,6622211,6622221,6622222,6631111,6633111,6633311,6633331,6633333,6661111,6662111,6662211,6662221,6662222,6663111,6663311,6663331,6663333,6666111,6666211,6666221,6666222,6666311,6666331,6666333,6666611,6666621,6666622,6666631,6666633,6666661,6666662,6666663,6666666,7111111,7711111,7771111,7777111,7777711,7777771,7777777,8111111,8211111,8221111,8222111,8222211,8222221,8222222,8411111,8421111,8422111,8422211,8422221,8422222,8441111,8442111,8442211,8442221,8442222,8444111,8444211,8444221,8444222,8444411,8444421,8444422,8444441,8444442,8444444,8811111,8821111,8822111,8822211,8822221,8822222,8841111,8842111,8842211,8842221,8842222,8844111,8844211,8844221,8844222,8844411,8844421,8844422,8844441,8844442,8844444,8881111,8882111,8882211,8882221,8882222,8884111,8884211,8884221,8884222,8884411,8884421,8884422,8884441,8884442,8884444,8888111,8888211,8888221,8888222,8888411,8888421,8888422,8888441,8888442,8888444,8888811,8888821,8888822,8888841,8888842,8888844,8888881,8888882,8888884,8888888,9111111,9311111,9331111,9333111,9333311,9333331,9333333,9911111,9931111,9933111,9933311,9933331,9933333,9991111,9993111,9993311,9993331,9993333,9999111,9999311,9999331,9999333,9999911,9999931,9999933,9999991,9999993,9999999,11111111,21111111,22111111,22211111,22221111,22222111,22222211,22222221,22222222,31111111,33111111,33311111,33331111,33333111,33333311,33333331,33333333,41111111,42111111,42211111,42221111,42222111,42222211,42222221,42222222,44111111,44211111,44221111,44222111,44222211,44222221,44222222,44411111,44421111,44422111,44422211,44422221,44422222,44441111,44442111,44442211,44442221,44442222,44444111,44444211,44444221,44444222,44444411,44444421,44444422,44444441,44444442,44444444,51111111,55111111,55511111,55551111,55555111,55555511,55555551,55555555,61111111,62111111,62211111,62221111,62222111,62222211,62222221,62222222,63111111,63311111,63331111,63333111,63333311,63333331,63333333,66111111,66211111,66221111,66222111,66222211,66222221,66222222,66311111,66331111,66333111,66333311,66333331,66333333,66611111,66621111,66622111,66622211,66622221,66622222,66631111,66633111,66633311,66633331,66633333,66661111,66662111,66662211,66662221,66662222,66663111,66663311,66663331,66663333,66666111,66666211,66666221,66666222,66666311,66666331,66666333,66666611,66666621,66666622,66666631,66666633,66666661,66666662,66666663,66666666,71111111,77111111,77711111,77771111,77777111,77777711,77777771,77777777,81111111,82111111,82211111,82221111,82222111,82222211,82222221,82222222,84111111,84211111,84221111,84222111,84222211,84222221,84222222,84411111,84421111,84422111,84422211,84422221,84422222,84441111,84442111,84442211,84442221,84442222,84444111,84444211,84444221,84444222,84444411,84444421,84444422,84444441,84444442,84444444,88111111,88211111,88221111,88222111,88222211,88222221,88222222,88411111,88421111,88422111,88422211,88422221,88422222,88441111,88442111,88442211,88442221,88442222,88444111,88444211,88444221,88444222,88444411,88444421,88444422,88444441,88444442,88444444,88811111,88821111,88822111,88822211,88822221,88822222,88841111,88842111,88842211,88842221,88842222,88844111,88844211,88844221,88844222,88844411,88844421,88844422,88844441,88844442,88844444,88881111,88882111,88882211,88882221,88882222,88884111,88884211,88884221,88884222,88884411,88884421,88884422,88884441,88884442,88884444,88888111,88888211,88888221,88888222,88888411,88888421,88888422,88888441,88888442,88888444,88888811,88888821,88888822,88888841,88888842,88888844,88888881,88888882,88888884,88888888,91111111,93111111,93311111,93331111,93333111,93333311,93333331,93333333,99111111,99311111,99331111,99333111,99333311,99333331,99333333,99911111,99931111,99933111,99933311,99933331,99933333,99991111,99993111,99993311,99993331,99993333,99999111,99999311,99999331,99999333,99999911,99999931,99999933,99999991,99999993,99999999,111111111,211111111,221111111,222111111,222211111,222221111,222222111,222222211,222222221,222222222,311111111,331111111,333111111,333311111,333331111,333333111,333333311,333333331,333333333,411111111,421111111,422111111,422211111,422221111,422222111,422222211,422222221,422222222,441111111,442111111,442211111,442221111,442222111,442222211,442222221,442222222,444111111,444211111,444221111,444222111,444222211,444222221,444222222,444411111,444421111,444422111,444422211,444422221,444422222,444441111,444442111,444442211,444442221,444442222,444444111,444444211,444444221,444444222,444444411,444444421,444444422,444444441,444444442,444444444,511111111,551111111,555111111,555511111,555551111,555555111,555555511,555555551,555555555,611111111,621111111,622111111,622211111,622221111,622222111,622222211,622222221,622222222,631111111,633111111,633311111,633331111,633333111,633333311,633333331,633333333,661111111,662111111,662211111,662221111,662222111,662222211,662222221,662222222,663111111,663311111,663331111,663333111,663333311,663333331,663333333,666111111,666211111,666221111,666222111,666222211,666222221,666222222,666311111,666331111,666333111,666333311,666333331,666333333,666611111,666621111,666622111,666622211,666622221,666622222,666631111,666633111,666633311,666633331,666633333,666661111,666662111,666662211,666662221,666662222,666663111,666663311,666663331,666663333,666666111,666666211,666666221,666666222,666666311,666666331,666666333,666666611,666666621,666666622,666666631,666666633,666666661,666666662,666666663,666666666,711111111,771111111,777111111,777711111,777771111,777777111,777777711,777777771,777777777,811111111,821111111,822111111,822211111,822221111,822222111,822222211,822222221,822222222,841111111,842111111,842211111,842221111,842222111,842222211,842222221,842222222,844111111,844211111,844221111,844222111,844222211,844222221,844222222,844411111,844421111,844422111,844422211,844422221,844422222,844441111,844442111,844442211,844442221,844442222,844444111,844444211,844444221,844444222,844444411,844444421,844444422,844444441,844444442,844444444,881111111,882111111,882211111,882221111,882222111,882222211,882222221,882222222,884111111,884211111,884221111,884222111,884222211,884222221,884222222,884411111,884421111,884422111,884422211,884422221,884422222,884441111,884442111,884442211,884442221,884442222,884444111,884444211,884444221,884444222,884444411,884444421,884444422,884444441,884444442,884444444,888111111,888211111,888221111,888222111,888222211,888222221,888222222,888411111,888421111,888422111,888422211,888422221,888422222,888441111,888442111,888442211,888442221,888442222,888444111,888444211,888444221,888444222,888444411,888444421,888444422,888444441,888444442,888444444,888811111,888821111,888822111,888822211,888822221,888822222,888841111,888842111,888842211,888842221,888842222,888844111,888844211,888844221,888844222,888844411,888844421,888844422,888844441,888844442,888844444,888881111,888882111,888882211,888882221,888882222,888884111,888884211,888884221,888884222,888884411,888884421,888884422,888884441,888884442,888884444,888888111,888888211,888888221,888888222,888888411,888888421,888888422,888888441,888888442,888888444,888888811,888888821,888888822,888888841,888888842,888888844,888888881,888888882,888888884,888888888,911111111,931111111,933111111,933311111,933331111,933333111,933333311,933333331,933333333,991111111,993111111,993311111,993331111,993333111,993333311,993333331,993333333,999111111,999311111,999331111,999333111,999333311,999333331,999333333,999911111,999931111,999933111,999933311,999933331,999933333,999991111,999993111,999993311,999993331,999993333,999999111,999999311,999999331,999999333,999999911,999999931,999999933,999999991,999999993,999999999&#125;;int n = 1299;int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; int L,R; cin&gt;&gt;L&gt;&gt;R; int ans = 0; for(int i = 0 ;i &lt; n;i++) &#123; if(f[i]&gt;= L &amp;&amp; f[i]&lt;=R) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;"},{"title":"Hdu 5178 BestCoder #31 1001 Pairs 解题报告","permalink":"http://blog.jetmuffin.com/2015/03/06/hdu-5178-Pairs/","text":"题意简单，找到线段上距离小于k的点对的个数。 解法为，先排序所有点，然后遍历每个点x[a]，二分刚好小于b=x[a]+k的所在点下标，表示a和a+1～b之间的点都为符合点。然后累加b-a即可。 用lower_bound会WA，要用upper_bound或者自己手写二分，问题出在当x[b]=x[a]+k时的区别。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define LL long long#define MAXN 100005int x[MAXN];int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; int n,k; scanf(\"%d%d\",&amp;n,&amp;k); for(int i = 0 ; i &lt; n ; i++) &#123; scanf(\"%d\",&amp;x[i]); &#125; sort(x,x+n); LL ans = 0; for(int i = 0; i &lt; n; i++) &#123; int b = upper_bound(x + i + 1, x + n, x[i] + k) - x - i - 1; // cout&lt;&lt;b&lt;&lt;endl; ans += b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;"},{"title":"弹出框popover点击框外区域关闭弹出框效果","permalink":"http://blog.jetmuffin.com/2015/03/04/popover/","text":"bootstrap用多了，前不久自己写一个popover，弹出很简单，但是让弹出框失去焦点消失时有点问题，记录一下： 原先的想法是获取鼠标点击范围，若鼠标点击在弹出框之外，则绑定事件关闭弹出框，代码如下： 然而这样非常的麻烦， ` … ` 之后发现加了一层黑色的遮罩后，弹出框必定在遮罩上方，这样其实只要给黑色遮罩绑定事件即可。 代码： `// 关闭登录框 var close_login_box= function (){ $(&apos;#black-layer&apos;).fadeOut(); $(&apos;#login-pop&apos;).fadeOut(); }; // 登录按钮点击事件 $(‘#login-btn’).click(function(){ $(&apos;#black-layer&apos;).fadeIn(); $(&apos;#login-pop&apos;).fadeIn(); return false; }); // 点击黑色区域直接关闭登陆框 $(‘#black-layer’).click(close_login_box);`"},{"title":"BestCoder #29 1002 hdu 5171 GTY's birthday gift 题解","permalink":"http://blog.jetmuffin.com/2015/02/07/bestCoder-29-1002-hdu-5171-gty-s-birthday-gift-solution/","text":"假期放松了太多，状态太差，水题都WA了好几发。。 先是第一题，思路很简单，取个对数判断大小就行了，然后脑抽了居然直接用“==”进行判断，事实上应该要用精度判断，然后卡到第二题做出来才想到。。ORZ 然后是第二题，读题后很容易可以发现最后的答案是取最大的2个数a,b，进行相加，然后得到第三个数a+b，再相加得到a+2b，反复下去类似斐波那契数列。然后可以得出a的系数是从斐波那契的某一项开始的前n项和-1，b同理是前某项和-2，然后用矩阵快速幂o(log(n))轻松搞定斐波那契，再加上数列所有数的和即可。 官方题解是直接从线性方程推出转移矩阵，然后根据三阶矩阵快速幂求得解，同样可用。 这里值得一提的是，我竟然直接无视题目中的mod 10000007，然后想当然地感觉这个数会按往常一样取int范围内最大的质数1000000007，然后按着事先打好的模板，结果failed final test了。。这也警告之后不能按照打好的模板来。。还是得自己纯手打好。。 HACK时看到好多人直接for循环跑。。交了两发，都Invalid Input的了，听群里人才知道。。数据最后要换行。。ORZ 本来这场2题保证涨分，紫名近在眼前。。可惜啊，还是要努力啊！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int N = 2;const long long MOD = 10000007;LL a[100005];struct Mat&#123; LL m[N][N];&#125;;Mat operator * (Mat a,Mat b)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i = 0 ; i &lt; N; i++) for(int j = 0 ; j &lt; N; j++) for(int k = 0 ; k &lt; N; k++) &#123; c.m[i][j] = (c.m[i][j]%MOD + (a.m[i][k]%MOD) * (b.m[k][j]% MOD) % MOD) % MOD; &#125; return c;&#125;Mat operator ^ (Mat a,LL k)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i = 0; i &lt; N; i++) c.m[i][i] = 1; while(k)&#123; if(k&amp;1) c = c * a; a = a * a; k &gt;&gt;= 1; &#125; return c;&#125;LL quick_pow(LL a,LL n)&#123; LL tmp = 1; while(n)&#123; if(n&amp;1) tmp = tmp * a % MOD; n &gt;&gt;= 1; a = a * a % MOD; &#125; return tmp;&#125;int main()&#123; freopen(\"in.txt\",\"r\",stdin); LL n,k; while(~scanf(\"%I64d%I64d\",&amp;n,&amp;k)) &#123; LL mx = 0; LL mxx = 0; LL sum = 0; for(int i = 0 ; i &lt;n;i++) &#123; scanf(\"%I64d\",&amp;a[i]); sum = (sum + a[i])%MOD; if(a[i]&gt;mx) &#123; mxx = mx; mx = a[i]; &#125; else if(a[i]&gt;mxx) mxx = a[i]; &#125; sort(a,a+n); mx = a[n-1]% MOD; mxx = a[n-2]% MOD; //cout&lt;&lt;mx&lt;&lt;\" \"&lt;&lt;mxx&lt;&lt;endl; //cout&lt;&lt;sum&lt;&lt;endl; Mat base = &#123;1,1,1,0&#125;; Mat mm = base ^ (k+2); LL c = mm.m[0][1]-1 % MOD; LL d = mm.m[0][0]-2 % MOD; // LL ans = (mx * d% MOD + mxx*c% MOD + sum% MOD)%MOD; //cout&lt;&lt;c&lt;&lt;\" \"&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;"},{"title":"hdu 4549 费马小定理 矩阵快速幂","permalink":"http://blog.jetmuffin.com/2015/02/04/hdu-4549-fermat-little-theorem/","text":"题目是斐波那契的变式，F[n]=F[n-1]*F[n-2]，F[0]=a，F[1]=b。 可以推出最后的ans = a^x * b^y，然后x和y都是斐波那契相邻的两项，x=f(n-1)，y=f(n)。 斐波那契和求幂都可以用快速幂搞定，中间数字特别大，快速幂过程容易溢出，然后WA+TLE了好几发，看了看discuss，群巨建议用费马小定理，查阅了一下，当a和p互质且p是质数时，a^(p-1)≡1，然后变式就是a^p=a^(p%Euler(MOD))%MOD，至于为什么，我之后还会再研究研究。。最近看数论比较有效率。 这样的话，就很容易可以推出 c = a^(f(n-1)%1000000006)%1000000007; d = b^(f(n)%1000000006)%1000000007; ans = c*d; 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define LL long longconst int N = 2;const long long MOD = 1000000007;struct Mat&#123; LL m[N][N];&#125;;Mat operator * (Mat a,Mat b)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i = 0 ; i &lt; N; i++) for(int j = 0 ; j &lt; N; j++) for(int k = 0 ; k &lt; N; k++) &#123; c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % (MOD-1); &#125; return c;&#125;Mat operator ^ (Mat a,LL k)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i = 0; i &lt; N; i++) c.m[i][i] = 1; while(k)&#123; if(k&amp;1) c = c * a; a = a * a; k &gt;&gt;= 1; &#125; return c;&#125;LL quick_pow(LL a,LL n)&#123; LL tmp = 1; while(n)&#123; if(n&amp;1) tmp = tmp * a % MOD; n &gt;&gt;= 1; a = a * a % MOD; &#125; return tmp;&#125;int main()&#123; freopen(\"in.txt\",\"r\",stdin); LL a,b,n; while(~scanf(\"%I64d%I64d%I64d\",&amp;a,&amp;b,&amp;n)) &#123; if(n==0) printf(\"%I64d\\n\",a); else if(n==1)printf(\"%I64d\\n\",b); else&#123; Mat base = &#123;1,1,1,0&#125;; base = base ^ (n-1); LL c = base.m[0][0]; LL d = base.m[0][1]; LL ans = (quick_pow(a,d) * quick_pow(b,c))%MOD; // cout&lt;&lt;c&lt;&lt;\" \"&lt;&lt;d&lt;&lt;endl; printf(\"%I64d\\n\",ans); &#125; &#125;&#125;"},{"title":"蓝桥杯校内选拔赛第6题题解 poj 2676","permalink":"http://blog.jetmuffin.com/2015/02/03/poj-2676-blue-bridge-cup-training/","text":"题目就是输入一个9*9的数独，然后解出数独的最终解。 大体思路还是搜索，dfs即可，写一个检查函数判断行、列、小方阵是否违规。 dfs的函数变量一开始考虑用x,y坐标进行处理，然后对于每个点，枚举1-9个数字中可用的数字，但是由于每次到一行的末尾需要换行到下一行比较麻烦，索性将二维数组一维化，仅使用一个变量k即可。 调试的时候出现各种错误，还是要细心的问题= = 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int m[9][9];char buffer[9]; bool check(int k,int v) &#123; int x = (k-1)/9; int y = k - x*9 -1; for(int i = 0 ;i &lt; 9; i++) //column if(m[i][y] == v) return 0; for(int j = 0 ;j &lt; 9; j++) //row if(m[x][j] == v) return 0; int a,b; //small square a = x/3*3; b = y/3*3; for(int i = a; i &lt; a+3; i++) for(int j = b; j &lt; b+3 ; j++) &#123; if(m[i][j] == v) return 0; &#125; return 1;&#125;bool dfs(int k) &#123; //cout&lt;&lt;k&lt;&lt;endl; if(k &gt; 81) &#123; for(int i = 0; i &lt; 9; i++) &#123; for(int j = 0 ; j &lt; 9; j++) cout&lt;&lt;m[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; return 1; &#125; int x = (k-1)/9; int y = k - x*9 -1; if(m[x][y] != 0) &#123; dfs(k+1); &#125; else &#123; int i; for(int i = 1; i &lt;= 9; i++) &#123; if(check(k,i)) &#123; // cout&lt;&lt;k&lt;&lt;\" \"&lt;&lt;i&lt;&lt;endl; m[x][y] = i; if(dfs(k+1)) return 1; m[x][y] = 0; &#125; &#125; &#125; return 0;&#125;int main() &#123; freopen(\"in.txt\",\"r\",stdin); int tmp; int cnt = 0; memset(c,0,sizeof(c)); memset(r,0,sizeof(r)); memset(m,0,sizeof(m)); for(int i = 0 ; i &lt;9; i++) &#123; cin&gt;&gt;buffer; for(int j = 0 ; j &lt; 9;j++) &#123; tmp = buffer[j] - '0'; m[i][j] = tmp; if(tmp) &#123; c[i][tmp-1]++; r[j][tmp-1]++; cnt++; &#125; &#125; &#125; dfs(1);&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435005300000800000020070010500400005300010070006003200080060500009004000030000009700145327698839654127672918543496185372218473956753296481367542819984761235521839764"},{"title":"蓝桥杯校内选拔第四题解题报告","permalink":"http://blog.jetmuffin.com/2015/02/03/blu-bridge-cup-4/","text":"题目： 今有7对数字：两个1，两个2，两个3，…两个7，把它们排成一行。 要求，两个1间有1个其它数字，两个2间有2个其它数字，以此类推，两个7之间有7个其它数字。如下就是一个符合要求的排列： 17126425374635 当然，如果把它倒过来，也是符合要求的。 请你找出另一种符合要求的排列法，并且这个排列法是以74开头的。 注意：只填写这个14位的整数，不能填写任何多余的内容，比如说明注释等。 思路： 题目是很简单的，去年蓝桥杯也有类似题目，当时不知道怎么写，现在会了= = 记录一下吧，思路就是纯搜索,dfs就OK了 代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int f[15];void dfs(int i,int v) &#123; if(v == 0) &#123; for(int k = 1 ; k &lt;= 14; k++ ) cout&lt;&lt;f[k]; cout&lt;&lt;endl; return; &#125; if(i &gt; 14) return; for(int i = 1 ; i+v+1&lt;=14 ;i++ ) &#123; if(f[i] == 0 &amp;&amp; f[i+v+1] == 0) &#123; f[i] = v; f[i+v+1] = v; dfs(i,v-1); f[i] = 0; f[i+v+1] = 0; &#125; &#125;&#125;int main() &#123; memset(f,0,sizeof(f)); dfs(1,7);&#125;"},{"title":"BestCoder #28 1002 Fibonacci hdu 5167 解题报告","permalink":"http://blog.jetmuffin.com/2015/02/03/bestcoder-28-1002-fibonacci-hdu-5167-solution/","text":"题目很简单，就是给出一个n，判断n能否由斐波那契数相乘得到，n范围为1e9。 先判断了一下，该范围大概有40来个数，先预处理保存这些数即可。 一开始的思路是对于每个数直接进行dfs，判断能否能够达到该n，但是写的太烂，加上case T的范围是1e5，结果TLE了。之后看了看别人代码的思路，找到了一种比较好的方法。 先预处理所有能达到的乘积，然后对于每次查询二分答案即可。测试了下，处理完所有范围的数，大概在80ms左右，看来还是不错的。 dfs的主体内容就是： 12345for i:= t to cnt val *= f[i];dfs(i,val); 其中t为当前搜索的index，val为当前乘积值，再加上一些限制条件就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define INF 1000000000#define LL long longLL f[100];int vis[100];int cnt;int flag;LL now = 1;LL n;vector&lt;LL&gt; v;vector&lt;LL&gt;::iterator it;void dfs(int t,LL val) &#123; //cout&lt;&lt;t&lt;&lt;\" \"&lt;&lt;val&lt;&lt;endl; v.push_back(val); if(t &gt;= cnt) return; for(int i = t; i &lt; cnt; i++) &#123; LL tmp = val * f[i]; if(tmp &gt; INF) break; dfs(i,tmp); &#125;&#125;void init() &#123; f[0] = 0; f[1] = 1; cnt = 2; for(int i = 2;f[i] &lt; 100;i++) &#123; f[i] = f[i-1] + f[i-2]; if(f[i] &gt; INF) break; cnt++; &#125; //cnt = 5; v.push_back(0); dfs(3,1); sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif init(); int T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; flag = 0; memset(vis,0,sizeof(vis)); it = lower_bound(v.begin(),v.end(),n); if( it!= v.end() &amp;&amp; *it== n) flag = 1; if(!flag) puts(\"No\"); else puts(\"Yes\"); &#125;&#125;"},{"title":"BestCoder #26 1002 Card  期望 解题报告","permalink":"http://blog.jetmuffin.com/2015/01/27/bestCoder-26-1002-card-expection-solution/","text":"题目的意思是，从x张牌里抽1张牌，然后放回重复b次，Sj为每次抽出牌的积分之和，问Sj的期望。 一开始看这个题目的时候考虑用组合做，因为b最大为5，所以考虑Sj由5个数-1个数组成的情况，然后算概率，但是题目的a和T的范围太大，O(Tlog(a))都会T估计，这明摆着是要O(T)的节奏啊。。也就是说，给定一个x，一个b，就有公式可以推出答案。 然后从另一个方向考虑，如果从组合考虑，即使给定几个数被抽到，还得考虑顺序情况，相当复杂，于是可以考虑对于每个数，其实只有2种状态（选中OR未选中），根据这两种状态去求期望会方便很多。 每次抽牌，选中某一张牌的概率为1/x； 抽b次牌结束后，某张牌被抽中概率为p = 1-(1-1/x)^b，（转化为相反的事件再转化回来）。 因此抽中某一张牌对期望的贡献为 i p ，因此总期望为 ∑(i=1~x) i p ，即EX = (x + 1)x (1-(1-1/x)^b)。 代码： 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int cnt = 0; int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; cnt++; double x; int b; scanf(\"%lf%d\",&amp;x,&amp;b); double p = 1.0; for(int i = 0; i &lt; b; i++) p *= (1 - 1/x); double ans = (1 - p) * (x + 1) * x / 2; printf(\"Case #%d: %.3f\\n\",cnt,ans); &#125; &#125;"},{"title":"Codeforces #285 C Misha and Forest 队列维护 解题报告","permalink":"http://blog.jetmuffin.com/2015/01/14/codeforces-285-C-Misha-and-Forest-solution/","text":"题目大意为一个森林，对于每个节点记录它的度数degree和与它连接的点的异或和Sv。现在给出每个点的degree和Sv，求这个图有多少条边，并写出每条边的顶点。 分析： 首先从异或和出发，加入x^y^z = a，那么左右都异或x的话，(x^x)^y^z = a^x，即y^z = a^x，同理z = a^x^y。 其次由于是森林，肯定有叶子节点，找出这些叶子节点，他们的degree均为1，且Sv为父节点的编号，每遍历一个叶子节点，将其父节点度数-1，Sv异或叶子节点编号，直到找到最后一个节点即可。 最后，需要用队列维护，不然会T。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; struct node&#123; int degree,s,i; int vis; void output()&#123; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;degree&lt;&lt;\" \"&lt;&lt;s&lt;&lt;endl; &#125; &#125;v[70000]; typedef pair&lt;int, int&gt; PII; vector&lt;PII&gt; edge; vector&lt;PII&gt;::iterator it; queue &lt;int&gt; q; int main() &#123; freopen(\"in.txt\",\"r\",stdin); int n; scanf(\"%d\",&amp;n); int cnt = 0; for(int i = 0 ; i &lt; n;i++) &#123; scanf(\"%d%d\",&amp;v[i].degree,&amp;v[i].s); if(v[i].degree == 1) q.push(i); &#125; while(!q.empty()) &#123; int i = q.front(); q.pop(); if(v[i].degree == 1) &#123; int fa = v[i].s; v[fa].s ^= i; v[fa].degree --; edge.push_back(make_pair(i,fa)); if(v[fa].degree == 1) q.push(fa); &#125; &#125; cout&lt;&lt;edge.size()&lt;&lt;endl; for(it = edge.begin();it!=edge.end();it++) &#123; PII pb = *it; cout&lt;&lt;pb.first&lt;&lt;\" \"&lt;&lt;pb.second&lt;&lt;endl; &#125; &#125;"},{"title":"CodeForces #285 B题Misha and Changing Handles解题报告","permalink":"http://blog.jetmuffin.com/2015/01/14/codeforces-285-B-Misha-and-Changing-Handles-solution/","text":"本题的意思是，给定多个改名的查询，每个查询包括一个新名字和旧名字，一个人可以多次更改，最终得到一个新名字，求这些查询中一共有多少个人，并且输出他最初的名字和最后的名字。(1&lt;=q&lt;=100） 1234567891011121314151617181920212223input5Misha ILoveCodeforcesVasya PetrovPetrov VasyaPetrov123ILoveCodeforces MikeMirzayanovPetya Ivanovoutput3Petya IvanovMisha MikeMirzayanovVasya VasyaPetrov123 考虑到q比较小，所以可以瞎搞。。直接对于每个节点设置sid和pid分别连接下一个名字和上一个名字，对于每一个查询，维护它的前驱和后继，最后便利一遍找到没有sid和没有pid的就是最初和最末的名字，最后根据循环找出每个初始名的结束名即可。 比的时候居然没注意到要用2*q存储，结果RE了，这点要注意。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; struct node&#123; string v; int pid; int sid; void output()&#123; cout&lt;&lt;v&lt;&lt;\" \"&lt;&lt;pid&lt;&lt;\" \"&lt;&lt;sid&lt;&lt;endl; &#125; &#125;f[1001]; int main() &#123; freopen(\"in.txt\",\"r\",stdin); int n; while(cin&gt;&gt;n) &#123; for(int i = 0; i &lt; n ; i++) &#123; f[i].pid = -1; f[i].sid = -1; &#125; int cnt = 0; int tmp; for(int i = 0 ;i &lt; n; i++) &#123; string a,b; cin&gt;&gt;a&gt;&gt;b; int j; for(j = 0;j &lt; cnt;j++) if(a==f[j].v) break; if(j==cnt) &#123; f[cnt].v = a; f[cnt].pid = -1; f[cnt].sid = cnt + 1; cnt++; f[cnt].v = b; f[cnt].pid = cnt-1; f[cnt].sid = -1; cnt++; &#125; else &#123; f[cnt].v = b; f[cnt].pid = j; f[j].sid = cnt; f[cnt].sid = -1; cnt++; &#125; &#125; // for(int i = 0 ; i &lt; cnt ;i++) // &#123; // f[i].output(); // &#125; int ans = 0; for(int i = 0 ; i &lt; cnt;i++) &#123; if(f[i].pid == -1) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 0 ; i &lt; cnt;i++) &#123; if(f[i].pid == -1) &#123; int si = f[i].sid; int pi ; while(si!=-1) &#123; pi = si; si = f[si].sid; &#125; cout&lt;&lt;f[i].v&lt;&lt;\" \"&lt;&lt;f[pi].v&lt;&lt;endl; &#125; &#125; &#125; &#125;"},{"title":"2014 Facebook Hacker Cup 资格赛 第二题 二进制模拟","permalink":"http://blog.jetmuffin.com/2015/01/14/2014-Facebook-Hacker-Cup-qualification-B/","text":"Facebook Hacker Cup资格赛的第二题，题目的意思问，给定的三个指标Ga,Gb,Gc，给定最多20种食物，能否任意组合刚刚好达到该指标。 范围不是很大，20的话怎么搞都行，于是敲了一个二进制模拟去枚举。。过了 思路类似容斥原理里的枚举因子，例如 i = 3 = ‘011’ 即选中第一个和第二个。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;ctime&gt; using namespace std; #define LL long long #define ULL unsigned long long //#define mod 1000000007 #define eps 1e-8 #define MP make_pair #define REP(i,a,b) for(int i = a; i &lt; b; ++i) #define RREP(i,a,b) for(int i = b; i &gt; a ; --i) #define RE freopen(\"in.txt\",\"r\",stdin) //#define WE freopen(\"out.txt\",\"w\",stdout) struct node &#123; int a,b,c; void output()&#123; cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl; &#125; &#125;; node g; node f[21]; int cnt = 0; int solve(int count)&#123; for(int i = 1; i &lt; (int)1&lt;&lt;count; i++)&#123; int a,b,c; a=b=c=0; for(int j = 0; j &lt; count; j++)&#123; if(i &amp; (1&lt;&lt;j))&#123; a += f[j].a; b += f[j].b; c += f[j].c; &#125; if(a==g.a&amp;&amp;b==g.b&amp;&amp;c==g.c) return 1; else if(a&gt;g.a||b&gt;g.b||c&gt;g.c) break; &#125; &#125; return 0; &#125; int main() &#123; freopen(\"in.txt\",\"r\",stdin); int T; cin&gt;&gt;T; while(T--) &#123; cnt++; int n; scanf(\"%d%d%d\",&amp;g.a,&amp;g.b,&amp;g.c); scanf(\"%d\",&amp;n); for(int i = 0 ; i &lt; n;i++) &#123; scanf(\"%d%d%d\",&amp;f[i].a,&amp;f[i].b,&amp;f[i].c); &#125; int flag = 0; flag = solve(n); if(flag) cout&lt;&lt;\"Case #\"&lt;&lt;cnt&lt;&lt;\": yes\"&lt;&lt;endl; else cout&lt;&lt;\"Case #\"&lt;&lt;cnt&lt;&lt;\": no\"&lt;&lt;endl; &#125; &#125;"},{"title":"hdu 5124 BestCoder #20 1002 lines 解题报告","permalink":"http://blog.jetmuffin.com/2014/11/30/hdu-5124-BestCoder-20-1002-lines-solution/","text":"这道题和以前做过的一道很像，然后哗啦哗啦就敲了提交了，然后pretest pass了 ，交了以后发现有问题，我的方法只是对一维数组进行标记然后扫描一遍，但是对于1e9的数据不仅爆数组又会T。想了一会儿怎么改进，最后还是卡这了。 赛后想了想，做一个简单的映射就行了，在原来的数组上相当于再加一层数组，对当前数组的index也就是上层数组的value进行标记扫描，就好过了。。。 将线段的x和y都放在一个数组v里，然后对2*n大小的v数组排序，然后对于每一个x，二分查找v数组的lower_bound，然后标记++，对于每一个y,二分查找v数组的lower_bound，然后标记–，最后扫描一遍OK了。。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int a[maxn],b[maxn];int f[maxn * 2];int v[maxn * 2];int main()&#123; freopen(\"in.txt\",\"r\",stdin); int T; cin&gt;&gt;T; while(T--) &#123; int n; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(f,0,sizeof(f)); memset(v,0,sizeof(v)); scanf(\"%d\",&amp;n); for(int i = 0 ; i &lt;n ; i++) &#123; scanf(\"%d%d\",&amp;a[i],&amp;b[i]); f[i] = a[i]; f[i+n] = b[i]; &#125; sort(f,f+n*2); for(int i = 0; i &lt; n ; i++) &#123; int aa = lower_bound(f, f+2*n,a[i])-f; int bb = lower_bound(f, f+2*n, b[i])-f; v[aa]++; v[bb+1]--; &#125; int tmp = 0,ans= 0; for(int i = 0 ; i &lt; n*2;i++) &#123; tmp += v[i]; ans = max(ans,tmp); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;"},{"title":"","permalink":"http://blog.jetmuffin.com/2014/11/28/hdu-5072-Coprime-2014-anshan-reigion-C/","text":"鞍山赛区比赛的时候这题没有任何思路，比赛结束后clj提到了单色三角，后来在做白书的训练指南时候看到了这点，然后就把这题写一写。 用到的几个知识点： 单色三角 平面中n个点没有三点共线，每两个点染白边或者染黑边，求单色三角形的数量。 事实上只要求非单色三角形，因为一个公共点的两条异色边总是唯一且对应一个非单色三角形，因此第i个点连接了a条白边，n-1-a条黑边，这些边属于a(n-1-a)个非单色三角形，因此答案是C(3,n)-sigma(ai(n-1-ai))。 容斥原理 这里用的容斥原理和hdu4135的题目相似。即求1-n中有多少个数与k互质。 求法就是将k分解质因数，然后对于其质因数的每一个组合，求多少个数可以被整除，最后用容斥原理相加可得不互质的数量，也就能得到答案了。 如n=20,k=30。质因数为2,3,5，所以依次求20/2,20/3,20/5,20/6,20/10,20/15,20/35，用到偶数个因数为减，奇数个加。 打素数表 这个就不用提了，作用是用来分解质因数。 提前处理 这一点比较重要，因为是要算这n个不同的数中与x互质的数。所以事先处理这些数中与（1-100000）中数不互质的数的个数。num[i]表示数列中，能被i整除的数的个数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;#include &lt;list&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;// #define LL __int64#define LL long long#define eps 1e-9#define PI acos(-1.0)using namespace std;const LL INF = 1&lt;&lt;30;const int maxn = 100010;int n;int prime[maxn];int factor[maxn][30];int num[maxn];int a[maxn];int cnt[maxn];void getPrime()&#123; memset(prime,0,sizeof(prime)); for(int i=2; i&lt;=maxn; i++) &#123; if(!prime[i]) prime[++prime[0]]=i; for(int j=1; j&lt;=prime[0]&amp;&amp;prime[j]&lt;=maxn/i; j++) &#123; prime[prime[j] * i] =1; if(i%prime[j] == 0) break; &#125; &#125;&#125;void getFactor(int val, int pos)&#123; int tmp = val; for(int i = 1; i &lt;= prime[0] &amp;&amp;prime[i]* prime[i] &lt;= tmp; i++) &#123; if(tmp % prime[i] == 0) &#123; factor[pos][cnt[pos]++] = prime[i]; while(tmp % prime[i] == 0) tmp /= prime[i]; &#125; if(tmp == 1) break; &#125; if(tmp &gt; 1) factor[pos][cnt[pos]++] = tmp; // cout&lt;&lt;val&lt;&lt;\": \"; // for(int i = 0;i&lt;cnt[pos];i++)&#123; // cout&lt;&lt;factor[pos][i]&lt;&lt;\" \"; // &#125; // cout&lt;&lt;endl;&#125;void init()&#123; for(int i =2; i&lt;100000; i++) for(int j= i+i;j &lt; 100000; j+=i) &#123; num[i] += num[j]; &#125;&#125;int main()&#123;// freopen(\"data2\",\"r\",stdin); getPrime(); int T; cin&gt;&gt;T; while(T--)&#123; memset(cnt,0,sizeof(cnt)); memset(num,0,sizeof(num)); int n; scanf(\"%d\",&amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\",&amp;a[i]); num[a[i]]++; &#125; init(); int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; getFactor(a[i],i); int ansNow = 0; for(int j = 1; j &lt; 1&lt;&lt;cnt[i]; j++) &#123; int flag = 0, tmp = 1; for(int k = 0; k &lt; cnt[i]; k++) &#123; if(j&amp;(1&lt;&lt;k)) &#123; flag ++; tmp *= factor[i][k]; &#125; &#125; if(flag &amp;1) ansNow += num[tmp] -1; else ansNow -= num[tmp] -1; &#125; ans += ansNow*(n-1-ansNow); &#125; ans = n*(n-1)*(n-2)/6-ans/2; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;"},{"title":"hdu 4135 Co-prime 容斥原理","permalink":"http://blog.jetmuffin.com/2014/11/28/hdu-4135-Co-prime/","text":"最近在看容斥原理的题目，这道题目是很典型的。 题目要求求[L,R]区间内与k互斥的数有多少个。 可以用容斥原理求[1,R]中与k互斥的个数，再减去[1,L-1]中与k互斥的个数。 容斥原求[1,n]中与k互斥的数的思路是：对于k，先分解质因数，放在prime[i]里，然后对于每个因数的各个组合，求[1,n]中能被其整除的个数，即n/prime[i]，然后不能直接相加。 比如说30的因数是2,3,5。求[1,20]中与30互斥的数，先要求20/2,20/3,20/5，然后求20/6,20/10,20/15，最后求20/30。 由2个因数组成的除数，要减，一个因数组成的，则加。 再讲怎么取到这每一个组合。用位运算表示最方便了。如i=3用011表示，就是要取prime[0]，prime[1]。 因此只要循环i := 1 -&gt; 2^cnt (因数个数) ，j := 0 -&gt; cnt -1 ，若 (1&lt;&lt;(j+1)) &amp; 1 不为0，则要取到该数。如i = 3,要取到prime[0]和prime[1]，1&lt;&lt;1 = “ 001”， 1&lt;&lt;2 = “010”，则符合。 最后说一下题目里的坑，因为a,b，n都是long long 范围，所以循环变量i需要也为long long ，且函数返回也为long long ，prime[]数组也是long long ，总之精度不能有错。 然后是long long 的问题，hdoj long long 用%lld居然会WA，然后卡了我好几次，最后改为%I64d过了。。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)//#define WE freopen(\"out.txt\",\"w\",stdout) const int maxn = 70;LL prime[maxn];LL a,b,n;int cnt;int t = 0;LL solve(LL num)&#123; LL ans = 0; for(LL i = 1; i &lt; (LL)1&lt;&lt;cnt; i++)&#123; LL flag = 0, tmp = 1; for(LL j = 0; j &lt; cnt; j++)&#123; if(i &amp; (1&lt;&lt;j))&#123; tmp *= prime[j]; flag ++; &#125; &#125; if(flag &amp; 1)&#123; ans += num/tmp; &#125; else&#123; ans -= num/tmp; &#125; &#125; return num - ans;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; t++; scanf(\"%I64d%I64d%I64d\",&amp;a,&amp;b,&amp;n); cnt = 0; for(LL i = 2; i*i &lt;= n;i++)&#123; if(n&amp;&amp;n%i == 0)&#123; prime[cnt++] = i; while(n&amp;&amp;n%i == 0)&#123; n /= i; &#125; &#125; &#125; if(n &gt; 1)&#123; prime[cnt++] = n; &#125; printf(\"Case #%d: %I64d\\n\",t,solve(b)-solve(a-1)); &#125; return 0; &#125;"},{"title":"Codeforces #279 A Team Olympiad 瞎搞","permalink":"http://blog.jetmuffin.com/2014/11/25/codeforces-279-A-Team-Olympiad/","text":"难得一场CF在下午5点打，果断参加，涨了100多分～ A题比较水，说的是n个学生，分别擅长体育，数学， 编程，要求把他们分成几组，每组里必须有会编程，会体育，会数学的各一人，求最多分多少组。 其实就是将三类学生分类，找到人数最少的一类，瞎搞搞就过了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=5001;int a[maxn];int b[maxn];int c[maxn];int n;int main()&#123; cin&gt;&gt;n; int ax = 0, bx = 0, cx = 0; for(int i = 0;i&lt;n;i++) &#123; int tmp; cin&gt;&gt;tmp; if(tmp == 1) &#123; a[ax++] = i; &#125; if(tmp == 2)&#123; b[bx++] = i; &#125; if(tmp == 3)&#123; c[cx++] = i; &#125; &#125; if(ax==0||bx==0||cx==0)&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int ans = 0; ans = min(ax,bx); ans = min(ans,cx); cout&lt;&lt;ans&lt;&lt;endl; for(int i = 0; i &lt; ans; i++) &#123; cout&lt;&lt;a[i]+1&lt;&lt;\" \"&lt;&lt;b[i]+1&lt;&lt;\" \"&lt;&lt;c[i]+1; cout&lt;&lt;endl; &#125;&#125;"},{"title":"hdu 5105 Math Problem BestCoder#18 1002 求最大值","permalink":"http://blog.jetmuffin.com/2014/11/19/hdu-5105-Math-Problem-BestCoder-18-1002-solution/","text":"f(x) = ax^3+bx^2+cx+d，最大&#20540;只会出现在几个地方：左端点，右端点，极&#20540;点。 求导后是个二次函数，可以求根，然后判断根是否在(L,R)范围内，若在范围内，直接求max(f(x),f(L),f(R))就是最大&#20540;了。 PS：要考虑a=0，b=0的情况，WA了一次ORZ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)//#define WE freopen(\"out.txt\",\"w\",stdout) const double INF = 99999;double a,b,c,d,L,R;double max(double a,double b)&#123; return a&gt;b?a:b;&#125;double fun(double x)&#123; return fabs(a*x*x*x+b*x*x+c*x+d);&#125;int main()&#123; while(~scanf(\"%lf %lf %lf %lf %lf %lf\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;L,&amp;R)) &#123; double ans; double left = fun(L); double right = fun(R); double sans = max(left,right); if(a==0) &#123; if(b == 0)&#123; ans = sans; &#125;else&#123; double x = -c/(2*b); if(x&lt;=R&amp;&amp;x&gt;=L) ans = fun(x); else ans = 0; ans = max(ans,sans); &#125; &#125; else&#123; double deta = 4*b*b - 12*a*c; if(deta &lt; 0)&#123; ans = 0; ans = max(ans,sans); &#125; else&#123; double x1 = (sqrt(deta)-2*b)/(6*a); double x2 = (-sqrt(deta)-2*b)/(6*a); double k1,k2; if(x1&lt;=R&amp;&amp;x1&gt;=L) k1 = fun(x1); else k1 = 0; if(x2&lt;=R&amp;&amp;x2&gt;=L) k2 = fun(x2); else k2 = 0; ans = max(k1,k2); ans = max(ans,sans); &#125; &#125; printf(\"%.2lf\\n\",ans); &#125;&#125;"},{"title":"HDU 5104 BestCoder #18 1001 Primes Problem 水题","permalink":"http://blog.jetmuffin.com/2014/11/19/hdu-5104-Primes-Problem/","text":"题意为对于每个n，求有多少种组合(a,b,c),a&lt;=b&lt;=c，a、b、c都是素数 事先打个1-10000的素数表，然后穷举a和b判断c是否为素数即可 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)//#define WE freopen(\"out.txt\",\"w\",stdout) const int maxn = 10000;int notprime[maxn+1];int prime[maxn+1];int cnt = 0; void init()&#123; memset(notprime,0,sizeof(prime)); notprime[0] = notprime[1] = true; for(int i = 2; i &lt; maxn; i++) &#123; if(!notprime[i]) &#123; if(i &gt; maxn / i) continue; for(int j = i * i; j &lt; maxn; j+=i) notprime[j] = 1; &#125; &#125; &#125; void getPrime()&#123; for(int i = 2; i &lt; maxn; i++) &#123; if(!notprime[i]) &#123; prime[cnt++] = i; &#125; &#125; &#125;int main()&#123; init(); getPrime(); int n; while(cin&gt;&gt;n) &#123; int ans = 0; for(int i = 0;prime[i] &lt;= n / 3;i++) for(int j = i ;n-prime[i]-prime[j]&gt;=prime[j];j++) &#123; int tmp = n - prime[i] - prime[j]; if(!notprime[tmp]) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;"},{"title":"nginx 配置图片缓存服务器，nginx.conf的配置","permalink":"http://blog.jetmuffin.com/2014/11/19/use-nginx-to-configurate-a-picture-cache-server/","text":"最近在搞云计算，弄了一个图片缓存服务器服务器，搭了一阵子，做个笔记。 教程转自Hermit_Macx，感谢作者，地址http://hermit-macx.iteye.com/blog/1697375 PS：proxy_cache_purge 需要另外下载包，不然报错，先注释了把 nginx.conf: user had;worker_processes 8; error_log /usr/local/nginx/nginx8011/logs/error.log crit; pid /usr/local/nginx/nginx8011/logs/nginx.pid; events { use epoll; worker_connections 65535;} http { include mime.types; default_type application/octet-stream; charset utf-8; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 300m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; client_body_buffer_size 512k; proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; #注：images_temp和images_cache指定的路径必须在同一分区 proxy_temp_path /usr/local/nginx/nginx8011/html/tmp; #设置Web缓存区名称为cache_one，内存缓存空间大小为200MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为30GB。 proxy_cache_path /usr/local/nginx/nginx8011/html/cache levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g; server { listen 80; server_name localhost; location / { proxy_cache cache_one; #对不同的HTTP状态码设置不同的缓存时间 proxy_cache_valid 200 304 12h; #以域名、URI、参数组合成Web缓存的Key值，Nginx根据Key值哈希，存储缓存内容到二级缓存目录内 proxy_cache_key $host$uri$is_args$args; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://localhost:8080; log_format cache &amp;#39;***$time_local &amp;#39; &amp;#39;***$upstream_cache_status &amp;#39; &amp;#39;***Cache-Control: $upstream_http_cache_control &amp;#39; &amp;#39;***Expires: $upstream_http_expires &amp;#39; &amp;#39;***&quot;$request&quot; ($status) &amp;#39; &amp;#39;***&quot;$http_user_agent&quot; &amp;#39;; access_log /usr/local/nginx/nginx8011/logs/cache.log cache; expires 1d; } #用于清除缓存，假设一个URL为http://localhost/test.txt，通过访问http://localhost/purge/test.txt就可以清除该URL的缓存。 location ~ /purge(/.*) { #设置只允许指定的IP或IP段才可以清除URL缓存。 allow 127.0.0.1; allow 192.168.0.0/16; deny all; #proxy_cache_purge cache_one $host$1$is_args$args; } #扩展名以.php、.jsp、.cgi结尾的动态应用程序不缓存。 location ~ .*\\.(php|jsp|cgi)?$ { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://localhost:8080; } access_log off; } server{ listen 8080; server_name localhost; location / { root html; index index.html index.htm; } access_log off; } }"},{"title":"Hadoop java api ，HDFS文件操作，便于Web开发的集合","permalink":"http://blog.jetmuffin.com/2014/11/06/hadoop-java-api-hdfs/","text":"最近在搞一个云计算比赛，要开发HDFS存储云，根据一个博客给的API写了一个完整的JAVA文件集成所有的HDFS文件操作，后期用JSP开发时只要导入这个包就OK了。 感谢原作者：http://www.cnblogs.com/xuqiang/archive/2011/06/03/2042526.html 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.net.URI;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.BlockLocation;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;public class HadoopFileUtil &#123;/** * HDFS文件访问API * @author Jet-Muffin */ public static String hdfsUrl = \"hdfs://localhost:9000\"; /** * create HDFS folder 创建一个文件夹 * @param dirPath * @return */ public static void createDir(String dirPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(dirPath); hdfs.mkdirs(path); hdfs.close(); &#125; /** * delete HDFS folder 删除一个文件夹 * @param dirPath * @return */ public static void deleteDir(String dirPath) throws Exception&#123; Configuration conf = new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); hdfs.delete(new Path(dirPath)); hdfs.close(); &#125; /** * create a file 创建一个文件 * @param filePath * @return */ public static void createFile(String filePath,String content) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(filePath); FSDataOutputStream out = hdfs.create(path); out.write(content.getBytes()); out.close(); hdfs.close(); &#125; /** * rename a file 重命名一个文件 * @param oldPath * @param newPath * @return */ public static void renameFile(String oldPath,String newPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(oldPath); Path nPath = new Path(newPath); hdfs.close(); System.out.println(hdfs.rename(path, nPath)); &#125; /** * delete a file 删除一个文件 * @param hadoopFile * @return isDeleted */ public static boolean deleteFile(String hadoopFile) throws Exception&#123; Configuration conf=new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(hadoopFile); boolean isDeleted = hdfs.delete(path); hdfs.close(); return isDeleted; &#125; /** * upload a local file 上传文件 * @param localPath * @param hadoopPath * @return */ public static void uploadLocalFile(String localPath,String hadoopPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path src = new Path(localPath); Path dst = new Path(hadoopPath); hdfs.copyFromLocalFile(src, dst); hdfs.close(); &#125; /** * 读取文件于字节缓冲数组 * @param hadoopFile * @return buffer */ public static byte[] readFile(String hadoopFile) throws Exception &#123; Configuration conf = new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(hadoopFile); if ( hdfs.exists(path) ) &#123; FSDataInputStream in = hdfs.open(path); FileStatus stat = hdfs.getFileStatus(path); byte[] buffer = new byte[Integer.parseInt(String.valueOf(stat.getLen()))]; in.readFully(0, buffer); in.close(); hdfs.close(); return buffer; &#125; else &#123; throw new Exception(\"the file is not found .\"); &#125; &#125; /** * list files under folder 列出文件夹中所有文件 * @param hadoopPath * @return fileString */ public static String listFiles(String hadoopPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path dst = new Path(\"/test\"); FileStatus[] files = hdfs.listStatus(dst); String fileString = \"\"; for(FileStatus file: files)&#123; System.out.println(file.getPath().toString()); fileString += file.getPath().toString() + \" \"; &#125; hdfs.close(); return fileString; &#125; /** * list block info of file 查找文件所在的数据块 * @param hadoopPath * @return blockString */ public static String getBlockInfo(String hadoopPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path dst = new Path(hadoopPath); FileStatus fileStatus = hdfs.getFileStatus(dst); BlockLocation[] blkloc=hdfs.getFileBlockLocations(fileStatus,0,fileStatus.getLen()); //查找文件所在数据块 String blockString = \"\"; for(BlockLocation loc: blkloc)&#123; for(int i=0;i &lt; loc.getHosts().length;i++) System.out.println(loc.getHosts()[i]); // blockString += loc.getHosts()[i] + \" \"; &#125; hdfs.close(); return blockString; &#125; public static void main(String[] args) throws Exception &#123; //createDir(\"/test2\"); //deleteDir(\"/test2\"); //createFile(\"/test/helloworld.txt\"); //renameFile(\"/test/a.txt\",\"/test/b.txt\"); //uploadLocalFile(\"/home/had/in\",\"/test\"); //listFiles(\"/test\"); //getBlockInfo(\"/test/b.txt\"); //deleteFile(\"/test/hellwo.txt\"); /* byte[] buffer = readFile(\"/test/in\"); String out = new String(buffer); System.out.println(out); */ &#125; &#125;"},{"title":"最短加法链问题，POJ2248，BFS，搜索","permalink":"http://blog.jetmuffin.com/2014/10/30/poj-2248-shortest-addition-chain/","text":"该题也是算法导论的结课作业，看了一下貌似在POJ上有原题。 宽搜BFS，因为要找到的是最短的加法链，宽搜是最快速的方法。算法的设计上，因为需要保存路径，所以用结构体node（intid,int val, int pre)，保存每个节点，根据pre和id`的映射关系使得路径成为链式，再宽搜路径即可 核心代码代码： 123456789101112131415161718192021222324252627void bfs() &#123; q.push(node(0,1,-1)); path[cnt++] = node(0,1,-1); node now,next; while(!q.empty()) &#123; now = q.front(); q.pop(); //now.print(); for(int i = now.id; i!=-1; i = path[i].pre) &#123; int tmp = now.val + path[i].val; if(tmp == n) &#123; cout&lt;&lt;countPath(now.id)&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;\" \"; output(now.id); cout&lt;&lt;endl; return; &#125; if(tmp &lt; n) &#123; next = node(cnt, tmp, now.id); path[cnt++] = next; q.push(next); &#125; &#125; &#125;&#125;"},{"title":"最少费用购物问题，裸DP，动态规划","permalink":"http://blog.jetmuffin.com/2014/10/30/least-cost-shopping-dp/","text":"算法导论结课题目。 题目很长，大义是给出每个商品的编码和费用，再给出某些商品的组合价，求买了所需商品的最少费用。 样例输入： 2 7 3 2 8 2 5 2 1 7 3 5 2 7 1 8 2 10 样例输出： 14 样例解释： 第一行2代表有2个商品，之后两行中，第一个数字是商品编码，第二个数字是商品所需购买数量，第三个数字是商品单价。 第二行2代表优惠组合数，第一个数字代表有多少商品的组合，之后每一对数字代表组合的商品的编码和数量，该行最后一个数字代表优惠组合优惠价格。 题目看起来很复杂，读起来更复杂- -。 第一眼看上去很像背包，刚开始试着用多重背包的思想去做，发现二维完全解决不了（因为需要各个商品的数量作为状态）。仔细看发现商品数量最大为5，果断使用普通的裸DP，不过维数较多，有5维，也就意味着有至少5个for循环，蛋疼至极。打算试试状态压缩，发现不好办，最后还是老老实实编码了。 注意点：优惠商品数量不能大于需求数量，同时注意商品编码和输入的i、j的关系要处理好。 PS：写完后雪林哥给了一组数据，我的程序跪了，发现就是商品编码没处理好，ORZ～ 分享该数据： 输入： 5 1 1 2 2 1 3 3 1 4 4 1 5 5 1 6 6 1 2 1 3 2 1 1 2 1 5 5 1 1 2 1 3 1 4 1 5 1 3 3 1 1 3 1 4 1 1 2 2 1 5 1 1 1 1 1 3 输出：2 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;time.h&gt; using namespace std; int sale[1000][6] = &#123;0&#125;; //分别表示每个优惠中每个商品数量 int saleprice[1000] = &#123;0&#125;; //优惠总价 int salelength[1000] = &#123;0&#125;; //优惠总共有几个商品 int salenumber[1000][1000] = &#123;0&#125;; //优惠商品的ID int good[6][4] = &#123;0&#125;; //1 -&gt; number 2 -&gt; price 3 -&gt; last num int num[1000]; //商品ID int dp[6][6][6][6][6]; int n,m; void input() &#123; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;good[i][1]&gt;&gt;good[i][3]&gt;&gt;good[i][2]; num[i] = good[i][1]; &#125; cin&gt;&gt;m; for(int i = 1; i &lt;= m; i++) &#123; cin&gt;&gt;salelength[i]; for(int j = 1; j &lt;= salelength[i]; j++) &#123; cin&gt;&gt;salenumber[i][j]; cin&gt;&gt;sale[i][salenumber[i][j]]; &#125; cin&gt;&gt;saleprice[i]; &#125; &#125; void output() &#123; for(int i = 1; i &lt;= n; i++) cout&lt;&lt;\"goodnum: \"&lt;&lt;good[i][1]&lt;&lt;\" goodprice: \"&lt;&lt;good[i][2]&lt;&lt;\" goodlast: \"&lt;&lt;good[i][3]&lt;&lt;endl; for(int i = 1; i &lt;= m; i++) &#123; //cout&lt;&lt;salelength[i]&lt;&lt;endl; cout&lt;&lt;\"sale\"&lt;&lt;i&lt;&lt;\" : \"; for(int j = 1; j &lt;= salelength[i]; j++) cout&lt;&lt;\"num: \"&lt;&lt;salenumber[i][j]&lt;&lt;\" count: \"&lt;&lt;sale[i][salenumber[i][j]]&lt;&lt;\" \"; cout&lt;&lt;endl; cout&lt;&lt;\" price: \"&lt;&lt;saleprice[i]&lt;&lt;endl; &#125; &#125; int main() &#123; //freopen(\"in2\",\"r\",stdin); input(); // output(); dp[0][0][0][0][0] = 0; for(int i = 0; i &lt;= good[1][3]; i++) for(int j= 0; j &lt;= good[2][3]; j++) for(int k = 0; k &lt;= good[3][3] ;k++) for(int l = 0; l &lt;= good[4][3]; l++) for(int p = 0; p &lt;= good[5][3]; p++) &#123; int minx = i * good[1][2] + j * good[2][2] + k * good[3][2] + l * good[4][2] + p * good[5][2]; for(int q = 1; q &lt;= m; q++) &#123; if(i -sale[q][num[1]]&lt;0 || i - sale[q][num[2]]&lt;0 || i-sale[q][num[3]]&lt;0 || i-sale[q][num[4]]&lt;0 ||i-sale[q][num[5]]&lt;0) continue; int t = dp[i - sale[q][num[1]]][j - sale[q][num[2]]][k - sale[q][num[3]]][l - sale[q][num[4]]][p - sale[q][num[5]]] + saleprice[q]; if(t &lt; minx) minx = t; &#125; dp[i][j][k][l][p] = minx; &#125; cout&lt;&lt;dp[good[1][3]][good[2][3]][good[3][3]][good[4][3]][good[5][3]]&lt;&lt;endl; return 0; &#125;"},{"title":"2014 ACM-ICPC 亚洲地区赛 西安站小结","permalink":"http://blog.jetmuffin.com/2014/10/28/2014-ACM-ICPC-xian-region-conclusion/","text":"弱菜第二次参加地区赛，继续流水帐记录下。 西安赛区举办很隆重，西工大校园也是够大，只是长安校区太远，从火车站打的到友谊校区再坐公交到长安校区花了2个多小时ORZ～本来以为赶不上热身赛，结果热身赛是15：30开始，时间很够。 热身赛1个小时半，4道题。3分钟就看到有人出了D，仔细看是map计数，统计单词出现次数，大小写不区分，输出为大写。以前做过这种题，当时死活想不起怎么用STL里的MAP，无奈先让老范和纪存写其他题先。老范写的C，多边形的面积和周长计算，几何模板套用，打完代码发现有点小问题，接着思考去了。纪存写的A的模拟，是要写一个类&#20284;JAVA中的String to (Integer、Double、String)的模拟，目测坑多，写到一半纪存又思考去了。这时我才有点想起如何用MAP，立即code，打完测试，提交1Y 。交完老范也想到哪儿出问题了，改完提交C，1Y。之后时间不是很多了，我们继续思考A，后来发现A一个队伍都没过，还是果断放弃了。热身赛结束2题排在120左右，铜牌区，还行～ 其间先吐槽下住宿问题，本来以为住宿很高大上，后来发现房间差的很，插座除了电视外只有厕所一个，全部灯只有一个壁灯好的，床单枕头发黄恶心，电视小的可怜。不过除了住宿外，西工大其他都安排的很好～ 第二天正赛，上来我先看的F，纪存K，老范D。几分钟后刷榜有人过了A，开始看A。A题干长的让人想吐，具体是讲的老罗的锤子手机和他的情怀，以及锤子官网访问次数始终是3的倍数的问题被人发现等等等等。最后要求一个“情怀数列”，全文就一句话讲了这东西，就是所有数都是3的倍数。刚要打代码老范提醒hint里提示到数字过小不是情怀什么的，仔细一看貌&#20284;是这样。但是再往下看居然看到一句话，说本题的陈述和提示，全部都是joke，不要太在意- -，实在给跪ORZ～提交1Y，看了下排名110+。 回来再次看K，K大概讲的是一个无限数列，S1=A，S2=B，此后每个数都是前两个数做差取绝对&#20540;。最后会发现数会循环在某两个数。我简单的打了个代码测试停止的数，发现最后停的都是两个数的最大公约数。这时老范想到了方法，将类别分为A%B==0以及A%B！=0两种，算法类&#20284;gcd，大体是这样的： 123456while(x%y!=0) &#123; ans += x / y; int z = x % y; x = y; y = z;&#125; 最后这种类别的会转化为A%B==0的，ans再加上A/B+1就OK了。要提的一点是题干上貌&#20284;没说A&gt;B，所以要先交换下。 写完提交，发现WA，当时就慌了，忽然发现当A=0或B=0时会出现/0的RE，修改后提交依然WA。这才发现前两次提交交到A题上了ORZ，不过A题已经AC，不算次数，再次提交K的时候1Y，真是运气好。。查看一下排名60左右，很有希望。 之后看的F，是个染色问题，纪存写了一个DP，发现时间复杂度过大，空间复杂度也过大。后来又写了个压缩路径，空间复杂度能过，但是依然会TLE。之后我拿纪存的程序检验n m k的数字关系，最后写出一条地推公式，然后写了一个用矩阵加速的矩阵快速幂加打表阶乘，可以用o(log(k)log(n))，但是空间复杂度是o(kk)，最后他们一致认为会爆，就没实现了。 我们再次转移 到老范看的I，是个模拟IP的问题，a.b.c.d/e，e是子网掩码。题目给出了部分IP，相当于一些IP区域段，需要我们求这些区域段相对全网的补。我们始终无法搞定算法，最后没办法也放弃了。 直到结束都没出第三题。。封榜前是排在107,最后出的结果排在130，拿到了铜牌，还不错，哈哈～"},{"title":"extjs 解决rowEditing不满足allowBlank时，无法save的问题","permalink":"http://blog.jetmuffin.com/2014/10/22/solution-to-cannot-save-on-row-editing/","text":"最近一个项目使用了extjs，在用rowEditing的时候遇到了棘手的问题，当某一column的editor使用了属性allowBlank:true时，启用编辑时会报错（“该行不能为空”），这时save按钮是灰色的无法提交。然而填了该行，save仍然无法提交。 经过google之后发现这是个bug，最好的解决方法就是重写rowEditing~ORZ JS如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687Ext.override(Ext.grid.RowEditor, &#123; addFieldsForColumn: function(column, initial) &#123; var me = this, i, length, field; if (Ext.isArray(column)) &#123; for (i = 0, length = column.length; i &lt; length; i++) &#123; me.addFieldsForColumn(column[i], initial); &#125; return; &#125; if (column.getEditor) &#123; field = column.getEditor(null, &#123; xtype: &amp;#39;displayfield&amp;#39;, getModelData: function() &#123; return null; &#125; &#125;); if (column.align === &amp;#39;right&amp;#39;) &#123; field.fieldStyle = &amp;#39;text-align:right&amp;#39;; &#125; if (column.xtype === &amp;#39;actioncolumn&amp;#39;) &#123; field.fieldCls += &amp;#39; &amp;#39; + Ext.baseCSSPrefix + &amp;#39;form-action-col-field&amp;#39;; &#125; if (me.isVisible() &amp;&amp; me.context) &#123; if (field.is(&amp;#39;displayfield&amp;#39;)) &#123; me.renderColumnData(field, me.context.record, column); &#125; else &#123; field.suspendEvents(); field.setValue(me.context.record.get(column.dataIndex)); field.resumeEvents(); &#125; &#125; if (column.hidden) &#123; me.onColumnHide(column); &#125; else if (column.rendered &amp;&amp; !initial) &#123; me.onColumnShow(column); &#125; // -- start edit me.mon(field, &amp;#39;change&amp;#39;, me.onFieldChange, me); // -- end edit &#125; &#125;&#125;);//重写RowEditor 如果大家有遇到该问题的，只要在js文件里添加该段代码即可～"},{"title":"stl set和map应用记录","permalink":"http://blog.jetmuffin.com/2014/10/22/usage-of-set-and-map-in-stl/","text":"无聊水题，发现map容器使用的一块儿知识欠缺，就是很水的用map进行计数，赶紧补上。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;int,int&gt; s; int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; s.clear(); while(n--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); s[x]++; &#125; map&lt;int,int&gt;::iterator i; for(i=s.begin();i!=s.end();i++) &#123; cout&lt;&lt;i-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;i-&gt;second&lt;&lt;endl; &#125; &#125; return 0;&#125;"},{"title":"2014ACM-ICPC 地区赛鞍山站小结","permalink":"http://blog.jetmuffin.com/2014/10/21/2014-ACM-ICPC-anshan-region-conclusion/","text":"第一次参加ACM地区赛，感受挺深，以下用流水帐的形式记录一下这次的经历。 从出发开始说起，学校给定的火车票，从南京到鞍山，23小时车程，早上5点从学校出发，也是不容易，上车后发现南航的就在隔壁，压力甚大。报道时没有教练在，都由我们自己处理，有一点印象比较深，当志愿者问我们来自什么学校时，回答“河海大学”让边上天津大学的教练惊讶了一番，不知是学校太不出名还是太弱的原因。。感慨ORZ。主办方辽宁科技大学很周到，一个队伍配了一个志愿者，从开始引导到结束，这点很好～XD。 第一天下午参加了热身赛，4道题目。一开始场地的交换机出问题了，不能交题不能看scoreboard，而且problem set三人只能有一份，我们只好每人一张开始切题。我开始看的是A题（不记得了），是要计算一个长度最大为28的全排列中符合条件（即任意一个数与前后两个数都互质）。出于范围比较小，全排列范围是28！，我想了一个搜索+剪枝方法，开始打代码，纪存和范仕良在看其他题。码完题测试下速度，发现当数据到达13的规模时时间超过1秒，果断放弃。这时候切出去看了一下scoreboard，发现好多人做出了D（不记得了），然后范仕良和我交流了一下思路，觉得可行，我花了2分钟打完代码，交了，1Y。随后看其他题，一道概率DP，实在太难找出递推公式，无奈放弃。时间过了2小时时看了一下scoreboad发现AC2道的队伍不超过10支，然后我们就开始很随意聊天了XD～比赛结束看了一下排名，97,铜牌最后一名，还是很不错的～ 吃完晚饭，闲着无聊我们队3人跑到附近的网吧休闲一番～发现有队伍居然在网吧打BC。。给大神跪了OTZ～ 第二天早上正赛，赛前有点紧张，比赛时发现更紧张。开始时我切的是C，纪存看I，范仕良看的K（不记得了）。3分钟左右看一下排名，I有人出了，立马转战I，了解题意后还是由我主打代码，打完后稍微检查一番决定交，结果WA，当时就蒙了，再次审查一遍，认为是sqrt中double的问题，修改再交，依然WA。当时真是整个情绪有点崩溃，毕竟这只是道签到题。再次审查，把该改的地方再完善，依然WA。最后发现错误错在一个平时都不注意的地方。大概是： double dis = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) 其中x1,x2,y1,y2都是1e5的范围，当时我们一直觉得这样赋&#20540;，计算后的结果范围1e10肯定不会超double，但是居然是这儿出错了，原因是该语句先计算结果后转换精度，而结果爆int了。修改后AC，这时候看一下排行，120+，有些崩溃。 转战E题，我认为这题只要弄清楚各个情况即可，于是我开始打代码，写完发现测试数据都过不了。这时范仕良已经整理思路，换他来写了一个DP，1Y。 这时我们看了下排行，110+，而3题的大概只有30队。迅速看完D题，讨论，想出思路时大概50支队伍3题，赛后发现如果这时候1Y很有希望拿铜。 E题题意大概是有n个点，去掉k个点使得剩下的点方差最小。 一开始范仕良的思路是：最后得到的一定是个连续的区间，所以枚举各个长度为n-k的区间即可，但是被我和纪存否定了，原因是我们认为对于每次枚举要重新计算方差，整体复杂度为o(n*k)，会超时。之后纪存想出了一个方法，每次删去离重心最远的点，更新重心，复杂度o(n)，讨论后我们都觉得此方法可行，由我打代码，打完交后WA，再次找错误，改精度，依然WA，最后卡题到结束。没能拿到牌都挺郁闷。 返程的火车上和南理工的同学讨论了下，他们指出了错误。当一堆数据中有一部分密集无效数据和有效数据距离太远时，我们的算法结果是删后的数据重心在有效和无效数据之间，而正确的结果应该是删除无效的数据。之后我随机生成数据进行测试，发现错误所在。 以下为我们的错误代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;double p[50005];using namespace std;int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; memset(p,0,sizeof(p)); int n,k; cin&gt;&gt;n&gt;&gt;k; double sum = 0; for(int i = 1;i&lt;=n;i++) &#123; cin&gt;&gt;p[i]; sum+= p[i]; &#125; sort(p+1,p+n+1); double avp = sum/(double)n; int fst = 1; int lst = n; for(int i = 0;i &lt; k; i++) &#123; double fstv = avp - p[fst]; double lstv = p[lst] - avp; cout &lt;&lt; p[fst]&lt;&lt;\" : \"&lt;&lt;fstv &lt;&lt; \" \"&lt;&lt;p[lst]&lt;&lt;\" : \"&lt;&lt;lstv&lt;&lt;endl; if(fstv &gt; lstv) &#123; sum -= p[fst]; fst ++; avp = sum/(double)(n-i-1); &#125;else&#123; sum -= p[lst]; lst --; avp = sum/(double)(n-i-1); &#125; &#125; double ans = 0; for(int i=fst;i&lt;=lst;i++) &#123; cout&lt;&lt;p[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(int i=fst;i&lt;=lst;i++) &#123; ans += (p[i] - avp)*(p[i] - avp); &#125; printf(\"%.10f\\n\",ans); &#125; return 0;&#125; 当该算法碰到如下数据时： 1 13 4 1 1 1 1 5 6 7 8 9 10 11 12 13 会将10 11 12 13删除得道错误答案90 而正确答案则是删去4个1得到60. 再次思考原范仕良的思路是对的，只要事先处理一下方差公式: (xi - x平均)^2 = xi^2 + x平均^2 - 2xix平均 所以方差 = ∑xi^2 + nx平均 - 2∑xi*x平均 事先计算∑xi^2和∑xi，便可以以o(n)扫一遍得出结果。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; double p[50005]; using namespace std; int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; memset(p,0,sizeof(p)); int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i = 1;i&lt;=n;i++) cin&gt;&gt;p[i]; if(n==k) &#123; printf(\"%.9f\\n\",0); continue; &#125; sort(p+1,p+n+1); double sum = 0; double sqrsum = 0; for(int i = 1;i&lt;=n-k;i++) &#123; sum += p[i]; sqrsum += p[i] * p[i]; &#125; double avg = sum/(double) (n-k); double min = sqrsum + (n-k)*avg*avg - 2*sum*avg; // cout&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;sqrsum&lt;&lt;\" \"&lt;&lt;avg&lt;&lt;\" \"&lt;&lt;min&lt;&lt;endl; int flag = 0; for(int i = 1 ;i &lt;= k; i++) &#123; sum = sum + p[n-k+i] - p[i]; sqrsum = sqrsum + p[n-k+i]*p[n-k+i] - p[i]*p[i]; avg = sum/(double) (n-k); double now = sqrsum + (n-k)*avg*avg - 2*sum*avg; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;sqrsum&lt;&lt;\" \"&lt;&lt;avg&lt;&lt;\" \"&lt;&lt;min&lt;&lt;endl; if(now &lt; min) &#123; min = now; flag = i; &#125; &#125; printf(\"%.10f\\n\",min); &#125; &#125; 鞍山赛区失利，不过没有关系，西安争取拿牌～ 最后感谢一下比赛期间一直引导我们的志愿者粘微微（姓很奇怪XD～） 文章流水帐，无所谓啦～"},{"title":"hdu 2080 夹角有多大II","permalink":"http://blog.jetmuffin.com/2014/10/15/hdu-2080-how-large-is-the-include-angle-II/","text":"这是一题水题，至于为什么放在这儿。。因为要借鉴一下做法。。 地区赛的时候一道题之中要用到该题的结论，当时的做法是算(x轴-该点与原点连线)，再求其arctan算出角度，取两个角度求差。 这种做法的弊端就是，如果角度大于90度，大于180度，大于270度，得做相应处理，同时如果某点在坐标轴上也得处理，非常的繁琐。 今天做到这道水题才发现问题所在，原来直接用余弦定理一步搞定，cosA = (a^2 + b^2 - c^2)/(2ab)，同时也不用处理180度的问题。以后就不会犯这种错了。 需要提的一点是，x,y都是double，没发现这点用int，WA了数次。。不够细心 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)#define WE freopen(\"out.txt\",\"w\",stdout) #define PI 3.141592654int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; double x1,x2,y1,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; double a=(double)sqrt((double)(x1*x1+y1*y1)); double b=(double)sqrt((double)(x2*x2+y2*y2)); double c=(double)sqrt((double)((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))); double arc=acos((a*a+b*b-c*c)/(2*a*b)); arc=arc*180/PI; printf(\"%.2f\\n\",arc); &#125;&#125;"},{"title":"hdu 3076 ssworld VS DDD 概率dp","permalink":"http://blog.jetmuffin.com/2014/10/14/hdu-3076-ssworld-VS-DDD/","text":"题意应该很明显，甩骰子决定谁扣血，输的扣血，赢的不变，平局双方都不变。 解题时有好几个地方想错了： 原本以为dp[i][j]表示当前A和B的血量，结果想反了，整个思路貌似有点偏 以为平局的概率也要加入，事实上也是错误1引起的，修改为dp[i][j]表示A和B赢的次数就好理解了，简化问题，去掉平局，p1 = win/(win+lose) ; p2 = lose/(win+lose) 最后的答案不是dp数组中的一个，而是A赢了hp2次的概率，就是dp[hp2-1][j(j从0到hp1-1求和)]*win 解决了这几个问题，结果提交还是WA，后来看了discuss才发现数据错了，两人血量反了，所以把其中的i和j互换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;ctime&gt; using namespace std; #define LL long long #define ULL unsigned long long //#define mod 1000000007 #define eps 1e-8 #define MP make_pair #define REP(i,a,b) for(int i = a; i &lt; b; ++i) #define RREP(i,a,b) for(int i = b; i &gt; a ; --i) #define RE freopen(\"in.txt\",\"r\",stdin) #define WE freopen(\"out.txt\",\"w\",stdout) #define N 2001 double a[7],b[7]; double dp[N][N]; //dp[i][j]表示A赢了i局，B赢了j局，最后求A赢了hp2局的概率 int main() &#123; RE; int hp1,hp2; while(cin&gt;&gt;hp1&gt;&gt;hp2) &#123; memset(dp,0,sizeof(dp)); double win,lose,draw; win = lose = draw = 0; for(int i=1;i&lt;=6;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=6;i++) cin&gt;&gt;b[i]; for(int i=2;i&lt;=6;i++) for(int j=1;j&lt;i;j++) win += a[i]*b[j]; for(int i=1;i&lt;=5;i++) for(int j=i+1;j&lt;=6;j++) lose += a[i]*b[j]; draw = 1-win-lose; double win_p = (win)/(1-draw); double lose_p = lose/(1-draw); dp[0][0] = 1; for(int j=0;j&lt;=hp1-1;j++) for(int i=0;i&lt;=hp2;i++) &#123; if(i+j&gt;0) &#123; if(i&gt;0) dp[i][j] += dp[i-1][j]*lose_p; if(j&gt;0) dp[i][j] += dp[i][j-1]*win_p; &#125; &#125; //cout&lt;&lt;dp[hp2-1][hp1-1]&lt;&lt;endl; double ans = 0; for(int i=0;i&lt;=hp2-1;i++) ans += dp[i][hp1-1] * win_p; if(ans&gt;1) ans=1; printf(\"%.6f\\n\",ans); &#125; &#125;"},{"title":"CodeForces 148D Bags of mice 概率dp","permalink":"http://blog.jetmuffin.com/2014/10/14/codeforces-148D-Bags-of-mice-probability-dp/","text":"开始看概率dp的内容，碰到算期望的题目，一般就要用概率dp了。这是道入门的概率dp，弄清楚每一步发生的事件和对应的概率，求出递推公式就OK了。123dp[i][j][0]表示轮到公主取，还剩下i只白鼠，j只黑鼠；dp[i][j][1]表示轮到龙取，还剩下i只白鼠，j只黑鼠； 获胜的期望就是dp[w][b][0]。1234567dp[i][j][0] = p1 //公主抽到的是白鼠概率p1，结束dp[i][j][0] += dp[i][j-1][1] * p2 //公主抽到的是黑鼠概率p2dp[i][j][1] += dp[i-1][j-1][0] * p3 // 龙抽到的是黑鼠，吓跑一只白鼠概率p3dp[i][j][1] += dp[i][j-2][0] * p4 //龙抽到黑鼠，吓跑一只黑鼠概率p4 再依次算概率 就OK了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)#define WE freopen(\"out.txt\",\"w\",stdout) #define N 1005double dp[N][N][2]; int main()&#123; int w,b; cin&gt;&gt;w&gt;&gt;b; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;=w;i++) for(int j=0;j&lt;=b;j++) &#123; if(i&gt;0) dp[i][j][0] = i/(double)(i+j); if(j&gt;0) dp[i][j][0] += j/(double)(i+j) * dp[i][j-1][1] ; if(i&gt;=1&amp;&amp;j&gt;=1) dp[i][j][1] += j/(double)(i+j) *i/(double)(i+j-1) * dp[i-1][j-1][0] ; if(j&gt;=2) dp[i][j][1] += j/(double)(i+j) * (j-1)/(double)(i+j-1) * dp[i][j-2][0] ; &#125; printf(\"%.9lf\\n\",dp[w][b][0]);&#125;"},{"title":"hdu 2098 分拆素数和 水题","permalink":"http://blog.jetmuffin.com/2014/10/12/hdu-2098-solution/","text":"偶尔一水，打个素数表，再正向打ans表。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt; #include&lt;math.h&gt; #define N 1231 using namespace std; int prime[N]; int ans[N*N]; void makeprime() &#123; int j,n=29,i=9,sqrtn; prime[0]=2; prime[1]=3; prime[2]=5; prime[3]=7; prime[4]=11; prime[5]=13; prime[6]=17; prime[7]=19; prime[8]=23; while (i&lt;N) &#123; j=0; sqrtn=(double)sqrt((double)n); while (prime[j]&lt;=sqrtn) &#123; if (n%prime[j]==0)break; j++; &#125; if (prime[j]&gt;sqrtn) &#123; prime[i]=n; i++; &#125; n+=2; &#125; &#125; int main() &#123; makeprime(); for(int i=0;i&lt;N;i++) for(int j=i+1;j&lt;N;j++) &#123; if(prime[i] == prime[j]) continue; else ans[prime[i]+prime[j]]++; &#125; int n; while(cin&gt;&gt;n) &#123; if(!n) break; cout&lt;&lt;ans[n]&lt;&lt;endl; &#125; &#125;"},{"title":"遗传算法求x^2+y^2的最大值，C++实现","permalink":"http://blog.jetmuffin.com/2014/10/08/genetic-algorithm/","text":"最近和学院的教授开始学习数据挖掘和机器学习的课程，第一步就是学习简单的遗传算法。 在网上找了篇教程，于是将其实现。文章地址非常好的理解遗传算法的例子。 内容是求求f(x1,x2)=x1^2+x2^2的最大值 ，x1∈{1,2,3,4,5,6,7} , x2∈{1,2,3,4,5,6,7} 。 选择样本数量为8，经过100代的迭代，效果还不错 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271/*** 遗传算法求f(x1,x2)=x1^2+x2^2的最大值 ** x1∈&#123;1,2,3,4,5,6,7&#125; , x2∈&#123;1,2,3,4,5,6,7&#125; ** @Jet-Muffin*/ #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define SAMPLE_NUM 8 //样本数量 #define EVOLVE_NUM 300 //进化代数 #define random(x) (rand()%x) //随机函数 #define VARIATE_RATE 10 //变异率 void init();void output();void cross();void cross_change(int a,int b);//样本node struct node&#123; int bin[6]; int x1,x2; int f; double pct;&#125;group[SAMPLE_NUM];//样本集合group node temp[SAMPLE_NUM]; //操作中间变量数组 int choosen[SAMPLE_NUM]; //概率分布区域数组 //初始化，随机生成样本 void init() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; //随机生成bin数组 for(int j = 0; j &lt; 6; j++) &#123; int pct = random(100); if(pct &gt;= 50) group[i].bin[j] = 1; else group[i].bin[j] = 0; &#125; &#125;&#125;//计算相应数值 void calcu() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; //生成相应x1、x2 int base = 1; group[i].x1 = group[i].x2 = 0; for(int j = 6 / 2 - 1; j &gt;= 0; j--) &#123; group[i].x1 += base * group[i].bin[j]; base *= 2; &#125; base = 1; for(int j = 6 - 1; j &gt;= 6 / 2; j--) &#123; group[i].x2 += base * group[i].bin[j]; base *= 2; &#125; //计算相应适值 group[i].f = group[i].x1 * group[i].x1 + group[i].x2 * group[i].x2; //计算占总数百分比 int totf = 0; for(int i = 0; i &lt; SAMPLE_NUM; i++) totf += group[i].f; for(int i = 0; i &lt; SAMPLE_NUM; i++) group[i].pct = group[i].f / (double)totf; &#125;&#125;//选择过程 void choose() &#123; cout&lt;&lt;endl; cout&lt;&lt;\"Choosen:.......\"&lt;&lt;endl; memset(choosen,0,sizeof(choosen)); //计算概率区域 choosen[0] = floor(group[0].pct * 100 + 0.5); for(int i = 1; i &lt; SAMPLE_NUM - 1; i++) &#123; choosen[i] = choosen[i-1] + floor(group[i].pct * 100 + 0.5); &#125; choosen[SAMPLE_NUM - 1] = 100; cout&lt;&lt;\"Posibility Area: \"; for(int i = 0; i &lt; SAMPLE_NUM; i++) cout&lt;&lt;choosen[i]&lt;&lt;\" \"; cout&lt;&lt;endl; //生成随机数以模拟选择 for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; int pct = random(100); int choosen_node; for(int j = 1; j &lt; SAMPLE_NUM; j++) if(pct &lt; choosen[j]) &#123; choosen_node = j; break; &#125; cout&lt;&lt;\"seed:\"&lt;&lt;pct&lt;&lt;\", \"; cout&lt;&lt;\"node \"&lt;&lt;choosen_node + 1&lt;&lt;\" was choosen\"&lt;&lt;endl; temp[i] = group[choosen_node]; &#125; //输出选择结果 cout&lt;&lt;\"choosen result:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;temp[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125;&#125;//交叉运算 void cross() &#123; cout&lt;&lt;endl; cout&lt;&lt;\"Crossing:....\"&lt;&lt;endl; cout&lt;&lt;\"Matching:...\"&lt;&lt;endl; //用vector的random_shuffle实现随机乱序配对，从vector中取两个node就进行运算，实现随机交叉 vector&lt;int&gt; seeds; for (int i = 0; i &lt; SAMPLE_NUM; i++) seeds.push_back(i + 1); random_shuffle(seeds.begin(), seeds.end()); int cnt = 0; int pair_fst,pair_sec; for(vector&lt;int&gt;::iterator it = seeds.begin(); it != seeds.end(); it++) &#123; cnt++; if(cnt&amp;1) pair_fst = *it; else pair_sec = *it; if(cnt == 2) &#123; cout&lt;&lt;\"Matching result: \"&lt;&lt;pair_fst&lt;&lt;\"-\"&lt;&lt;pair_sec&lt;&lt;endl; cnt = 0; cross_change(pair_fst - 1,pair_sec - 1); &#125; &#125; //输出交换结果 cout&lt;&lt;\"cross result:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;temp[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125;//交叉运算过程 void cross_change(int a,int b) &#123; //生成交叉点 int cross_seed = random(4) + 1; cout&lt;&lt;\"cross position:\"&lt;&lt;cross_seed&lt;&lt;endl; //输出交换前串信息 cout&lt;&lt;\"temp[\"&lt;&lt;a + 1&lt;&lt;\"]: \"; for(int i = 0; i &lt; 6; i++) &#123; if(i == cross_seed) cout&lt;&lt;\"| \"; cout&lt;&lt;temp[a].bin[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; cout&lt;&lt;\"temp[\"&lt;&lt;b + 1&lt;&lt;\"]: \"; for(int i = 0; i &lt; 6; i++) &#123; if(i == cross_seed) cout&lt;&lt;\"| \"; cout&lt;&lt;temp[b].bin[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; //进行交换 for(int i = cross_seed; i &lt; 6; i++) &#123; int tmp; tmp = temp[a].bin[i]; temp[a].bin[i] = temp[b].bin[i]; temp[b].bin[i] = tmp; &#125;&#125; //变异运算 void variation() &#123; cout&lt;&lt;\"Variation:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i&lt;&lt;\"]:\" ; int position_seed = random(5); cout&lt;&lt;\"variate pos: \"&lt;&lt;position_seed&lt;&lt;\",\"; int var_seed = random(100); if(var_seed &lt; VARIATE_RATE) &#123; cout&lt;&lt;\" success\"; if(temp[i].bin[position_seed]) temp[i].bin[position_seed] = 0; else temp[i].bin[position_seed] = 1; &#125; cout&lt;&lt;endl; &#125; //输出变异结果 cout&lt;&lt;\"variate result:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;temp[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;//将运算的temp数组赋值给group数组以方便下一次迭代运算 void trans() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) group[i] = temp[i];&#125;//输出信息 void output() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"node[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;group[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;\" x1: \"&lt;&lt;group[i].x1; cout&lt;&lt;\" x2: \"&lt;&lt;group[i].x2; cout&lt;&lt;\" f: \"&lt;&lt;group[i].f; cout&lt;&lt;\" percent:\"&lt;&lt;group[i].pct&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125; //总函数接口 void evolution() &#123; init(); calcu(); output(); for(int i = 0; i &lt; EVOLVE_NUM; i++) &#123; choose(); cross(); variation(); trans(); calcu(); output(); &#125;&#125;int main() &#123; srand((int)time(0)); evolution();&#125; 结果：该函数最大值为98，有7个样本进化到了该数值，还有1个样本为次大值，效果不错。"},{"title":"算m点问题，深搜解决","permalink":"http://blog.jetmuffin.com/2014/10/08/using-dfs-to-solute-m-points-problem/","text":"算法导论课后的一道题。 题目：给定k个正整数，用算数运算符+,-,*,/将这k个正整数链接起来，使最终的得数恰为m。 样例输入： 5 125 7 2 2 12 3 样例输出： 7 3 = 21; 21 12 = 252 ; 252 - 2 = 250; 250 / 2 = 125 简单的用深搜解决了，不考虑优化什么的了，数据多的话会超时，不过这不是A题就这样吧~XD 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;ctime&gt; using namespace std; #define maxn 100 int data[maxn],vis[maxn],num[maxn]; char op[maxn]; int n,m; int value = 0; int flag = 0; void output() &#123; int tmp = num[0]; for(int i = 1; i &lt; n ; i++) &#123; cout&lt;&lt;tmp&lt;&lt;\" \"; if(op[i] == '+') &#123; cout&lt;&lt;\"+\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp += num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; if(op[i] == '-') &#123; cout&lt;&lt;\"-\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp -= num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; if(op[i] == '*') &#123; cout&lt;&lt;\"*\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp *= num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; if(op[i] == '/') &#123; cout&lt;&lt;\"/\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp /= num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; &#125; &#125; void dfs(int t) &#123; //cout&lt;&lt;t&lt;&lt;\" \"&lt;&lt;value&lt;&lt;\" \"&lt;&lt;endl; if(t &gt;= n) &#123; if(value == m) &#123; cout&lt;&lt;\"found!\"&lt;&lt;endl; output(); flag = 1; &#125; &#125; else &#123; for(int i = 0; i &lt; n ; i++) &#123; if(t == 0) &#123; if(!vis[i]) &#123; value = data[i]; num[t] = data[i]; vis[i] = 1; dfs(t + 1); vis[i] = 0; &#125; &#125; else &#123; if(!vis[i]) &#123; vis[i] = 1; int tmp = value; op[t] = '+'; num[t] = data[i]; value = tmp + data[i]; dfs(t + 1); if(flag) return; op[t] = '-'; num[t] = data[i]; value = tmp - data[i]; dfs(t + 1); if(flag) return; op[t] = '*'; num[t] = data[i]; value = tmp * data[i]; dfs(t + 1); if(flag) return ; if(data[i] != 0) &#123; op[t] = '/'; num[t] = data[i]; value = tmp / data[i]; dfs(t + 1); if(flag) return; &#125; value = tmp; vis[i] = 0; &#125; &#125; &#125; &#125; &#125; int main() &#123; // freopen(\"in\",\"r\",stdin); cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i++) cin&gt;&gt;data[i]; memset(vis, 0, sizeof(vis)); memset(num, 0, sizeof(num)); memset(op, 0, sizeof(op)); dfs(0); if(!flag) cout&lt;&lt;\"not found!\"&lt;&lt;endl;&#125;"},{"title":"8个8通过加减乘除得到1000 深搜+剪枝 算法实现","permalink":"http://blog.jetmuffin.com/2014/09/22/using-eight-eights-and-four-arithmetic-operation-to-get-1000/","text":"算法导论的作业，编程使得8个8通过加减乘除得到1000。该题类似24点，但数据规模远大于24点的算法。具体思路参考24点的算法，在编程之美中有提到过。 深搜，然后用map 进行对2个操作数的判重进行剪枝，但是该方法仍然会得到大量的重复算式，想了想用set进行筛选重复的expression，虽然稍微影响效率，但是也没事，最终能在20秒左右搜出结果。 代码：```cpp #include #include #include #include #include #include using namespace std;const double EPS = 1e-6;const int NUM = 8;const int RES = 1000;double A[NUM];string res_str[NUM];set ans;set::iterator it;int times = 0; bool dfs(int n) { // 退出条件 if (n==1) { if (fabs(A[0]-RES)&lt;EPS) { // cout &lt;&lt; res_str[0] &lt;&lt; endl; ans.insert(res_str[0]); } } double a, b; string expa, expb; map&lt;int ,int&gt; hash; hash.clear(); for (int i=0; i&lt;n; i++) for (int j=i+1; j&lt;n; j++) { times++; // 保存状态（操作数i,j） a = A[i]; b = A[j]; expa = res_str[i]; expb = res_str[j]; //hash判重 if(hash[a] == b) continue; if(hash[b] == a) continue; hash[a] = b; // 改变状态 A[j] = A[n-1]; res_str[j] = res_str[n-1]; // + A[i] = a+b; res_str[i] = &apos;(&apos; + expa + &apos;+&apos; + expb + &apos;)&apos;; if (dfs(n-1)) return true; // - A[i] = a-b; res_str[i] = &apos;(&apos; + expa + &apos;-&apos; + expb + &apos;)&apos;; if (dfs(n-1)) return true; // - 反方向 A[i] = b-a; res_str[i] = &apos;(&apos; + expb + &apos;-&apos; + expa + &apos;)&apos;; if (dfs(n-1)) return true; // * A[i] = a*b; res_str[i] = &apos;(&apos; + expa + &apos;*&apos; + expb + &apos;)&apos;; if (dfs(n-1)) return true; // / if (b!=0) { A[i] = a/b; res_str[i] = &apos;(&apos; + expa + &apos;/&apos; + expb + &apos;)&apos;; if (dfs(n-1)) return true; } // /反方向 if (a!=0) { A[i] = b/a; res_str[i] = &apos;(&apos; + expb + &apos;/&apos; + expa + &apos;)&apos;; if (dfs(n-1)) return true; } // 恢复状态 A[i] = a; A[j] = b; res_str[i] = expa; res_str[j] = expb; } return false; } int main() { for (int i=0; i&lt;NUM; i++) { A[i] = 8; char c[10]; sprintf(c,”%.0f”,A[i]); res_str[i] = c; } cout&lt;&lt;&quot;start searching....&quot;&lt;&lt;endl; clock_t start = clock(); dfs(NUM); for(it = ans.begin(); it != ans.end();it ++){ cout&lt;&lt;*it&lt;&lt;endl; } clock_t duration = clock() - start; cout&lt;&lt; &quot;found : &quot; &lt;&lt;ans.size()&lt;&lt;&quot; expressions!&quot;&lt;&lt;endl; cout &lt;&lt; &quot;spend : &quot;&lt;&lt;duration &lt;&lt; &quot; ms&quot;&lt;&lt;endl; }"},{"title":"hdu5012 ACM-ICPC 西安赛区E题 Dice","permalink":"http://blog.jetmuffin.com/2014/09/14/hdu-5012-ACM-ICPC-Xian-region-E-Dice/","text":"题目的意思是给定骰子的一个开始状态（六个面的数字），再给定另一个结束状态，问从初始到结束状态最少要走几步，只能前后左右翻滚。 一开始做题想简单了，以为模拟所有方案就可以了，后来发现模拟的越多越乱，结果没A出来。 比赛结束后尝试BFS+Hash(记忆化搜索)，先确定四种操作各改变的数组元素，然后搜索，便可以A了。 代码不够优美，毕竟菜鸟： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define RE freopen(\"in.txt\",\"r\",stdin)#define WE freopen(\"out.txt\",\"w\",stdout) const int maxn=10000;string a,b;char tmp[100],tmp2[100];int hash[maxn];string L(string c)&#123; char t = c[2]; c[2] = c[0]; c[0] = c[3]; c[3] = c[1]; c[1] = t; return c;&#125;string R(string c)&#123; char t = c[1]; c[1] = c[3]; c[3] = c[0]; c[0] = c[2]; c[2] = t; return c;&#125;string F(string c)&#123; char t = c[0]; c[0] = c[5]; c[5] = c[1]; c[1] = c[4]; c[4] = t; return c;&#125; string B(string c)&#123; char t = c[4]; c[4] = c[1]; c[1] = c[5]; c[5] = c[0]; c[0] = t; return c;&#125;struct node&#123; string s; int step; void print() &#123; cout&lt;&lt;s&lt;&lt;endl; &#125; unsigned int APHash() &#123; unsigned int key = 0; int i; for (i=0; i&lt;s.length(); i++) &#123; if ((i &amp; 1) == 0) key ^= ((key &lt;&lt; 7) ^ (s[i]) ^ (key &gt;&gt; 3)); else key ^= (~((key &lt;&lt; 11) ^ (s[i]) ^ (key &gt;&gt; 5))); &#125; return (key &amp; 0x7FFFFFFF)%maxn; &#125;&#125;;void rotate(int i,node &amp;p,node q)&#123; if(i==1) p.s = L(q.s); if(i==2) p.s = R(q.s); if(i==3) p.s = F(q.s); if(i==4) p.s = B(q.s);&#125;node p;void print()&#123; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;endl;&#125;int bfs() &#123; memset(hash,0,sizeof(hash)); int j,key; queue&lt;node&gt; q; q.push(p); while(!q.empty()) &#123; node p = q.front(); if(p.s == b) &#123; return p.step; &#125; node l,r,f,b; int ll,rr,ff,bb; rotate(1,l,p);ll=l.APHash(); rotate(2,r,p);rr=r.APHash(); rotate(3,f,p);ff=f.APHash(); rotate(4,b,p);bb=b.APHash(); if(!hash[ll])&#123; l.step=p.step+1; hash[ll] = 1; q.push(l); &#125; if(!hash[rr])&#123; r.step=p.step+1; hash[rr] = 1; q.push(r); &#125; if(!hash[ff])&#123; f.step=p.step+1; hash[ff] = 1; q.push(f); &#125; if(!hash[bb])&#123; b.step=p.step+1; hash[bb] = 1; q.push(b); &#125; // cout&lt;&lt;\"bfs: \"&lt;&lt;p.s&lt;&lt;\" hashKey:\"&lt;&lt;p.APHash()&lt;&lt;\" depth:\"&lt;&lt;p.step&lt;&lt;endl; q.pop(); &#125; return -1;&#125;int main()&#123; //RE; while(gets(tmp)&amp;&amp;gets(tmp2)) &#123; a=\"\"; b=\"\"; for(int i=0;i&lt;strlen(tmp);i++) if(tmp[i]!=' ') a+= tmp[i]; for(int i=0;i&lt;strlen(tmp2);i++) if(tmp2[i]!=' ') b+= tmp2[i]; p.s=a; p.step=0; cout&lt;&lt;bfs()&lt;&lt;endl; &#125;&#125;"},{"title":"hdu5011 西安邀请赛E题 Game 博弈论","permalink":"http://blog.jetmuffin.com/2014/09/14/hdu-5011-xian-invitation-Game-game-theory/","text":"比赛前没有看过博弈论，也不知道Nim问题，这题写了一个多小时，做出来一个错误的结论。。硬伤。。 事实上只要把每个数求异或就可以出结果了。 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; long long a; int ans; cin&gt;&gt;ans; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;a; ans ^= a; &#125; if(ans) puts(\"Win\"); else puts(\"Lose\"); &#125;&#125;"},{"title":"hdu5007 ACM-ICPC 西安赛区网赛A题 水题","permalink":"http://blog.jetmuffin.com/2014/09/14/hdu-5007-ACM-ICPC-xian-online-a/","text":"题意为 只要文章中出现相应词语，就输出语句。第一眼看这题想用字典树，想想不对，后来果断拉了一段KMP代码AC了，后来才发现根本不需要这么复杂KMP，直接每碰到一个‘A’，’i’，‘S’,进行相应判断就好了，不过用KMP直接码一小段代码就可以快速AC也是不错的！ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;#define maxn 100000int next[maxn];char s[maxn],p[maxn];void makeNext(char *p,int *next)&#123; int q,k; int m = strlen(p); next[0] = 0; for(q=1,k=0;q&lt;m;q++) &#123; while(k&gt;0&amp;&amp;p[q]!=p[k]) k = next[k-1]; if(p[q]==p[k]) k++; next[q]=k; &#125;&#125;int kmp(char *s,char *p,int *next)&#123; int n,m; int i,q; int count = 0; n = strlen(s); m = strlen(p); makeNext(p,next); for (i = 0,q = 0; i &lt; n; ++i) &#123; while(q &gt; 0 &amp;&amp; p[q] != s[i]) q = next[q-1]; if (p[q] == s[i]) &#123; q++; &#125; if (q == m) &#123; count++; &#125; &#125; return count; &#125;int check1(char *s)&#123; if(kmp(s,\"Apple\",next)||kmp(s,\"iPhone\",next)||kmp(s,\"iPod\",next)||kmp(s,\"iPad\",next)) return 1; else return 0;&#125;int check2(char *s)&#123; if(kmp(s,\"Sony\",next)) return 1; else return 0;&#125;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); while(cin&gt;&gt;s) &#123; if(check1(s)) cout&lt;&lt;\"MAI MAI MAI!\"&lt;&lt;endl; if(check2(s)) cout&lt;&lt;\"SONY DAFA IS GOOD!\"&lt;&lt;endl; &#125;&#125;"},{"title":"2014 Multi-University Training Contest 2 1011 ZCC Loves Codefires 解题报告","permalink":"http://blog.jetmuffin.com/2014/07/24/2014-Multi-University-Training-Contest-2-1011-ZCC-Loves-Codefires-solution/","text":"暑期联训第二场。 高中被镇海虐了3年，大学继续被镇海虐，刚入ACM这条路不久，基础不够扎实，镇海还出这么变态的题目= =，就AC了最后一题。。 题目如上，总结就是类似分顺序取数，每个数大小不同，但是取出顺序会累加从而影响最后的结果，为了使最后结果最小，要找到最优解。 第一下看到这个题目，第一反应就是用动态规划去做，但是琢磨半天很难想出状态方程，因为它每个状态点无法比较状态对应的值大小（即使比较了也无意义）。 多次尝试之后，开始寻求其他方法，想了一种最朴素的方法， 定义结构体1234567point&#123; int E; int K; &#125; 先用快速排序将按分值将point从大到小排序，然后依次从大到小进行冒泡，每次冒泡能保证前几次会使函数值减小，当再冒泡函数值增加时就停止该数的冒泡，换第二大的数进行冒泡。但是该算法每进行一次冒泡需要计算一次函数值，且n过大，最后导致TLE。 之后开始寻找变换的规律， 写出一组数据： 10 10 20 30 1 2 3 4 totEi 30 50 60 70 Ki 4 3 2 1 交换3 和 4 后得到 totEi 20 50 60 70 Ki 3 4 2 1 可以看出，3和4的交换，对于其他项是不会有影响的，对值的影响来源于304+503与203+504的大小变换。 用常规变量表示的话就是，point(i)&gt;point(i+1) 的充要条件是 Ei+1Ki+1+(Ei+Ei+1)Ki&lt;EiKi+(Ei+1+Ei)Ki+1 化简得 EiKi+1&lt;Ei+1Ki 即Ei/Ki &gt; Ei+1/Ki+1 所以只要该条件满足，交换point(i)与point(i+1）就能得到最优解。 因而在point结构体中加入变量double s // s=E/K; 根据s对 point进行快速排序，排序得到的就是最优解，求和就是要出的结果了。 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;algorithm&gt;using namespace std;struct point&#123; int E; int K; double s;&#125;;struct point p[100001]; int cmp(point p1,point p2) &#123; return p1.s&lt;p2.s;&#125;int main() &#123; freopen(\"in.txt\",\"r\",stdin); int i,j,N; int min; __int64 sum=0; __int64 totE=0; cin&gt;&gt;N; for(i=1;i&lt;=N;i++) cin&gt;&gt;p[i].E; for(i=1;i&lt;=N;i++) cin&gt;&gt;p[i].K; for(i=1;i&lt;=N;i++) p[i].s = p[i].E/(double)p[i].K; sort(p+1,p+N+1,cmp); for(i=1;i&lt;=N;i++) &#123; totE+=p[i].E; sum+= totE*p[i].K; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;"},{"title":"hdu4828 Grids 百度之星初赛1002解题报告","permalink":"http://blog.jetmuffin.com/2014/07/21/hdu-4828-Grids-Astar-1002-solution/","text":"搞ACM起步比较晚，但是对这方面兴趣很大，第一次参加百度之星，资格赛水过一道题进入初赛，结果初赛被一道题难倒了。 初赛分两场，每场筛选500人（赛程规定），而之后的结果上看，只有约250人A出题，而大多数人都是通过这道题拿到复赛入场券。这道题我一直觉得非常接近结果了，但是在最重要的环节，也就是取模上出了很大的问题，导致没有A出该题，下面是该题的分析。 题干上，大多数人可以看出看出规律，即求卡特兰数，HDOJ上有相类似的题目，但是这道题的数据量非常大，有100万之多，因而题目上要求对1000000007取模。 卡特兰数有很多递推公式，我选择的是h(n)=h(n-1)(4n-2)/(n+1);这条。 由于数据量比较大，因而我选择用打表的方式，但是这里出现了一个问题，卡特兰数的数据在不断的增大，因而一定要在取模的基础上进行递推，然而简单地进行取模会造成递推公式出错，即不能在原结果上直接取模。 比赛时就卡在这点上了，怎么想都想不出改进的方法。 直到后来做到HDOJ的拓展欧几里德的题目（HDOJ 1576），才直到这道题的解法。 除法的取模需要用extgcd的算法进行取逆，这是该题的关键。 该题代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;__int64 h[1000001];const int MOD=1000000007;int extgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; return a; &#125; int r=extgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return r;&#125;int main()&#123; int T; int n,i,j,x,y; h[0]=1; for(i=1;i&lt;=1000000;i++) &#123; h[i]=(4*i-2)%MOD; h[i]=(h[i]*h[i-1])%MOD; extgcd(i+1,MOD,x,y); h[i]=(h[i]*(x+MOD)%MOD)%MOD; &#125; cin&gt;&gt;T; for(i=1;i&lt;=T;i++) &#123; cin&gt;&gt;n; cout&lt;&lt;\"Case #\"&lt;&lt;i&lt;&lt;\":\"&lt;&lt;endl; cout&lt;&lt;h[n]&lt;&lt;endl; &#125; return 0;&#125;"}]}