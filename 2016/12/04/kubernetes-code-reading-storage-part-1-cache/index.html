<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>kubernetes源码阅读 - storage part 1 - cache | JetMuffin&#39;s Blog</title>
  <meta name="description" content="A minimal hexo theme." />
  <meta name="keywords" content="hexo,theme,typescript,otakism,otaku" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 Storage，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="kubernetes源码阅读 - storage part 1 - cache">
<meta property="og:url" content="http://blog.jetmuffin.com/2016/12/04/kubernetes-code-reading-storage-part-1-cache/index.html">
<meta property="og:site_name" content="JetMuffin's Blog">
<meta property="og:description" content="kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 Storage，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？">
<meta property="og:updated_time" content="2017-02-17T13:05:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kubernetes源码阅读 - storage part 1 - cache">
<meta name="twitter:description" content="kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 Storage，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？">
  
  
    <link rel="icon" href="/favicon.png">
  
  
	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku keeps alive
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<div class="site-sidebar">
	
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          Home
        </a>
      
        <a href="/about" class="nav-about nav">
          About
        </a>
      
        <a href="/archives" class="nav-archives nav">
          Archives
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      <article id="post-kubernetes-code-reading-storage-part-1-cache"
  class="post article white-box article-type-post"
  itemscope itemprop="blogPost">
	<h2 class="title">
  	<a href="/2016/12/04/kubernetes-code-reading-storage-part-1-cache/">
    	kubernetes源码阅读 - storage part 1 - cache
    </a>
  </h2>
	<time>
	  12月 4, 2016
	</time>
	<section class="content">
  	<div class="article-entry" itemprop="articleBody">
    	<p>kubernetes 的 scheduler 维护了一个先进先出的队列，而这个队列的事实上是一种 <code>Storage</code>，只不过它重载了 Storage 中的各种方法。那么 kubernetes 中的存储是如何设计的呢？</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</div><div class="line">	Store <span class="comment">// Queue事实上也是一种Storage，而在FIFOQueue中具体对Add,List,Delete等方法进行了重写</span></div><div class="line"></div><div class="line">	Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</div><div class="line"></div><div class="line">	AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</div><div class="line"></div><div class="line">	<span class="comment">// Return true if the first batch of items has been popped</span></div><div class="line">	HasSynced() <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>在 <code>pkg/client/cache</code> 包里实现了 cache 的一些基本结构，其中最核心的，也是最顶层的结构是 <code>Store</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/store.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</div><div class="line">	Add(obj <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 增</span></div><div class="line">	Update(obj <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 改</span></div><div class="line">	Delete(obj <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 删</span></div><div class="line">	List() []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 列举</span></div><div class="line">	ListKeys() []<span class="keyword">string</span> <span class="comment">// 列举 key</span></div><div class="line">	Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error) <span class="comment">// 查</span></div><div class="line">	GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error) <span class="comment">// 按key查</span></div><div class="line"></div><div class="line">	<span class="comment">// Replace will delete the contents of the store, using instead the</span></div><div class="line">	<span class="comment">// given list. Store takes ownership of the list, you should not reference</span></div><div class="line">	<span class="comment">// it after calling this function.</span></div><div class="line">	Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error <span class="comment">// 替换</span></div><div class="line">	Resync() error <span class="comment">// 同步</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Store 接口定义了 cache 中的所有数据类型的最通用的一层抽象，包括对 cache 存储的增删改查列举等操作。Store 具体的接口实现包括前面提到的 <code>FIFO</code>，<code>DeltaFIFO</code>，以及后面会提到的 <code>ThreadSafeStore</code>，<code>UnDeltaStore</code> 和 <code>ExpirationCache</code>。</p>
<h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p><code>ThreadSafeStore</code> 是 k8s 中用的最多，也是默认的 cache 存储。它允许对数据并行的访问，同时使用加锁的机制保证数据在多线程中是线程安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/thread_safe_store.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</div><div class="line">	lock  sync.RWMutex <span class="comment">// 锁</span></div><div class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 存储数据的map</span></div><div class="line"></div><div class="line">	<span class="comment">// indexers maps a name to an IndexFunc</span></div><div class="line">	indexers Indexers <span class="comment">// 存储Indexer的map</span></div><div class="line">	<span class="comment">// indices maps a name to an Index</span></div><div class="line">	indices Indices <span class="comment">// 存储Index的map</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ThreadSafeStore</code> 的实现上也比较简单，数据放在 map 的数据结构里，同时使用 <code>sync.RWMutex</code> 对这个 map 的 Add，Update，Delete，Get 等操作加读锁和写锁。此外，它还允许对同一作用的 items 加一个共同的索引方便直接获取，而这个索引放在 <code>indices</code> 里，获得索引的函数放在 <code>indexers</code> 里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/thread_safe_store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">Index</span><span class="params">(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	c.lock.RLock()</div><div class="line">	<span class="keyword">defer</span> c.lock.RUnlock()</div><div class="line"></div><div class="line">	indexFunc := c.indexers[indexName] <span class="comment">// 通过给的索引名称拿到索引函数</span></div><div class="line">	<span class="keyword">if</span> indexFunc == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Index with name %s does not exist"</span>, indexName)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	indexKeys, err := indexFunc(obj) <span class="comment">// 用索引函数拿到索引的keys</span></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	index := c.indices[indexName]</div><div class="line"></div><div class="line">	<span class="comment">// need to de-dupe the return list.  Since multiple keys are allowed, this can happen.</span></div><div class="line">	returnKeySet := sets.String&#123;&#125;</div><div class="line">	<span class="keyword">for</span> _, indexKey := <span class="keyword">range</span> indexKeys &#123;  <span class="comment">// 对索引的keys进行去重</span></div><div class="line">		set := index[indexKey]</div><div class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> set.UnsortedList() &#123;</div><div class="line">			returnKeySet.Insert(key)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	list := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, returnKeySet.Len())</div><div class="line">	<span class="keyword">for</span> absoluteKey := <span class="keyword">range</span> returnKeySet &#123;</div><div class="line">		list = <span class="built_in">append</span>(list, c.items[absoluteKey]) <span class="comment">// 根据keys拿到实际的items放到list里</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> list, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="UndeltaStore"><a href="#UndeltaStore" class="headerlink" title="UndeltaStore"></a>UndeltaStore</h3><p><code>UndeltaStore</code> 在 <code>Store</code> 上做了一层封装，在实例化时传入了一个回调函数 <code>PushFunc</code>，每当 <code>Store</code> 进行了 Add，Update，Delete 等操作，会调用 <code>PushFunc</code> 来告知这个数据的操作已经完成，可以进行后续的工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/undelta_store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UndeltaStore)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err := u.Store.Add(obj); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	u.PushFunc(u.Store.List())</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现上其实也很简单，在每个操作的最后调用一次传入的 <code>PushFunc()</code>。</p>
<h3 id="ExpirationCache"><a href="#ExpirationCache" class="headerlink" title="ExpirationCache"></a>ExpirationCache</h3><p><code>ExpirationCache</code> 同样是对 <code>Store</code> 做了一层的封装，和 <code>UndeltaStore</code> 不同的是它是在 <code>ThreadSafeStore</code> 上进行的封装，实现了带过期期限的 cache 功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/expiration_cache.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> ExpirationCache <span class="keyword">struct</span> &#123;</div><div class="line">	cacheStorage     ThreadSafeStore <span class="comment">// 实际存储的storage</span></div><div class="line">	keyFunc          KeyFunc</div><div class="line">	clock            clock.Clock <span class="comment">// 标记创建时间的时间戳</span></div><div class="line">	expirationPolicy ExpirationPolicy <span class="comment">// 失效策略</span></div><div class="line">	<span class="comment">// expirationLock is a write lock used to guarantee that we don't clobber</span></div><div class="line">	<span class="comment">// newly inserted objects because of a stale expiration timestamp comparison</span></div><div class="line">	expirationLock sync.Mutex <span class="comment">// 失效检查的锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>ExpirationCache</code> 中的每个 item 被创建的时候会为其打上时间戳，而这个 item 在查询的时候会检查这个时间戳到目前的时间间隔是否超过了失效的阈值，若超过了则返回 <code>nil</code> 并把这个 item 从 map 里删掉。（这里相当于做了一个 lazy 操作，如果 item 失效了但是一直没有查询，那么它会一直在 map 里待着）。</p>
<p>默认使用的失效策略比较简单，就是给定一个时间范围阈值 <code>TTL(TimeToLive)</code>，然后判断这个时间戳到现在的时间距离是否大于这个阈值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/expiration_cache.go</span></div><div class="line"><span class="keyword">type</span> TTLPolicy <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">//	 &gt;0: Expire entries with an age &gt; ttl</span></div><div class="line">	<span class="comment">//	&lt;=0: Don't expire any entry</span></div><div class="line">	Ttl time.Duration <span class="comment">// 过期阈值</span></div><div class="line"></div><div class="line">	<span class="comment">// Clock used to calculate ttl expiration</span></div><div class="line">	Clock clock.Clock</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *TTLPolicy)</span> <span class="title">IsExpired</span><span class="params">(obj *timestampedEntry)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> p.Ttl &gt; <span class="number">0</span> &amp;&amp; p.Clock.Since(obj.timestamp) &gt; p.Ttl <span class="comment">// 判断是否失效（间隔是否大于TTL）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比于 <code>ThreadSafeStore</code>，<code>ExpirationCache</code> 在使用时还需要检查 item 是不是失效了，而这个检查的过程也是加锁的，而我们知道 <code>ThreadSafeStore</code> 自身本来就是带锁的操作的，所以它的操作会比 <code>ThreadSafeStore</code> 慢一些。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>除了上面提到的几种 cache 中用到的数据结构外，cache 包里还提供了一些其他的类来进行辅助工作：</p>
<ul>
<li>Indexer（<code>pkg/client/cache/index.go</code>）允许用多种方法对 items 进行过滤（索引）</li>
<li>Lister（<code>pkg/client/cache/lister.go</code>）提供了各种列举 items 的方法</li>
<li>MutationDetection（<code>pkg/client/cache/mutation_dectector.go</code>）检测某个 item 是否发生变化了</li>
<li>…</li>
</ul>
<h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><p>cache 包里的各个类定义了不同场景下 k8s 使用的数据结构，我们也知道 k8s 里实际存储 pods 等资源是放在 <code>ThreadSafeStore</code> 里的，那么 k8s 是如何将 APIServer 里的 RESTful API 和 cache 相联系起来的呢？</p>
<p>在 <code>pkg/client/cache/reflector.go</code> 里，k8s 提供了一种叫做 <code>Reflector</code> 的类，用于作为 APIServer 和 cache 之间的桥梁。对每一类 Resource 为它创建一个从 RESTful Resource 到 cache item 的 Reflector。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></div><div class="line">	name <span class="keyword">string</span></div><div class="line"></div><div class="line">	<span class="comment">// The type of object we expect to place in the store.</span></div><div class="line">	expectedType reflect.Type <span class="comment">// item的类型</span></div><div class="line">	<span class="comment">// The destination to sync up with the watch source</span></div><div class="line">	store Store <span class="comment">// item 的实际存储</span></div><div class="line">	<span class="comment">// listerWatcher is used to perform lists and watches.</span></div><div class="line">	listerWatcher ListerWatcher <span class="comment">// 用于监听item变化的watcher</span></div><div class="line">	<span class="comment">// period controls timing between one watch ending and</span></div><div class="line">	<span class="comment">// the beginning of the next one.</span></div><div class="line">	period       time.Duration <span class="comment">//watch的间隔</span></div><div class="line">	resyncPeriod time.Duration</div><div class="line">	<span class="comment">// now() returns current time - exposed for testing purposes</span></div><div class="line">	now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></div><div class="line">	// <span class="title">lastSyncResourceVersion</span> <span class="title">is</span> <span class="title">the</span> <span class="title">resource</span> <span class="title">version</span> <span class="title">token</span> <span class="title">last</span></div><div class="line">	// <span class="title">observed</span> <span class="title">when</span> <span class="title">doing</span> <span class="title">a</span> <span class="title">sync</span> <span class="title">with</span> <span class="title">the</span> <span class="title">underlying</span> <span class="title">store</span></div><div class="line">	// <span class="title">it</span> <span class="title">is</span> <span class="title">thread</span> <span class="title">safe</span>, <span class="title">but</span> <span class="title">not</span> <span class="title">synchronized</span> <span class="title">with</span> <span class="title">the</span> <span class="title">underlying</span> <span class="title">store</span></div><div class="line">	<span class="title">lastSyncResourceVersion</span> <span class="title">string</span></div><div class="line">	// <span class="title">lastSyncResourceVersionMutex</span> <span class="title">guards</span> <span class="title">read</span>/<span class="title">write</span> <span class="title">access</span> <span class="title">to</span> <span class="title">lastSyncResourceVersion</span></div><div class="line">	<span class="title">lastSyncResourceVersionMutex</span> <span class="title">sync</span>.<span class="title">RWMutex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Reflector 有两种允许方式：</p>
<ul>
<li><code>Run()</code></li>
<li><code>RunUntil(stopCh &lt;-chan struct{})</code></li>
</ul>
<p>两者的区别在于后者传入了一个 stopCh，当收到停止信号会停止这个 <code>Run()</code> 方法，而前者则是 Run forever 的。而两者的方法的主题都是一致的，都在启动了一个 goroutine 去一直执行 <code>ListAndWatch()</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</div><div class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err := r.ListAndWatch(wait.NeverStop); err != <span class="literal">nil</span> &#123; <span class="comment">// 一直执行ListAndWatch</span></div><div class="line">			utilruntime.HandleError(err)</div><div class="line">		&#125;</div><div class="line">	&#125;, r.period, wait.NeverStop)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么来看一看这个 <code>ListAndWatch()</code> 是做什么的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"></div><div class="line"><span class="comment">//...</span></div><div class="line">w, err := r.listerWatcher.Watch(options) <span class="comment">// 获得一个watch.Interface</span></div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">	<span class="keyword">switch</span> err &#123;</div><div class="line">	<span class="keyword">case</span> io.EOF:</div><div class="line">		<span class="comment">// watch closed normally</span></div><div class="line">	<span class="keyword">case</span> io.ErrUnexpectedEOF:</div><div class="line">		glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></div><div class="line">	<span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></div><div class="line">	<span class="comment">// watch where we ended.</span></div><div class="line">	<span class="comment">// If that's the case wait and resend watch request.</span></div><div class="line">	<span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</div><div class="line">		<span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</div><div class="line">			<span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</div><div class="line">				time.Sleep(time.Second)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123; <span class="comment">// 处理这个 watch.Interface</span></div><div class="line">	<span class="keyword">if</span> err != errorStopRequested &#123;</div><div class="line">		glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>在 <code>ListAndWatch()</code> 中前面先开了一个独立的 goroutine 去同步 Store 这里就不细说了。核心的内容在后面，首先是 <code>r.listerWatcher.Watch(options)</code> 获取到一个 <code>watch.Interface</code> 对象，然后对这个对象进行处理，即 <code>r.watchHandler()</code>。</p>
<p>首先看这个 <code>watch.Interface</code>，寻找引用它的路径可以按着 <code>pkg/client/cache/listwatch.go: ListerWatcher.Watch()</code> -&gt; <code>pkg/client/cache/listwatch.go: ListWatch.WatchFunc</code> -&gt; <code>pkg/client/cache/listwatch.go: NewListWatchFromClient()</code> 的一个思路去看。</p>
<p>那么最终关注这个 <code>NewListWatchFromClient()</code> 方法，它事实上就是连接着 API 的那一头，传入了 API 的一个 Resource，而 <code>ListerWatcher</code> 的 <code>Watch()</code> 方法就是这个 Resource 中的 <code>Watch()</code> 方法。具体实例化是在每个资源的包中，例如 <code>pkg/kubelet/config/apiserver.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/kubelet/config/apiserver.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSourceApiserver</span><span class="params">(c *clientset.Clientset, nodeName types.NodeName, updates <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	lw := cache.NewListWatchFromClient(c.Core().RESTClient(), <span class="string">"pods"</span>, v1.NamespaceAll, fields.OneTermEqualSelector(api.PodHostField, <span class="keyword">string</span>(nodeName)))</div><div class="line">	newSourceApiserverFromLW(lw, updates)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里为 pods 创建了一个 RESTClient，同时用这个 Client 作为参数创建一个 ListWatcher，ListAndWatch 中的 Watch 方法就是 Client 中的 Watch 方法。</p>
<p>那么搞清楚了这一头了以后看一看检测到变化以后 Reflector 是怎么处理的。在 ListAndWatch 方法中还有一个重要的方法 <code>watchHandler()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/reflector.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">  	<span class="comment">//...</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-stopCh:</div><div class="line">			<span class="keyword">return</span> errorStopRequested</div><div class="line">		<span class="keyword">case</span> err := &lt;-errc:</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		<span class="keyword">case</span> event, ok := &lt;-w.ResultChan(): <span class="comment">// 从ResultChan中拿出一个event</span></div><div class="line">			<span class="keyword">if</span> !ok &#123;</div><div class="line">				<span class="keyword">break</span> loop</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> event.Type == watch.Error &#123;</div><div class="line">				<span class="keyword">return</span> apierrs.FromObject(event.Object)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			meta, err := meta.Accessor(event.Object) <span class="comment">//用event.Object获取meta信息</span></div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			newResourceVersion := meta.GetResourceVersion()</div><div class="line">			<span class="keyword">switch</span> event.Type &#123; <span class="comment">// 根据event的不同类型对cache做不同处理</span></div><div class="line">			<span class="keyword">case</span> watch.Added:</div><div class="line">				r.store.Add(event.Object)</div><div class="line">			<span class="keyword">case</span> watch.Modified:</div><div class="line">				r.store.Update(event.Object)</div><div class="line">			<span class="keyword">case</span> watch.Deleted:</div><div class="line">				<span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></div><div class="line">				<span class="comment">// state", which is passed in event.Object? If so, may need</span></div><div class="line">				<span class="comment">// to change this.</span></div><div class="line">				r.store.Delete(event.Object)</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</div><div class="line">			&#125;</div><div class="line">			*resourceVersion = newResourceVersion</div><div class="line">			r.setLastSyncResourceVersion(newResourceVersion)</div><div class="line">			eventCount++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>watchHandler()</code> 的核心是这个 loop，Reflector 会从 watch.Interface 中拿到一个叫做 ResultChan 的 chanel，watch.Interface 在 API 的那一头会根据 HTTP Request 源源不断往这个 chanel 里扔进去事件 Event（<code>pkg/watch/watch.go: Event</code>），而 Reflector 从 chanel 的这一头不断的拿出这些事件，获取他们的 meta 信息，再根据事件的不同类型对 cache 做增删改查操作。</p>
<p>也就是说 k8s 对各种操作事实上是统一通过这个 chanel 里以事件的形式市传过来的，这也解释了为什么 cache 和 Store 中的实现所有的方法都是传进去一个 object 的 interface。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里所有的路径都打通了，再最后理一遍 k8s 是如何从 API 到 cache 的 Store 的：</p>
<ol>
<li>APIServer 为每类资源（例如 pods）创建一个 RESTClient（client）用于处理诸如 POST，PUT，GET 的 RESTful HTTP requsts</li>
<li>APIServer 用 client 创建一个 ListWatcher（lw）用于监控每类资源的变化</li>
<li>APIServer 用 lw，指定的 store，创建一个 Reflector（reflector），将这个变化作用到 store 上</li>
<li>当发生 HTTP Requests 时，client 的 Watch 方法会把资源和资源变化类型打包成 event 放进 lw 的 ResultChan 中</li>
<li>reflector 从 ResultChan 里拿出 event，根据 event.EventType 把 event.Object 作用到 store 里去</li>
</ol>
<p>整个过程中用了许多的 goroutine 来完成这么一件事。相比于 k8s 的实现，常见的 webapp 的处理相对就简单了好多，也可以看出 k8s 在设计上的精妙。</p>

  	</div>
	  
	  <div class="article-tags tags">
		  
        <a class="tag-link" href="/tags/cache/">cache</a><a class="tag-link" href="/tags/kubernetes/">kubernetes</a><a class="tag-link" href="/tags/storage/">storage</a>
      
	  </div>
	</section>
</article>


<section id="comments">
	<div id="disqus_thread"></div>
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" class="u-search-input" placeholder="Looking for something?" />
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/artchen" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/otakism" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
        <a href="https://plus.google.com/+ArtChenOtakism/posts" class="social google"
          target="_blank" rel="external">
          <span class="icon icon-google"></span>
        </a>
      
        <a href="http://weibo.com/otakism/" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">JetMuffin&#39;s Blog</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'jetmuffin';
  
  var disqus_url = 'http://blog.jetmuffin.com/2016/12/04/kubernetes-code-reading-storage-part-1-cache/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
