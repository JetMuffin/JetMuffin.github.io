<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>kubernetes源码阅读 - scheduler | JetMuffin&#39;s Blog</title>
  <meta name="description" content="A minimal hexo theme." />
  <meta name="keywords" content="hexo,theme,typescript,otakism,otaku" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。">
<meta property="og:type" content="article">
<meta property="og:title" content="kubernetes源码阅读 - scheduler">
<meta property="og:url" content="http://blog.jetmuffin.com/2016/11/24/kubernetes-code-reading-scheduler/index.html">
<meta property="og:site_name" content="JetMuffin's Blog">
<meta property="og:description" content="阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。">
<meta property="og:image" content="http://cdn.jetmuffin.com/posts/kubernetes.jpg">
<meta property="og:updated_time" content="2017-02-17T13:05:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kubernetes源码阅读 - scheduler">
<meta name="twitter:description" content="阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。">
<meta name="twitter:image" content="http://cdn.jetmuffin.com/posts/kubernetes.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  
	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku keeps alive
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<div class="site-sidebar">
	
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          Home
        </a>
      
        <a href="/about" class="nav-about nav">
          About
        </a>
      
        <a href="/archives" class="nav-archives nav">
          Archives
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      <article id="post-kubernetes-code-reading-scheduler"
  class="post article white-box article-type-post"
  itemscope itemprop="blogPost">
	<h2 class="title">
  	<a href="/2016/11/24/kubernetes-code-reading-scheduler/">
    	kubernetes源码阅读 - scheduler
    </a>
  </h2>
	<time>
	  11月 24, 2016
	</time>
	<section class="content">
  	<div class="article-entry" itemprop="articleBody">
    	<p>阅读 scheduler 部分的源码我们从控制流的低端向上延伸去阅读。</p>
<p><img src="http://cdn.jetmuffin.com/posts/kubernetes.jpg" alt="k8s"></p>
<a id="more"></a>
<h2 id="Scheduler-入口"><a href="#Scheduler-入口" class="headerlink" title="Scheduler 入口"></a>Scheduler 入口</h2><p>首先定位到 <code>plugin/cmd/scheduler.go</code> 这个文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/cmd/scheduler.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := options.NewSchedulerServer()</div><div class="line">    s.AddFlags(pflag.CommandLine) <span class="comment">// 解析参数</span></div><div class="line"></div><div class="line">    flag.InitFlags()</div><div class="line">    logs.InitLogs()</div><div class="line">    <span class="keyword">defer</span> logs.FlushLogs()</div><div class="line"></div><div class="line">    verflag.PrintAndExitIfRequested()</div><div class="line"></div><div class="line">    app.Run(s) <span class="comment">// 启动调度器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面这段代码可以看出这是从 command 启动 scheduler 的入口，它解析了 scheduler 的参数，同时调用了 <code>app.Run(s)</code>来启动 scheduler。</p>
<p>按着这个走向找到 <code>app.Run(s)</code> 的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/cmd/kube-scheduler/app/server.go</span></div><div class="line"></div><div class="line"><span class="comment">// Run runs the specified SchedulerServer.  This should never exit.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(s *options.SchedulerServer)</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line"></div><div class="line">    sched := scheduler.New(config) <span class="comment">// 新建调度器</span></div><div class="line"></div><div class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(_ &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</div><div class="line">        sched.Run() <span class="comment">// 正式启动调度器入口</span></div><div class="line">        <span class="keyword">select</span> &#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到在这段代码片段中，通过 <code>sched := scheduler.New(config)</code> 新建了一个 scheduler 对象，并且调用它的 <code>Run()</code> 成员方法，同时需要特意留意 <code>config</code>。继续追踪到 scheduler 类的定义中取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="comment">// Run begins watching and scheduling. It starts a goroutine and returns immediately.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">go</span> wait.Until(s.scheduleOne, <span class="number">0</span>, s.config.StopEverything)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Scheduler.Run()</code> 方法中，Scheduler 通过 <code>wait.Until()</code> 工具，不停得调用 <code>Scheduler.scheduleOne()</code> 方法直到收到停止信号。我们接着看 <code>scheduleOne()</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">scheduleOne</span><span class="params">()</span></span> &#123;</div><div class="line">    pod := s.config.NextPod() <span class="comment">// 获取下一个待调度的pod</span></div><div class="line"></div><div class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Attempting to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">    start := time.Now()</div><div class="line">    dest, err := s.config.Algorithm.Schedule(pod, s.config.NodeLister) <span class="comment">// 调用算法进行调度</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        glog.V(<span class="number">1</span>).Infof(<span class="string">"Failed to schedule pod: %v/%v"</span>, pod.Namespace, pod.Name)</div><div class="line">        s.config.Error(pod, err)</div><div class="line">        s.config.Recorder.Eventf(pod, api.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"%v"</span>, err)</div><div class="line">        s.config.PodConditionUpdater.Update(pod, &amp;api.PodCondition&#123;</div><div class="line">            Type:   api.PodScheduled,</div><div class="line">            Status: api.ConditionFalse,</div><div class="line">            Reason: api.PodReasonUnschedulable,</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    metrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInMicroseconds(start))</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scheduler 首先通过 <code>config.NextPod()</code> 来获取到当前要进行调度的一个 pod，然后调用 <code>config.Algorithm.Schedule()</code> 方法来对这个 pod 实际进行调度。从这种写法上我们可以猜测到 Algorithm 这儿用的是工厂模式。若根据该算法调度成功，那么将这个时间进行记录。否则调用 <code>config.Error()</code> 来进行错误处理。</p>
<p>这里有三个比较重点的内容：</p>
<ul>
<li>config.NextPod()</li>
<li>config.Algorithm.schedule()</li>
<li>config.Error()</li>
</ul>
<p>它们均来自 <code>Config</code> 类，那么我们先看这个类，再接下去探索这两个方法。<code>Config</code> 类的定义也在这个文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/scheduler.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// It is expected that changes made via SchedulerCache will be observed</span></div><div class="line">    <span class="comment">// by NodeLister and Algorithm.</span></div><div class="line">    SchedulerCache schedulercache.Cache</div><div class="line">    NodeLister     algorithm.NodeLister</div><div class="line">    Algorithm      algorithm.ScheduleAlgorithm <span class="comment">// 调度算法</span></div><div class="line">    Binder         Binder</div><div class="line">    <span class="comment">// PodConditionUpdater is used only in case of scheduling errors. If we succeed</span></div><div class="line">    <span class="comment">// with scheduling, PodScheduled condition will be updated in apiserver in /bind</span></div><div class="line">    <span class="comment">// handler so that binding and setting PodCondition it is atomic.</span></div><div class="line">    PodConditionUpdater PodConditionUpdater</div><div class="line"></div><div class="line">    <span class="comment">// NextPod should be a function that blocks until the next pod</span></div><div class="line">    <span class="comment">// is available. We don't use a channel for this, because scheduling</span></div><div class="line">    <span class="comment">// a pod may take some amount of time and we don't want pods to get</span></div><div class="line">    <span class="comment">// stale while they sit in a channel.</span></div><div class="line">    NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span> // 获取下一个<span class="title">pod</span>的抽象方法</span></div><div class="line"></div><div class="line">    // <span class="title">Error</span> <span class="title">is</span> <span class="title">called</span> <span class="title">if</span> <span class="title">there</span> <span class="title">is</span> <span class="title">an</span> <span class="title">error</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">passed</span> <span class="title">the</span> <span class="title">pod</span> <span class="title">in</span></div><div class="line">    // <span class="title">question</span>, <span class="title">and</span> <span class="title">the</span> <span class="title">error</span></div><div class="line">    <span class="title">Error</span> <span class="title">func</span><span class="params">(*api.Pod, error)</span> // 处理调度出现的错误</div><div class="line"></div><div class="line">    // <span class="title">Recorder</span> <span class="title">is</span> <span class="title">the</span> <span class="title">EventRecorder</span> <span class="title">to</span> <span class="title">use</span></div><div class="line">    <span class="title">Recorder</span> <span class="title">record</span>.<span class="title">EventRecorder</span></div><div class="line"></div><div class="line">    // <span class="title">Close</span> <span class="title">this</span> <span class="title">to</span> <span class="title">shut</span> <span class="title">down</span> <span class="title">the</span> <span class="title">scheduler</span>.</div><div class="line">    <span class="title">StopEverything</span> <span class="title">chan</span> <span class="title">struct</span>&#123;&#125; <span class="comment">// 停止信号</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Config</code> 类传入了 scheduler 必要的各种参数，相当于原来隶属于 scheduler 的成员变量通过它传入。<code>Config</code> 类在 <code>plugin/pkg/scheduler/factory</code> 中被实例化，相应的抽象方法也被传入实际的引用方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> &amp;scheduler.Config&#123;</div><div class="line">      SchedulerCache: f.schedulerCache,</div><div class="line">      <span class="comment">// The scheduler only needs to consider schedulable nodes.</span></div><div class="line">      NodeLister:          f.NodeLister.NodeCondition(getNodeConditionPredicate()),</div><div class="line">      Algorithm:           algo,</div><div class="line">      Binder:              &amp;binder&#123;f.Client&#125;,</div><div class="line">      PodConditionUpdater: &amp;podConditionUpdater&#123;f.Client&#125;,</div><div class="line">      NextPod: <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">          <span class="keyword">return</span> f.getNextPod()</div><div class="line">      &#125;,</div><div class="line">      Error:          f.makeDefaultErrorFunc(&amp;podBackoff, f.PodQueue),</div><div class="line">      StopEverything: f.StopEverything,</div><div class="line">  &#125;, <span class="literal">nil</span></div></pre></td></tr></table></figure>
<h2 id="获取待调度的-Pod"><a href="#获取待调度的-Pod" class="headerlink" title="获取待调度的 Pod"></a>获取待调度的 Pod</h2><p>首先看 <code>NextPod</code> 参数，从类 <code>Config</code> 的定义中的注释可以看到，这个参数是一个获取下一个 pod，并且阻塞该方法直到下一个 pod 可用为止。并且它的实现没有用 chanel，原因是一旦放到 chanel 里，这个 pod 便无法修改。这个 参数是在实例化时传入的获取下一个 pod 的方法。传入的代码也在这个文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ConfigFactory)</span> <span class="title">getNextPod</span><span class="params">()</span> *<span class="title">api</span>.<span class="title">Pod</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        pod := cache.Pop(f.PodQueue).(*api.Pod)</div><div class="line">        <span class="keyword">if</span> f.responsibleForPod(pod) &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v"</span>, pod.Name)</div><div class="line">            <span class="keyword">return</span> pod</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这段代码可以看出，获取下一个待调度的 pod 似乎是从一个队列中 pop 出一个 pod 来实现的。使用的来源是 <code>pkg/client/cache</code>，继续追踪：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(queue Queue)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    <span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</div><div class="line">    queue.Pop(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">        result = obj</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是个代理方法，是对 <code>Queue</code> 类中的 <code>Pop()</code> 方法进行了一层封装，于是自然看到对应的 <code>Queue.Pop()</code>，它是在类 <code>FIFO</code> 中的，那么这块儿也逐渐明了了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pkg/client/cache/fifo.go</span></div><div class="line"></div><div class="line"><span class="comment">// Pop waits until an item is ready and processes it. If multiple items are</span></div><div class="line"><span class="comment">// ready, they are returned in the order in which they were added/updated.</span></div><div class="line"><span class="comment">// The item is removed from the queue (and the store) before it is processed,</span></div><div class="line"><span class="comment">// so if you don't successfully process it, it should be added back with</span></div><div class="line"><span class="comment">// AddIfNotPresent(). process function is called under lock, so it is safe</span></div><div class="line"><span class="comment">// update data structures in it that need to be in sync with the queue.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    f.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> f.lock.Unlock()</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</div><div class="line">            f.cond.Wait()</div><div class="line">        &#125;</div><div class="line">        id := f.queue[<span class="number">0</span>]</div><div class="line">        f.queue = f.queue[<span class="number">1</span>:]</div><div class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</div><div class="line">            f.initialPopulationCount--</div><div class="line">        &#125;</div><div class="line">        item, ok := f.items[id]</div><div class="line">        <span class="keyword">if</span> !ok &#123;</div><div class="line">            <span class="comment">// Item may have been deleted subsequently.</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">delete</span>(f.items, id)</div><div class="line">        err := process(item)</div><div class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</div><div class="line">            f.addIfNotPresent(id, item)</div><div class="line">            err = e.Err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> item, err</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法算是这条路径的最后一个追踪的节点了。总结一下这条路径：</p>
<ol>
<li>kubernetes 的 cache 中维护了一个先进先出的队列 <code>FIFO</code>，它不同于 golang 中的 chanel，它支持对队列中的元素进行更新、删除等操作。</li>
<li>这个队列的 <code>FIFO.Pop()</code> 方法会队首元素（一个 pod）到达 ready 状态，然后将它弹出，否则阻塞该方法。</li>
<li><code>Scheduler</code> 类初始化时使用参数 <code>Config</code>，<code>Config</code> 中的 <code>NextPod()</code> 默认使用 <code>FIFO.Pop()</code>，当 <code>Scheduler</code> 需要进行调度时使用该方法得到下一个待调度的 pod。</li>
</ol>
<h2 id="使用调度算法进行实时调度"><a href="#使用调度算法进行实时调度" class="headerlink" title="使用调度算法进行实时调度"></a>使用调度算法进行实时调度</h2><p>回到 <code>Config</code> 类的第二个重要参数 <code>Algorithm</code>,它是对 pod 进行调度的实体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line">algo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, predicateMetaProducer, priorityConfigs, priorityMetaProducer, extenders)</div></pre></td></tr></table></figure>
<p>可以看到默认情况下，<code>Algorithm</code> 是用的通用调度器，接着看这个 <code>GenericScheduler</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/generic_scheduler.go</span></div><div class="line"></div><div class="line"><span class="comment">// Schedule tries to schedule the given pod to one of node in the node list.</span></div><div class="line"><span class="comment">// If it succeeds, it will return the name of the node.</span></div><div class="line"><span class="comment">// If it fails, it will return a Fiterror error with reasons.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">Schedule</span><span class="params">(pod *api.Pod, nodeLister algorithm.NodeLister)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> trace *util.Trace</div><div class="line">    <span class="keyword">if</span> pod != <span class="literal">nil</span> &#123;</div><div class="line">        trace = util.NewTrace(fmt.Sprintf(<span class="string">"Scheduling %s/%s"</span>, pod.Namespace, pod.Name))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        trace = util.NewTrace(<span class="string">"Scheduling &lt;nil&gt; pod"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</div><div class="line"></div><div class="line">    nodes, err := nodeLister.List() <span class="comment">// 获取所有节点</span></div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, ErrNoNodesAvailable</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Used for all fit and priority funcs.</span></div><div class="line">    err = g.cache.UpdateNodeNameToInfoMap(g.cachedNodeInfoMap)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// TODO(harryz) Check if equivalenceCache is enabled and call scheduleWithEquivalenceClass here</span></div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Computing predicates"</span>)</div><div class="line">    filteredNodes, failedPredicateMap, err := findNodesThatFit(pod, g.cachedNodeInfoMap, nodes, g.predicates, g.extenders, g.predicateMetaProducer)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filteredNodes) == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, &amp;FitError&#123;</div><div class="line">            Pod:              pod,</div><div class="line">            FailedPredicates: failedPredicateMap,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Prioritizing"</span>)</div><div class="line">    metaPrioritiesInterface := g.priorityMetaProducer(pod, g.cachedNodeInfoMap)</div><div class="line">    priorityList, err := PrioritizeNodes(pod, g.cachedNodeInfoMap, metaPrioritiesInterface, g.prioritizers, filteredNodes, g.extenders)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    trace.Step(<span class="string">"Selecting host"</span>)</div><div class="line">    <span class="keyword">return</span> g.selectHost(priorityList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，GenericScheduler 进行调度为以下过程：</p>
<ol>
<li>从 <code>NodeList</code> 获取所有的节点</li>
<li>通过所给的断言函数（<code>predicates</code>）对所有节点进行过滤，选出符合的节点（<code>findNodesThatFit()</code>）</li>
<li>根据所给的打分函数（<code>prioritizers</code>）对过滤后的节点进行排序（<code>PrioritizeNodes()</code>）</li>
<li>通过 round-robin 方式依次获取分数最高的节点来运行 pod。</li>
</ol>
<h2 id="调度失败"><a href="#调度失败" class="headerlink" title="调度失败"></a>调度失败</h2><p>在 <code>Config</code> 类的 <code>Error</code> 参数中传入了调度失败的处理方法 <code>makeDefaultErrorFunc()</code> 对调度失败的 pod 进行重调度处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// plugin/pkg/scheduler/factory/factory.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(factory *ConfigFactory)</span> <span class="title">makeDefaultErrorFunc</span><span class="params">(backoff *podBackoff, podQueue *cache.FIFO)</span> <span class="title">func</span><span class="params">(pod *api.Pod, err error)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(pod *api.Pod, err error)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> err == scheduler.ErrNoNodesAvailable &#123;</div><div class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"Unable to schedule %v %v: no nodes are registered to the cluster; waiting"</span>, pod.Namespace, pod.Name)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            glog.Errorf(<span class="string">"Error scheduling %v %v: %v; retrying"</span>, pod.Namespace, pod.Name, err)</div><div class="line">        &#125;</div><div class="line">        backoff.gc() <span class="comment">// 清空backoff列表</span></div><div class="line">        <span class="comment">// Retry asynchronously.</span></div><div class="line">        <span class="comment">// Note that this is extremely rudimentary and we need a more real error handling path.</span></div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">            <span class="keyword">defer</span> runtime.HandleCrash()</div><div class="line">            podID := types.NamespacedName&#123;</div><div class="line">                Namespace: pod.Namespace,</div><div class="line">                Name:      pod.Name,</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            entry := backoff.getEntry(podID)</div><div class="line">            <span class="keyword">if</span> !entry.TryWait(backoff.maxDuration) &#123;</div><div class="line">                glog.Warningf(<span class="string">"Request for pod %v already in flight, abandoning"</span>, podID)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Get the pod again; it may have changed/been scheduled already.</span></div><div class="line">            getBackoff := initialGetBackoff</div><div class="line">            <span class="keyword">for</span> &#123;</div><div class="line">                pod, err := factory.Client.Core().Pods(podID.Namespace).Get(podID.Name)</div><div class="line">                <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> &#123;</div><div class="line">                        podQueue.AddIfNotPresent(pod) <span class="comment">// 重新将pod加入调度队列</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> errors.IsNotFound(err) &#123;</div><div class="line">                    glog.Warningf(<span class="string">"A pod %v no longer exists"</span>, podID)</div><div class="line">                    <span class="keyword">return</span></div><div class="line">                &#125;</div><div class="line">                glog.Errorf(<span class="string">"Error getting pod %v for retry: %v; retrying..."</span>, podID, err)</div><div class="line">                <span class="keyword">if</span> getBackoff = getBackoff * <span class="number">2</span>; getBackoff &gt; maximalGetBackoff &#123;</div><div class="line">                    getBackoff = maximalGetBackoff</div><div class="line">                &#125;</div><div class="line">                time.Sleep(getBackoff)</div><div class="line">            &#125;</div><div class="line">        &#125;()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从该处理方法看出，一旦出现调度失败，k8s 并不会阻塞调度过程，而是将调度失败的 pod 扔到这个失败处理方法里，而这个方法是通过异步的方式进行重试。k8s 从 backoff 这个列表中拿出指定的 pod，然后将它再次放到 <code>FIFO</code> 队列里，期间如果继续失败，再扔进 backoff 里异步等待处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>k8s 的代码量非常庞大，需要快速定位源码比较困难，而采用这种根据从入口不断深入的阅读方式会减少很多工作量，只关心一部分的代码。当然这也无法从一个宏观的角度去看整个代码的设计，但是对于当前的工作已经足够。</p>

  	</div>
	  
	  <div class="article-tags tags">
		  
        <a class="tag-link" href="/tags/kubernetes/">kubernetes</a><a class="tag-link" href="/tags/scheduler/">scheduler</a>
      
	  </div>
	</section>
</article>


<section id="comments">
	<div id="disqus_thread"></div>
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" class="u-search-input" placeholder="Looking for something?" />
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/artchen" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/otakism" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
        <a href="https://plus.google.com/+ArtChenOtakism/posts" class="social google"
          target="_blank" rel="external">
          <span class="icon icon-google"></span>
        </a>
      
        <a href="http://weibo.com/otakism/" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">JetMuffin&#39;s Blog</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'jetmuffin';
  
  var disqus_url = 'http://blog.jetmuffin.com/2016/11/24/kubernetes-code-reading-scheduler/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
